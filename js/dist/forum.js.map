{"version":3,"sources":["webpack://@aradeid/flarum-references/webpack/bootstrap","webpack://@aradeid/flarum-references/external \"flarum.core.compat['common/utils/Stream']\"","webpack://@aradeid/flarum-references/external \"flarum.core.compat['components/Button']\"","webpack://@aradeid/flarum-references/external \"flarum.core.compat['app']\"","webpack://@aradeid/flarum-references/external \"flarum.core.compat['components/Modal']\"","webpack://@aradeid/flarum-references/external \"flarum.core.compat['common/extend']\"","webpack://@aradeid/flarum-references/external \"flarum.core.compat['components/ComposerBody']\"","webpack://@aradeid/flarum-references/./node_modules/@babel/runtime/regenerator/index.js","webpack://@aradeid/flarum-references/external \"flarum.core.compat['common/components/Alert']\"","webpack://@aradeid/flarum-references/external \"flarum.core.compat['common/components/TextEditor']\"","webpack://@aradeid/flarum-references/external \"flarum.core.compat['forum/components/CommentPost']\"","webpack://@aradeid/flarum-references/external \"flarum.core.compat['common/components/Tooltip']\"","webpack://@aradeid/flarum-references/external \"flarum.core.compat['common/utils/ItemList']\"","webpack://@aradeid/flarum-references/external \"flarum.core.compat['common/helpers/listItems']\"","webpack://@aradeid/flarum-references/./node_modules/regenerator-runtime/runtime.js","webpack://@aradeid/flarum-references/./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","webpack://@aradeid/flarum-references/./node_modules/orderedmap/index.es.js","webpack://@aradeid/flarum-references/../src/fragment.js","webpack://@aradeid/flarum-references/../src/diff.js","webpack://@aradeid/flarum-references/../src/comparedeep.js","webpack://@aradeid/flarum-references/../src/mark.js","webpack://@aradeid/flarum-references/../src/replace.js","webpack://@aradeid/flarum-references/../src/resolvedpos.js","webpack://@aradeid/flarum-references/../src/node.js","webpack://@aradeid/flarum-references/../src/content.js","webpack://@aradeid/flarum-references/../src/schema.js","webpack://@aradeid/flarum-references/../src/from_dom.js","webpack://@aradeid/flarum-references/../src/to_dom.js","webpack://@aradeid/flarum-references/../src/map.js","webpack://@aradeid/flarum-references/../src/transform.js","webpack://@aradeid/flarum-references/../src/step.js","webpack://@aradeid/flarum-references/../src/replace_step.js","webpack://@aradeid/flarum-references/../src/structure.js","webpack://@aradeid/flarum-references/../src/mark_step.js","webpack://@aradeid/flarum-references/../src/selection.js","webpack://@aradeid/flarum-references/../src/transaction.js","webpack://@aradeid/flarum-references/../src/state.js","webpack://@aradeid/flarum-references/../src/plugin.js","webpack://@aradeid/flarum-references/../src/commands.js","webpack://@aradeid/flarum-references/../src/inputrules.js","webpack://@aradeid/flarum-references/../src/rules.js","webpack://@aradeid/flarum-references/./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","webpack://@aradeid/flarum-references/./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","webpack://@aradeid/flarum-references/./src/forum/components/DefaultRefModal.js","webpack://@aradeid/flarum-references/./src/forum/components/SiteRefModal.js","webpack://@aradeid/flarum-references/./src/forum/components/BookRefModal.js","webpack://@aradeid/flarum-references/./src/forum/components/NewsRefModal.js","webpack://@aradeid/flarum-references/./src/forum/components/JournalRefModal.js","webpack://@aradeid/flarum-references/./src/forum/components/ReferencesModal.js","webpack://@aradeid/flarum-references/./src/forum/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","flarum","core","compat","require","runtime","Op","hasOwn","$Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","define","obj","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","context","Context","_invoke","state","method","arg","Error","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","done","makeInvokeMethod","fn","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","undefined","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","displayName","isGeneratorFunction","genFun","ctor","constructor","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","globalThis","Function","asyncGeneratorStep","gen","_next","_throw","_asyncToGenerator","args","arguments","apply","OrderedMap","content","find","found","update","newKey","remove","splice","addToStart","concat","addToEnd","addBefore","place","without","f","prepend","map","from","size","subtract","append","prop","orderedmap","Fragment","let","nodeSize","nodesBetween","to","nodeStart","parent","pos","child","end","start","Math","max","min","descendants","textBetween","blockSeparator","leafText","text","separated","node","isText","isLeaf","isBlock","other","last","lastChild","first","firstChild","sameMarkup","withText","cut","cutByIndex","empty","replaceChild","index","current","copy","eq","prototypeAccessors","childCount","RangeError","maybeChild","findDiffStart","a","b","childA","childB","j","inner","findDiffEnd","otherPos","posA","posB","iA","iB","same","minSize","findIndex","round","retIndex","curPos","toString","toStringInner","join","toJSON","fromJSON","schema","Array","isArray","nodeFromJSON","fromArray","array","joined","nodes","attrs","const","offset","compareDeep","Mark","ReplaceError","message","addToSet","set","placed","excludes","rank","removeFromSet","isInSet","_","json","marks","sameSet","setFrom","none","sort","Slice","openStart","openEnd","replace","$from","$to","depth","replaceOuter","$along","extra","resolveNoCache","prepareSliceForReplace","close","replaceThreeWay","$start","$end","joinable","addRange","checkJoin","addNode","replaceTwoWay","parentOffset","main","sub","compatibleContent","$before","$after","target","startIndex","endIndex","textOffset","nodeAfter","nodeBefore","validContent","insertAt","fragment","insertInto","dist","insert","canReplace","removeBetween","removeRange","offsetTo","indexTo","maxOpen","openIsolating","spec","isolating","ResolvedPos","path","resolveDepth","val","doc","indexAfter","before","after","dOff","posAtIndex","tmp","inclusive","marksAcross","isInline","sharedDepth","blockRange","pred","inlineContent","NodeRange","sameParent","str","rem","resolveCached","resolveCache","cached","resolveCachePos","resolveCacheSize","prototypeAccessors$1","emptyAttrs","Node","startPos","textContent","hasMarkup","defaultAttrs","includeParents","nodeAt","childAfter","childBefore","rangeHasMark","isTextblock","isAtom","toDebugString","wrapMarks","contentMatchAt","match","contentMatch","matchFragment","replacement","one","two","validEnd","allowsMarks","canReplaceWith","matchType","canAppend","check","markFromJSON","nodeType","TextNode","super","JSON","stringify","base","ContentMatch","wrapCache","parse","string","nodeTypes","stream","TokenStream","expr","parseExpr","nfa","labeled","explore","states","out","term","known","indexOf","nullFrom","cmp","dfa","connect","compile","exprs","reduce","loop","edge","cur","edges","work","dead","hasRequiredAttrs","checkForDeadEnds","frag","defaultType","compatible","fillBefore","toEnd","seen","search","types","finished","tp","createAndFill","findWrapping","computed","computeWrapping","active","via","shift","edgeCount","scan","inline","tokens","split","parseExprSeq","eat","parseExprSubscript","test","typeName","groups","resolveName","parseExprAtom","parseExprRange","parseNum","Number","defaults","attrName","attr","hasDefault","computeAttrs","built","given","initAttrs","Attribute","tok","SyntaxError","NodeType","group","markSet","atom","whitespace","code","isRequired","createChecked","allowsMarkType","markType","allowedMarks","topType","topNode","options","MarkType","excluded","instance","Schema","contentExprCache","contentExpr","markExpr","gatherMarks","excl","topNodeType","wrappings","ok","DOMParser","rules","tags","styles","rule","tag","style","normalizeLists","some","dom","ParseContext","addAll","parseSlice","matchTag","matches","namespace","namespaceURI","matchesContext","getAttrs","matchStyle","charCodeAt","schemaRules","priority","parseDOM","fromSchema","domParser","blockTags","address","article","aside","blockquote","canvas","dd","div","dl","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","hr","li","noscript","ol","output","pre","section","table","tfoot","ul","ignoreTags","head","script","title","listTags","wsOptionsFor","preserveWhitespace","OPT_PRESERVE_WS","NodeContext","pendingMarks","solid","activeMarks","stashMarks","fill","exec","popFromStashMark","applyPending","nextType","pending","markMayApply","inlineContext","parentNode","nodeName","toLowerCase","parser","open","isOpen","topContext","topOptions","topMatch","findPositions","needsBlock","selector","msMatchesSelector","webkitMatchesSelector","mozMatchesSelector","v","top","addDOM","addTextNode","getAttribute","readStyles","re","trim","parseStyles","addPendingMark","addElement","removePendingMark","nodeValue","domNodeBefore","previousSibling","insertNode","findInText","findInside","matchAfter","ruleID","prevItem","nextSibling","appendChild","normalizeList","ruleFromNode","ignore","ignoreFallback","skip","closeParent","sync","oldNeedsBlock","leafFallback","addElementByRule","consuming","ownerDocument","createTextNode","findPlace","continueAfter","enter","startIn","getContent","contentDOM","contentElement","querySelector","findAround","childNodes","findAtPoint","route","cx","enterInner","block","textblockFromContext","closeExtra","preserveWS","topOpen","currentPos","contains","compareDocumentPosition","textNode","parts","option","useRoot","minDepth","part","$context","deflt","findSameMarkInSet","upto","level","lastIndexOf","stashMark","DOMSerializer","gatherToDOM","toDOM","document","window","serializeFragment","createDocumentFragment","keep","rendered","spanning","add","markDOM","serializeMark","serializeNodeInner","renderSpec","onContent","serializeNode","structure","xmlNS","tagName","space","createElementNS","createElement","setAttributeNS","setAttribute","innerContent","domSerializer","nodesFromSchema","marksFromSchema","factor16","pow","recoverIndex","MapResult","deleted","recover","StepMap","ranges","inverted","diff","recoverOffset","mapResult","assoc","_map","simple","oldIndex","newIndex","oldSize","newSize","touches","oldStart","newStart","invert","Mapping","maps","mirror","TransformError","appendMap","mirrors","setMirror","appendMapping","mapping","startSize","mirr","getMirror","appendMappingInverted","totalSize","inverse","corr","Transform","steps","docs","mustOverride","step","maybeStep","failed","addStep","docChanged","getMap","stepsByID","Step","_doc","_mapping","merge","_other","stepType","jsonID","id","stepClass","StepResult","fail","fromReplace","e","ReplaceStep","contentBetween","ReplaceAroundStep","gapFrom","gapTo","gap","inserted","canCut","liftTarget","range","canSplit","typesAfter","$pos","innerType","rest","baseType","canJoin","mapFragment","mapped","lift","gapStart","gapEnd","splitting","wrappers","setBlockType","mapFrom","canChangeType","clearIncompatible","startM","endM","setNodeMarkup","newNode","replaceWith","typeAfter","AddMarkStep","oldSlice","RemoveMarkStep","replaceStep","fitsTrivially","Fitter","fit","addMark","removed","added","removing","adding","newSet","removeMark","matched","toRemove","parentType","delSteps","allowed","unplaced","frontier","dropFromFragment","count","addToFragment","contentAt","closeNodeStart","contentAfterFits","invalidMarks","closeFragment","oldOpen","newOpen","coveredDepths","findFittable","placeNodes","openMore","dropNode","moveInline","mustMoveInline","placedSize","pass","sliceDepth","frontierDepth","inject","openAtEnd","closeFrontierNode","openFrontierNode","taken","openEndCount","findCloseLevel","dropInner","move","replaceRange","deleteRange","targetDepths","preferredTarget","unshift","defining","preferredTargetIndex","leftNodes","preferredDepth","openDepth","targetDepth","expand","startSteps","replaceRangeWith","point","insertPoint","covered","classesById","Selection","$anchor","$head","SelectionRange","anchor","tr","lastNode","lastParent","selectionToInsertionEnd","findFrom","dir","textOnly","TextSelection","findSelectionIn","near","bias","AllSelection","atStart","atEnd","cls","selectionClass","getBookmark","between","visible","$cursor","ensureMarks","TextBookmark","dPos","NodeSelection","NodeBookmark","isSelectable","selectable","sel","selection","setSelection","AllBookmark","startLen","_from","_to","_newFrom","newTo","Transaction","time","Date","now","curSelection","curSelectionFor","storedMarks","updated","meta","selectionSet","setStoredMarks","addStoredMark","removeStoredMark","storedMarksSet","setTime","replaceSelection","replaceSelectionWith","inheritMarks","deleteSelection","insertText","setMeta","getMeta","isGeneric","scrollIntoView","scrolledIntoView","FieldDesc","desc","init","baseFields","config","_marks","_old","Configuration","plugins","fields","pluginsByKey","plugin","EditorState","applyTransaction","filterTransaction","rootTr","transactions","trs","newState","applyInner","haveNew","appendTransaction","oldState","newInstance","field","applyListeners","$config","reconfigure","pluginFields","addApplyListener","removeApplyListener","Plugin","props","bindProps","createKey","getState","PluginKey","dispatch","textblockAt","side","only","findCutBefore","findCutAfter","defaultBlockAt","splitBlock","can","$first","deleteBarrier","$cut","conn","joinMaybeClear","canDelAfter","joinAt","selAfter","at","afterText","afterDepth","selectTextblockSide","selectTextblockStart","selectTextblockEnd","chainCommands","view","commands","backspace","endOfTextblock","delStep","del","pcBaseKeymap","above","macBaseKeymap","Home","End","baseKeymap","navigator","platform","os","InputRule","handler","cutOff","_setPrototypeOf","_inheritsLoose","subClass","superClass","DefaultRefModal","oninit","vnode","app","composer","allReferences","referenceId","Stream","link","className","translator","trans","placeholder","required","oninput","removeRedStyle","Button","component","onclick","addReference","requiredFields","$","k","validity","valid","removeAttribute","areSetRequiredFields","setProperty","date","extensions","editor","insertAtCursor","position","getSelectionRange","moveCursorTo","menuState","editorView","outerText","setEnter","getDate","getMonth","getFullYear","setSelectionRange","console","log","el","modal","Modal","SiteRefModal","author","createAt","siteName","bidi","pattern","BookRefModal","year","editura","NewsRefModal","JournalRefModal","ReferencesModal","show","class","initializers","ProseMirrorEditorDriver","proseMirror","extend","TextEditor","items","Tooltip","icon","ComposerBody","sidebarMenu","ItemList","loading","loadingButton","linkControl","fetch","body","url","headers","response","success","every","ref","alerts","Alert","unaccesibleIndexes","filter","indexes","children","listItems","toArray","CommentPost","baseUrl","forum","attribute","classList","href","startsWith","elements","separateId","addEventListener","preventDefault","reference","getElementById","behavior","element","querySelectorAll"],"mappings":"2BACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QA0Df,OArDAF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,oBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,GAIjBlC,EAAoBA,EAAoBmC,EAAI,I,gBClFrDhC,EAAOD,QAAUkC,OAAOC,KAAKC,OAAO,wB,cCApCnC,EAAOD,QAAUkC,OAAOC,KAAKC,OAAO,sB,cCApCnC,EAAOD,QAAUkC,OAAOC,KAAKC,OAAY,K,cCAzCnC,EAAOD,QAAUkC,OAAOC,KAAKC,OAAO,qB,cCApCnC,EAAOD,QAAUkC,OAAOC,KAAKC,OAAO,kB,cCApCnC,EAAOD,QAAUkC,OAAOC,KAAKC,OAAO,4B,gBCApCnC,EAAOD,QAAUqC,EAAQ,K,cCAzBpC,EAAOD,QAAUkC,OAAOC,KAAKC,OAAO,4B,eCApCnC,EAAOD,QAAUkC,OAAOC,KAAKC,OAAO,iC,cCApCnC,EAAOD,QAAUkC,OAAOC,KAAKC,OAAO,iC,cCApCnC,EAAOD,QAAUkC,OAAOC,KAAKC,OAAO,8B,cCApCnC,EAAOD,QAAUkC,OAAOC,KAAKC,OAAO,0B,cCApCnC,EAAOD,QAAUkC,OAAOC,KAAKC,OAAO,6B,gBCOpC,IAAIE,EAAW,SAAUtC,GACvB,aAEA,IAAIuC,EAAK3B,OAAOkB,UACZU,EAASD,EAAGR,eAEZU,EAA4B,mBAAXxB,OAAwBA,OAAS,GAClDyB,EAAiBD,EAAQE,UAAY,aACrCC,EAAsBH,EAAQI,eAAiB,kBAC/CC,EAAoBL,EAAQvB,aAAe,gBAE/C,SAAS6B,EAAOC,EAAKvB,EAAKN,GAOxB,OANAP,OAAOC,eAAemC,EAAKvB,EAAK,CAC9BN,MAAOA,EACPL,YAAY,EACZmC,cAAc,EACdC,UAAU,IAELF,EAAIvB,GAEb,IAEEsB,EAAO,GAAI,IACX,MAAOI,GACPJ,EAAS,SAASC,EAAKvB,EAAKN,GAC1B,OAAO6B,EAAIvB,GAAON,GAItB,SAASiC,EAAKC,EAASC,EAASC,EAAMC,GAEpC,IAAIC,EAAiBH,GAAWA,EAAQxB,qBAAqB4B,EAAYJ,EAAUI,EAC/EC,EAAY/C,OAAOY,OAAOiC,EAAe3B,WACzC8B,EAAU,IAAIC,EAAQL,GAAe,IAMzC,OAFAG,EAAUG,QAuMZ,SAA0BT,EAASE,EAAMK,GACvC,IAAIG,EAhLuB,iBAkL3B,OAAO,SAAgBC,EAAQC,GAC7B,GAjLoB,cAiLhBF,EACF,MAAM,IAAIG,MAAM,gCAGlB,GApLoB,cAoLhBH,EAA6B,CAC/B,GAAe,UAAXC,EACF,MAAMC,EAKR,OAAOE,IAMT,IAHAP,EAAQI,OAASA,EACjBJ,EAAQK,IAAMA,IAED,CACX,IAAIG,EAAWR,EAAQQ,SACvB,GAAIA,EAAU,CACZ,IAAIC,EAAiBC,EAAoBF,EAAUR,GACnD,GAAIS,EAAgB,CAClB,GAAIA,IAAmBE,EAAkB,SACzC,OAAOF,GAIX,GAAuB,SAAnBT,EAAQI,OAGVJ,EAAQY,KAAOZ,EAAQa,MAAQb,EAAQK,SAElC,GAAuB,UAAnBL,EAAQI,OAAoB,CACrC,GApNqB,mBAoNjBD,EAEF,MADAA,EAlNc,YAmNRH,EAAQK,IAGhBL,EAAQc,kBAAkBd,EAAQK,SAEN,WAAnBL,EAAQI,QACjBJ,EAAQe,OAAO,SAAUf,EAAQK,KAGnCF,EA7NkB,YA+NlB,IAAIa,EAASC,EAASxB,EAASE,EAAMK,GACrC,GAAoB,WAAhBgB,EAAOE,KAAmB,CAO5B,GAJAf,EAAQH,EAAQmB,KAlOA,YAFK,iBAwOjBH,EAAOX,MAAQM,EACjB,SAGF,MAAO,CACLpD,MAAOyD,EAAOX,IACdc,KAAMnB,EAAQmB,MAGS,UAAhBH,EAAOE,OAChBf,EAhPgB,YAmPhBH,EAAQI,OAAS,QACjBJ,EAAQK,IAAMW,EAAOX,OA/QPe,CAAiB3B,EAASE,EAAMK,GAE7CD,EAcT,SAASkB,EAASI,EAAIjC,EAAKiB,GACzB,IACE,MAAO,CAAEa,KAAM,SAAUb,IAAKgB,EAAG5E,KAAK2C,EAAKiB,IAC3C,MAAOd,GACP,MAAO,CAAE2B,KAAM,QAASb,IAAKd,IAhBjCnD,EAAQoD,KAAOA,EAoBf,IAOImB,EAAmB,GAMvB,SAASb,KACT,SAASwB,KACT,SAASC,KAIT,IAAIC,EAAoB,GACxBrC,EAAOqC,EAAmB1C,GAAgB,WACxC,OAAO2C,QAGT,IAAIC,EAAW1E,OAAO2E,eAClBC,EAA0BF,GAAYA,EAASA,EAASG,EAAO,MAC/DD,GACAA,IAA4BjD,GAC5BC,EAAOnC,KAAKmF,EAAyB9C,KAGvC0C,EAAoBI,GAGtB,IAAIE,EAAKP,EAA2BrD,UAClC4B,EAAU5B,UAAYlB,OAAOY,OAAO4D,GAYtC,SAASO,EAAsB7D,GAC7B,CAAC,OAAQ,QAAS,UAAU8D,SAAQ,SAAS5B,GAC3CjB,EAAOjB,EAAWkC,GAAQ,SAASC,GACjC,OAAOoB,KAAKvB,QAAQE,EAAQC,SAkClC,SAAS4B,EAAclC,EAAWmC,GAgChC,IAAIC,EAgCJV,KAAKvB,QA9BL,SAAiBE,EAAQC,GACvB,SAAS+B,IACP,OAAO,IAAIF,GAAY,SAASG,EAASC,IAnC7C,SAASC,EAAOnC,EAAQC,EAAKgC,EAASC,GACpC,IAAItB,EAASC,EAASlB,EAAUK,GAASL,EAAWM,GACpD,GAAoB,UAAhBW,EAAOE,KAEJ,CACL,IAAIsB,EAASxB,EAAOX,IAChB9C,EAAQiF,EAAOjF,MACnB,OAAIA,GACiB,iBAAVA,GACPqB,EAAOnC,KAAKc,EAAO,WACd2E,EAAYG,QAAQ9E,EAAMkF,SAASC,MAAK,SAASnF,GACtDgF,EAAO,OAAQhF,EAAO8E,EAASC,MAC9B,SAAS/C,GACVgD,EAAO,QAAShD,EAAK8C,EAASC,MAI3BJ,EAAYG,QAAQ9E,GAAOmF,MAAK,SAASC,GAI9CH,EAAOjF,MAAQoF,EACfN,EAAQG,MACP,SAASI,GAGV,OAAOL,EAAO,QAASK,EAAOP,EAASC,MAvBzCA,EAAOtB,EAAOX,KAiCZkC,CAAOnC,EAAQC,EAAKgC,EAASC,MAIjC,OAAOH,EAaLA,EAAkBA,EAAgBO,KAChCN,EAGAA,GACEA,KAkHV,SAAS1B,EAAoBF,EAAUR,GACrC,IAAII,EAASI,EAASzB,SAASiB,EAAQI,QACvC,QA3TEyC,IA2TEzC,EAAsB,CAKxB,GAFAJ,EAAQQ,SAAW,KAEI,UAAnBR,EAAQI,OAAoB,CAE9B,GAAII,EAASzB,SAAT,SAGFiB,EAAQI,OAAS,SACjBJ,EAAQK,SAtUZwC,EAuUInC,EAAoBF,EAAUR,GAEP,UAAnBA,EAAQI,QAGV,OAAOO,EAIXX,EAAQI,OAAS,QACjBJ,EAAQK,IAAM,IAAIyC,UAChB,kDAGJ,OAAOnC,EAGT,IAAIK,EAASC,EAASb,EAAQI,EAASzB,SAAUiB,EAAQK,KAEzD,GAAoB,UAAhBW,EAAOE,KAIT,OAHAlB,EAAQI,OAAS,QACjBJ,EAAQK,IAAMW,EAAOX,IACrBL,EAAQQ,SAAW,KACZG,EAGT,IAAIoC,EAAO/B,EAAOX,IAElB,OAAM0C,EAOFA,EAAK5B,MAGPnB,EAAQQ,EAASwC,YAAcD,EAAKxF,MAGpCyC,EAAQiD,KAAOzC,EAAS0C,QAQD,WAAnBlD,EAAQI,SACVJ,EAAQI,OAAS,OACjBJ,EAAQK,SA1XVwC,GAoYF7C,EAAQQ,SAAW,KACZG,GANEoC,GA3BP/C,EAAQI,OAAS,QACjBJ,EAAQK,IAAM,IAAIyC,UAAU,oCAC5B9C,EAAQQ,SAAW,KACZG,GAoDX,SAASwC,EAAaC,GACpB,IAAIC,EAAQ,CAAEC,OAAQF,EAAK,IAEvB,KAAKA,IACPC,EAAME,SAAWH,EAAK,IAGpB,KAAKA,IACPC,EAAMG,WAAaJ,EAAK,GACxBC,EAAMI,SAAWL,EAAK,IAGxB3B,KAAKiC,WAAWC,KAAKN,GAGvB,SAASO,EAAcP,GACrB,IAAIrC,EAASqC,EAAMQ,YAAc,GACjC7C,EAAOE,KAAO,gBACPF,EAAOX,IACdgD,EAAMQ,WAAa7C,EAGrB,SAASf,EAAQL,GAIf6B,KAAKiC,WAAa,CAAC,CAAEJ,OAAQ,SAC7B1D,EAAYoC,QAAQmB,EAAc1B,MAClCA,KAAKqC,OAAM,GA8Bb,SAASjC,EAAOkC,GACd,GAAIA,EAAU,CACZ,IAAIC,EAAiBD,EAASjF,GAC9B,GAAIkF,EACF,OAAOA,EAAevH,KAAKsH,GAG7B,GAA6B,mBAAlBA,EAASd,KAClB,OAAOc,EAGT,IAAKE,MAAMF,EAASG,QAAS,CAC3B,IAAI5H,GAAK,EAAG2G,EAAO,SAASA,IAC1B,OAAS3G,EAAIyH,EAASG,QACpB,GAAItF,EAAOnC,KAAKsH,EAAUzH,GAGxB,OAFA2G,EAAK1F,MAAQwG,EAASzH,GACtB2G,EAAK9B,MAAO,EACL8B,EAOX,OAHAA,EAAK1F,WA1eTsF,EA2eII,EAAK9B,MAAO,EAEL8B,GAGT,OAAOA,EAAKA,KAAOA,GAKvB,MAAO,CAAEA,KAAM1C,GAIjB,SAASA,IACP,MAAO,CAAEhD,WA1fPsF,EA0fyB1B,MAAM,GA+MnC,OA7mBAG,EAAkBpD,UAAYqD,EAC9BpC,EAAO2C,EAAI,cAAeP,GAC1BpC,EAAOoC,EAA4B,cAAeD,GAClDA,EAAkB6C,YAAchF,EAC9BoC,EACArC,EACA,qBAaF9C,EAAQgI,oBAAsB,SAASC,GACrC,IAAIC,EAAyB,mBAAXD,GAAyBA,EAAOE,YAClD,QAAOD,IACHA,IAAShD,GAG2B,uBAAnCgD,EAAKH,aAAeG,EAAKzH,QAIhCT,EAAQoI,KAAO,SAASH,GAQtB,OAPIrH,OAAOyH,eACTzH,OAAOyH,eAAeJ,EAAQ9C,IAE9B8C,EAAOK,UAAYnD,EACnBpC,EAAOkF,EAAQnF,EAAmB,sBAEpCmF,EAAOnG,UAAYlB,OAAOY,OAAOkE,GAC1BuC,GAOTjI,EAAQuI,MAAQ,SAAStE,GACvB,MAAO,CAAEoC,QAASpC,IAsEpB0B,EAAsBE,EAAc/D,WACpCiB,EAAO8C,EAAc/D,UAAWc,GAAqB,WACnD,OAAOyC,QAETrF,EAAQ6F,cAAgBA,EAKxB7F,EAAQwI,MAAQ,SAASnF,EAASC,EAASC,EAAMC,EAAasC,QACxC,IAAhBA,IAAwBA,EAAc2C,SAE1C,IAAIC,EAAO,IAAI7C,EACbzC,EAAKC,EAASC,EAASC,EAAMC,GAC7BsC,GAGF,OAAO9F,EAAQgI,oBAAoB1E,GAC/BoF,EACAA,EAAK7B,OAAOP,MAAK,SAASF,GACxB,OAAOA,EAAOrB,KAAOqB,EAAOjF,MAAQuH,EAAK7B,WAuKjDlB,EAAsBD,GAEtB3C,EAAO2C,EAAI5C,EAAmB,aAO9BC,EAAO2C,EAAIhD,GAAgB,WACzB,OAAO2C,QAGTtC,EAAO2C,EAAI,YAAY,WACrB,MAAO,wBAkCT1F,EAAQ2I,KAAO,SAAS/G,GACtB,IAAI+G,EAAO,GACX,IAAK,IAAIlH,KAAOG,EACd+G,EAAKpB,KAAK9F,GAMZ,OAJAkH,EAAKC,UAIE,SAAS/B,IACd,KAAO8B,EAAKb,QAAQ,CAClB,IAAIrG,EAAMkH,EAAKE,MACf,GAAIpH,KAAOG,EAGT,OAFAiF,EAAK1F,MAAQM,EACboF,EAAK9B,MAAO,EACL8B,EAQX,OADAA,EAAK9B,MAAO,EACL8B,IAsCX7G,EAAQyF,OAASA,EAMjB5B,EAAQ/B,UAAY,CAClBqG,YAAatE,EAEb6D,MAAO,SAASoB,GAcd,GAbAzD,KAAK0D,KAAO,EACZ1D,KAAKwB,KAAO,EAGZxB,KAAKb,KAAOa,KAAKZ,WArgBjBgC,EAsgBApB,KAAKN,MAAO,EACZM,KAAKjB,SAAW,KAEhBiB,KAAKrB,OAAS,OACdqB,KAAKpB,SA1gBLwC,EA4gBApB,KAAKiC,WAAW1B,QAAQ4B,IAEnBsB,EACH,IAAK,IAAIrI,KAAQ4E,KAEQ,MAAnB5E,EAAKuI,OAAO,IACZxG,EAAOnC,KAAKgF,KAAM5E,KACjBoH,OAAOpH,EAAKwI,MAAM,MACrB5D,KAAK5E,QAphBXgG,IA0hBFyC,KAAM,WACJ7D,KAAKN,MAAO,EAEZ,IACIoE,EADY9D,KAAKiC,WAAW,GACLG,WAC3B,GAAwB,UAApB0B,EAAWrE,KACb,MAAMqE,EAAWlF,IAGnB,OAAOoB,KAAK+D,MAGd1E,kBAAmB,SAAS2E,GAC1B,GAAIhE,KAAKN,KACP,MAAMsE,EAGR,IAAIzF,EAAUyB,KACd,SAASiE,EAAOC,EAAKC,GAYnB,OAXA5E,EAAOE,KAAO,QACdF,EAAOX,IAAMoF,EACbzF,EAAQiD,KAAO0C,EAEXC,IAGF5F,EAAQI,OAAS,OACjBJ,EAAQK,SArjBZwC,KAwjBY+C,EAGZ,IAAK,IAAItJ,EAAImF,KAAKiC,WAAWQ,OAAS,EAAG5H,GAAK,IAAKA,EAAG,CACpD,IAAI+G,EAAQ5B,KAAKiC,WAAWpH,GACxB0E,EAASqC,EAAMQ,WAEnB,GAAqB,SAAjBR,EAAMC,OAIR,OAAOoC,EAAO,OAGhB,GAAIrC,EAAMC,QAAU7B,KAAK0D,KAAM,CAC7B,IAAIU,EAAWjH,EAAOnC,KAAK4G,EAAO,YAC9ByC,EAAalH,EAAOnC,KAAK4G,EAAO,cAEpC,GAAIwC,GAAYC,EAAY,CAC1B,GAAIrE,KAAK0D,KAAO9B,EAAME,SACpB,OAAOmC,EAAOrC,EAAME,UAAU,GACzB,GAAI9B,KAAK0D,KAAO9B,EAAMG,WAC3B,OAAOkC,EAAOrC,EAAMG,iBAGjB,GAAIqC,GACT,GAAIpE,KAAK0D,KAAO9B,EAAME,SACpB,OAAOmC,EAAOrC,EAAME,UAAU,OAG3B,KAAIuC,EAMT,MAAM,IAAIxF,MAAM,0CALhB,GAAImB,KAAK0D,KAAO9B,EAAMG,WACpB,OAAOkC,EAAOrC,EAAMG,gBAU9BzC,OAAQ,SAASG,EAAMb,GACrB,IAAK,IAAI/D,EAAImF,KAAKiC,WAAWQ,OAAS,EAAG5H,GAAK,IAAKA,EAAG,CACpD,IAAI+G,EAAQ5B,KAAKiC,WAAWpH,GAC5B,GAAI+G,EAAMC,QAAU7B,KAAK0D,MACrBvG,EAAOnC,KAAK4G,EAAO,eACnB5B,KAAK0D,KAAO9B,EAAMG,WAAY,CAChC,IAAIuC,EAAe1C,EACnB,OAIA0C,IACU,UAAT7E,GACS,aAATA,IACD6E,EAAazC,QAAUjD,GACvBA,GAAO0F,EAAavC,aAGtBuC,EAAe,MAGjB,IAAI/E,EAAS+E,EAAeA,EAAalC,WAAa,GAItD,OAHA7C,EAAOE,KAAOA,EACdF,EAAOX,IAAMA,EAET0F,GACFtE,KAAKrB,OAAS,OACdqB,KAAKwB,KAAO8C,EAAavC,WAClB7C,GAGFc,KAAKuE,SAAShF,IAGvBgF,SAAU,SAAShF,EAAQyC,GACzB,GAAoB,UAAhBzC,EAAOE,KACT,MAAMF,EAAOX,IAcf,MAXoB,UAAhBW,EAAOE,MACS,aAAhBF,EAAOE,KACTO,KAAKwB,KAAOjC,EAAOX,IACM,WAAhBW,EAAOE,MAChBO,KAAK+D,KAAO/D,KAAKpB,IAAMW,EAAOX,IAC9BoB,KAAKrB,OAAS,SACdqB,KAAKwB,KAAO,OACa,WAAhBjC,EAAOE,MAAqBuC,IACrChC,KAAKwB,KAAOQ,GAGP9C,GAGTsF,OAAQ,SAASzC,GACf,IAAK,IAAIlH,EAAImF,KAAKiC,WAAWQ,OAAS,EAAG5H,GAAK,IAAKA,EAAG,CACpD,IAAI+G,EAAQ5B,KAAKiC,WAAWpH,GAC5B,GAAI+G,EAAMG,aAAeA,EAGvB,OAFA/B,KAAKuE,SAAS3C,EAAMQ,WAAYR,EAAMI,UACtCG,EAAcP,GACP1C,IAKb,MAAS,SAAS2C,GAChB,IAAK,IAAIhH,EAAImF,KAAKiC,WAAWQ,OAAS,EAAG5H,GAAK,IAAKA,EAAG,CACpD,IAAI+G,EAAQ5B,KAAKiC,WAAWpH,GAC5B,GAAI+G,EAAMC,SAAWA,EAAQ,CAC3B,IAAItC,EAASqC,EAAMQ,WACnB,GAAoB,UAAhB7C,EAAOE,KAAkB,CAC3B,IAAIgF,EAASlF,EAAOX,IACpBuD,EAAcP,GAEhB,OAAO6C,GAMX,MAAM,IAAI5F,MAAM,0BAGlB6F,cAAe,SAASpC,EAAUf,EAAYE,GAa5C,OAZAzB,KAAKjB,SAAW,CACdzB,SAAU8C,EAAOkC,GACjBf,WAAYA,EACZE,QAASA,GAGS,SAAhBzB,KAAKrB,SAGPqB,KAAKpB,SA9rBPwC,GAisBOlC,IAQJvE,EA9sBM,CAqtBgBC,EAAOD,SAGtC,IACEgK,mBAAqB1H,EACrB,MAAO2H,GAWmB,iBAAfC,WACTA,WAAWF,mBAAqB1H,EAEhC6H,SAAS,IAAK,yBAAdA,CAAwC7H,K,8BC/uB5C,SAAS8H,EAAmBC,EAAKpE,EAASC,EAAQoE,EAAOC,EAAQ9I,EAAKwC,GACpE,IACE,IAAI0C,EAAO0D,EAAI5I,GAAKwC,GAChB9C,EAAQwF,EAAKxF,MACjB,MAAOqF,GAEP,YADAN,EAAOM,GAILG,EAAK5B,KACPkB,EAAQ9E,GAERsH,QAAQxC,QAAQ9E,GAAOmF,KAAKgE,EAAOC,GAIxB,SAASC,EAAkBvF,GACxC,OAAO,WACL,IAAI1B,EAAO8B,KACPoF,EAAOC,UACX,OAAO,IAAIjC,SAAQ,SAAUxC,EAASC,GACpC,IAAImE,EAAMpF,EAAG0F,MAAMpH,EAAMkH,GAEzB,SAASH,EAAMnJ,GACbiJ,EAAmBC,EAAKpE,EAASC,EAAQoE,EAAOC,EAAQ,OAAQpJ,GAGlE,SAASoJ,EAAOpH,GACdiH,EAAmBC,EAAKpE,EAASC,EAAQoE,EAAOC,EAAQ,QAASpH,GAGnEmH,OAAM7D,O,kCC7BZ,SAASmE,EAAWC,GAClBxF,KAAKwF,QAAUA,EAGjBD,EAAW9I,UAAY,CACrBqG,YAAayC,EAEbE,KAAM,SAASrJ,GACb,IAAK,IAAIvB,EAAI,EAAGA,EAAImF,KAAKwF,QAAQ/C,OAAQ5H,GAAK,EAC5C,GAAImF,KAAKwF,QAAQ3K,KAAOuB,EAAK,OAAOvB,EACtC,OAAQ,GAMVa,IAAK,SAASU,GACZ,IAAIsJ,EAAQ1F,KAAKyF,KAAKrJ,GACtB,OAAiB,GAAVsJ,OAActE,EAAYpB,KAAKwF,QAAQE,EAAQ,IAOxDC,OAAQ,SAASvJ,EAAKN,EAAO8J,GAC3B,IAAI1H,EAAO0H,GAAUA,GAAUxJ,EAAM4D,KAAK6F,OAAOD,GAAU5F,KACvD0F,EAAQxH,EAAKuH,KAAKrJ,GAAMoJ,EAAUtH,EAAKsH,QAAQ5B,QAOnD,OANc,GAAV8B,EACFF,EAAQtD,KAAK0D,GAAUxJ,EAAKN,IAE5B0J,EAAQE,EAAQ,GAAK5J,EACjB8J,IAAQJ,EAAQE,GAASE,IAExB,IAAIL,EAAWC,IAKxBK,OAAQ,SAASzJ,GACf,IAAIsJ,EAAQ1F,KAAKyF,KAAKrJ,GACtB,IAAc,GAAVsJ,EAAa,OAAO1F,KACxB,IAAIwF,EAAUxF,KAAKwF,QAAQ5B,QAE3B,OADA4B,EAAQM,OAAOJ,EAAO,GACf,IAAIH,EAAWC,IAKxBO,WAAY,SAAS3J,EAAKN,GACxB,OAAO,IAAIyJ,EAAW,CAACnJ,EAAKN,GAAOkK,OAAOhG,KAAK6F,OAAOzJ,GAAKoJ,WAK7DS,SAAU,SAAS7J,EAAKN,GACtB,IAAI0J,EAAUxF,KAAK6F,OAAOzJ,GAAKoJ,QAAQ5B,QAEvC,OADA4B,EAAQtD,KAAK9F,EAAKN,GACX,IAAIyJ,EAAWC,IAMxBU,UAAW,SAASC,EAAO/J,EAAKN,GAC9B,IAAIsK,EAAUpG,KAAK6F,OAAOzJ,GAAMoJ,EAAUY,EAAQZ,QAAQ5B,QACtD8B,EAAQU,EAAQX,KAAKU,GAEzB,OADAX,EAAQM,QAAiB,GAAVJ,EAAcF,EAAQ/C,OAASiD,EAAO,EAAGtJ,EAAKN,GACtD,IAAIyJ,EAAWC,IAMxBjF,QAAS,SAAS8F,GAChB,IAAK,IAAIxL,EAAI,EAAGA,EAAImF,KAAKwF,QAAQ/C,OAAQ5H,GAAK,EAC5CwL,EAAErG,KAAKwF,QAAQ3K,GAAImF,KAAKwF,QAAQ3K,EAAI,KAMxCyL,QAAS,SAASC,GAEhB,OADAA,EAAMhB,EAAWiB,KAAKD,IACbE,KACF,IAAIlB,EAAWgB,EAAIf,QAAQQ,OAAOhG,KAAK0G,SAASH,GAAKf,UADtCxF,MAOxB2G,OAAQ,SAASJ,GAEf,OADAA,EAAMhB,EAAWiB,KAAKD,IACbE,KACF,IAAIlB,EAAWvF,KAAK0G,SAASH,GAAKf,QAAQQ,OAAOO,EAAIf,UADtCxF,MAOxB0G,SAAU,SAASH,GACjB,IAAIxF,EAASf,KACbuG,EAAMhB,EAAWiB,KAAKD,GACtB,IAAK,IAAI1L,EAAI,EAAGA,EAAI0L,EAAIf,QAAQ/C,OAAQ5H,GAAK,EAC3CkG,EAASA,EAAO8E,OAAOU,EAAIf,QAAQ3K,IACrC,OAAOkG,GAKT,WACE,OAAOf,KAAKwF,QAAQ/C,QAAU,IAQlC8C,EAAWiB,KAAO,SAAS1K,GACzB,GAAIA,aAAiByJ,EAAY,OAAOzJ,EACxC,IAAI0J,EAAU,GACd,GAAI1J,EAAO,IAAK,IAAI8K,KAAQ9K,EAAO0J,EAAQtD,KAAK0E,EAAM9K,EAAM8K,IAC5D,OAAO,IAAIrB,EAAWC,IAGxB,IAEeqB,EAFEtB,E,ICzHJuB,EACX,SAAYtB,EAASiB,GAMnB,GALAzG,KAAKwF,QAAUA,EAIfxF,KAAKyG,KAAOA,GAAQ,EACR,MAARA,EAAc,IAAKM,IAAIlM,EAAI,EAAGA,EAAI2K,EAAQ/C,OAAQ5H,IACpDmF,KAAKyG,MAAQjB,EAAQ3K,GAAGmM,U,sGAO5BC,sBAAaT,EAAMU,EAAIb,EAAGc,EAAeC,Q,UAAH,GACpC,IAAKL,IAAIlM,EAAI,EAAGwM,EAAM,EAAGA,EAAMH,EAAIrM,IAAK,CACtCkM,IAAIO,EAAQtH,KAAKwF,QAAQ3K,GAAI0M,EAAMF,EAAMC,EAAMN,SAC/C,GAAIO,EAAMf,IAAiD,IAAzCH,EAAEiB,EAAOH,EAAYE,EAAKD,EAAQvM,IAAgByM,EAAM9B,QAAQiB,KAAM,CACtFM,IAAIS,EAAQH,EAAM,EAClBC,EAAML,aAAaQ,KAAKC,IAAI,EAAGlB,EAAOgB,GACnBC,KAAKE,IAAIL,EAAM9B,QAAQiB,KAAMS,EAAKM,GAClCnB,EAAGc,EAAYK,GAEpCH,EAAME,I,YAOVK,qBAAYvB,GACVrG,KAAKiH,aAAa,EAAGjH,KAAKyG,KAAMJ,I,YAMlCwB,qBAAYrB,EAAMU,EAAIY,EAAgBC,GACpChB,IAAIiB,EAAO,GAAIC,GAAY,EAa3B,OAZAjI,KAAKiH,aAAaT,EAAMU,GAAE,SAAGgB,EAAMb,GAC7Ba,EAAKC,QACPH,GAAQE,EAAKF,KAAKpE,MAAM6D,KAAKC,IAAIlB,EAAMa,GAAOA,EAAKH,EAAKG,GACxDY,GAAaH,GACJI,EAAKE,QAAUL,GACxBC,GAA4B,mBAAbD,EAA0BA,EAASG,GAAOH,EACzDE,GAAaH,IACHG,GAAaC,EAAKG,UAC5BL,GAAQF,EACRG,GAAY,KAEb,GACID,G,YAMTrB,gBAAO2B,GACL,IAAKA,EAAM7B,KAAM,OAAOzG,KACxB,IAAKA,KAAKyG,KAAM,OAAO6B,EACvBvB,IAAIwB,EAAOvI,KAAKwI,UAAWC,EAAQH,EAAMI,WAAYlD,EAAUxF,KAAKwF,QAAQ5B,QAAS/I,EAAI,EAKzF,IAJI0N,EAAKJ,QAAUI,EAAKI,WAAWF,KACjCjD,EAAQA,EAAQ/C,OAAS,GAAK8F,EAAKK,SAASL,EAAKP,KAAOS,EAAMT,MAC9DnN,EAAI,GAECA,EAAIyN,EAAM9C,QAAQ/C,OAAQ5H,IAAK2K,EAAQtD,KAAKoG,EAAM9C,QAAQ3K,IACjE,OAAO,IAAIiM,EAAStB,EAASxF,KAAKyG,KAAO6B,EAAM7B,O,YAKjDoC,aAAIrC,EAAMU,GAER,GADU,MAANA,IAAYA,EAAKlH,KAAKyG,MACd,GAARD,GAAaU,GAAMlH,KAAKyG,KAAM,OAAOzG,KACzC+G,IAAIhG,EAAS,GAAI0F,EAAO,EACxB,GAAIS,EAAKV,EAAM,IAAKO,IAAIlM,EAAI,EAAGwM,EAAM,EAAGA,EAAMH,EAAIrM,IAAK,CACrDkM,IAAIO,EAAQtH,KAAKwF,QAAQ3K,GAAI0M,EAAMF,EAAMC,EAAMN,SAC3CO,EAAMf,KACJa,EAAMb,GAAQe,EAAML,KAEpBI,EADEA,EAAMa,OACAb,EAAMuB,IAAIpB,KAAKC,IAAI,EAAGlB,EAAOa,GAAMI,KAAKE,IAAIL,EAAMU,KAAKvF,OAAQyE,EAAKG,IAEpEC,EAAMuB,IAAIpB,KAAKC,IAAI,EAAGlB,EAAOa,EAAM,GAAII,KAAKE,IAAIL,EAAM9B,QAAQiB,KAAMS,EAAKG,EAAM,KAE3FtG,EAAOmB,KAAKoF,GACZb,GAAQa,EAAMN,UAEhBK,EAAME,EAER,OAAO,IAAIT,EAAS/F,EAAQ0F,I,YAG9BqC,oBAAWtC,EAAMU,GACf,OAAIV,GAAQU,EAAWJ,EAASiC,MACpB,GAARvC,GAAaU,GAAMlH,KAAKwF,QAAQ/C,OAAezC,KAC5C,IAAI8G,EAAS9G,KAAKwF,QAAQ5B,MAAM4C,EAAMU,K,YAM/C8B,sBAAaC,EAAOf,GAClBnB,IAAImC,EAAUlJ,KAAKwF,QAAQyD,GAC3B,GAAIC,GAAWhB,EAAM,OAAOlI,KAC5B+G,IAAIoC,EAAOnJ,KAAKwF,QAAQ5B,QACpB6C,EAAOzG,KAAKyG,KAAOyB,EAAKlB,SAAWkC,EAAQlC,SAE/C,OADAmC,EAAKF,GAASf,EACP,IAAIpB,EAASqC,EAAM1C,I,YAM5BV,oBAAWmC,GACT,OAAO,IAAIpB,EAAS,CAACoB,GAAMlC,OAAOhG,KAAKwF,SAAUxF,KAAKyG,KAAOyB,EAAKlB,W,YAMpEf,kBAASiC,GACP,OAAO,IAAIpB,EAAS9G,KAAKwF,QAAQQ,OAAOkC,GAAOlI,KAAKyG,KAAOyB,EAAKlB,W,YAKlEoC,YAAGd,GACD,GAAItI,KAAKwF,QAAQ/C,QAAU6F,EAAM9C,QAAQ/C,OAAQ,OAAO,EACxD,IAAKsE,IAAIlM,EAAI,EAAGA,EAAImF,KAAKwF,QAAQ/C,OAAQ5H,IACvC,IAAKmF,KAAKwF,QAAQ3K,GAAGuO,GAAGd,EAAM9C,QAAQ3K,IAAK,OAAO,EACpD,OAAO,GAKTwO,EAAIX,WAAAhN,IAAA,WAAe,OAAOsE,KAAKwF,QAAQ/C,OAASzC,KAAKwF,QAAQ,GAAK,MAIlE6D,EAAIb,UAAA9M,IAAA,WAAc,OAAOsE,KAAKwF,QAAQ/C,OAASzC,KAAKwF,QAAQxF,KAAKwF,QAAQ/C,OAAS,GAAK,MAIvF4G,EAAIC,WAAA5N,IAAA,WAAe,OAAOsE,KAAKwF,QAAQ/C,Q,YAKvC6E,eAAM2B,GACJlC,IAAIrB,EAAQ1F,KAAKwF,QAAQyD,GACzB,IAAKvD,EAAO,MAAM,IAAI6D,WAAW,SAAWN,EAAQ,qBAAuBjJ,MAC3E,OAAO0F,G,YAKT8D,oBAAWP,GACT,OAAOjJ,KAAKwF,QAAQyD,I,YAMtB1I,iBAAQ8F,GACN,IAAKU,IAAIlM,EAAI,EAAG8B,EAAI,EAAG9B,EAAImF,KAAKwF,QAAQ/C,OAAQ5H,IAAK,CACnDkM,IAAIO,EAAQtH,KAAKwF,QAAQ3K,GACzBwL,EAAEiB,EAAO3K,EAAG9B,GACZ8B,GAAK2K,EAAMN,W,YAOfyC,uBAAcnB,EAAOjB,GACnB,Y,UADyB,GCtLtB,SAASoC,EAAcC,EAAGC,EAAGtC,GAClC,IAAKN,IAAIlM,EAAI,GAAIA,IAAK,CACpB,GAAIA,GAAK6O,EAAEJ,YAAczO,GAAK8O,EAAEL,WAC9B,OAAOI,EAAEJ,YAAcK,EAAEL,WAAa,KAAOjC,EAE/CN,IAAI6C,EAASF,EAAEpC,MAAMzM,GAAIgP,EAASF,EAAErC,MAAMzM,GAC1C,GAAI+O,GAAUC,EAAd,CAEA,IAAKD,EAAOjB,WAAWkB,GAAS,OAAOxC,EAEvC,GAAIuC,EAAOzB,QAAUyB,EAAO5B,MAAQ6B,EAAO7B,KAAM,CAC/C,IAAKjB,IAAI+C,EAAI,EAAGF,EAAO5B,KAAK8B,IAAMD,EAAO7B,KAAK8B,GAAIA,IAChDzC,IACF,OAAOA,EAET,GAAIuC,EAAOpE,QAAQiB,MAAQoD,EAAOrE,QAAQiB,KAAM,CAC9CM,IAAIgD,EAAQN,EAAcG,EAAOpE,QAASqE,EAAOrE,QAAS6B,EAAM,GAChE,GAAa,MAAT0C,EAAe,OAAOA,EAE5B1C,GAAOuC,EAAO5C,cAbUK,GAAOuC,EAAO5C,UDiL/ByC,CAAczJ,KAAMsI,EAAOjB,I,YAQpC2C,qBAAY1B,EAAOjB,EAAiB4C,GAClC,Y,UADuBjK,KAAKyG,W,UAAiB6B,EAAM7B,MCxKhD,SAASuD,EAAYN,EAAGC,EAAGO,EAAMC,GACtC,IAAKpD,IAAIqD,EAAKV,EAAEJ,WAAYe,EAAKV,EAAEL,aAAc,CAC/C,GAAU,GAANc,GAAiB,GAANC,EACb,OAAOD,GAAMC,EAAK,KAAO,CAACX,EAAGQ,EAAMP,EAAGQ,GAExCpD,IAAI6C,EAASF,EAAEpC,QAAQ8C,GAAKP,EAASF,EAAErC,QAAQ+C,GAAK5D,EAAOmD,EAAO5C,SAClE,GAAI4C,GAAUC,EAAd,CAKA,IAAKD,EAAOjB,WAAWkB,GAAS,MAAO,CAACH,EAAGQ,EAAMP,EAAGQ,GAEpD,GAAIP,EAAOzB,QAAUyB,EAAO5B,MAAQ6B,EAAO7B,KAAM,CAE/C,IADAjB,IAAIuD,EAAO,EAAGC,EAAU9C,KAAKE,IAAIiC,EAAO5B,KAAKvF,OAAQoH,EAAO7B,KAAKvF,QAC1D6H,EAAOC,GAAWX,EAAO5B,KAAK4B,EAAO5B,KAAKvF,OAAS6H,EAAO,IAAMT,EAAO7B,KAAK6B,EAAO7B,KAAKvF,OAAS6H,EAAO,IAC7GA,IAAQJ,IAAQC,IAElB,MAAO,CAACT,EAAGQ,EAAMP,EAAGQ,GAEtB,GAAIP,EAAOpE,QAAQiB,MAAQoD,EAAOrE,QAAQiB,KAAM,CAC9CM,IAAIgD,EAAQC,EAAYJ,EAAOpE,QAASqE,EAAOrE,QAAS0E,EAAO,EAAGC,EAAO,GACzE,GAAIJ,EAAO,OAAOA,EAEpBG,GAAQzD,EAAM0D,GAAQ1D,OAjBpByD,GAAQzD,EAAM0D,GAAQ1D,GDkKjBuD,CAAYhK,KAAMsI,EAAOjB,EAAK4C,I,YAOvCO,mBAAUnD,EAAKoD,GACb,Q,WADsB,GACX,GAAPpD,EAAU,OAAOqD,EAAS,EAAGrD,GACjC,GAAIA,GAAOrH,KAAKyG,KAAM,OAAOiE,EAAS1K,KAAKwF,QAAQ/C,OAAQ4E,GAC3D,GAAIA,EAAMrH,KAAKyG,MAAQY,EAAM,EAAG,MAAM,IAAIkC,WAAU,YAAalC,EAAG,yBAAyBrH,KAAI,KACjG,IAAK+G,IAAIlM,EAAI,EAAG8P,EAAS,GAAI9P,IAAK,CAChCkM,IAAyBQ,EAAMoD,EAArB3K,KAAKsH,MAAMzM,GAAuBmM,SAC5C,GAAIO,GAAOF,EACT,OAAIE,GAAOF,GAAOoD,EAAQ,EAAUC,EAAS7P,EAAI,EAAG0M,GAC7CmD,EAAS7P,EAAG8P,GAErBA,EAASpD,I,YAMbqD,oBAAa,MAAO,IAAM5K,KAAK6K,gBAAkB,K,YAEjDA,yBAAkB,OAAO7K,KAAKwF,QAAQsF,KAAK,O,YAI3CC,kBACE,OAAO/K,KAAKwF,QAAQ/C,OAASzC,KAAKwF,QAAQe,KAAG,SAACjK,GAAA,OAAKA,EAAEyO,YAAY,MAKnEjE,EAAOkE,SAAA,SAASC,EAAQnP,GACtB,IAAKA,EAAO,OAAOgL,EAASiC,MAC5B,IAAKmC,MAAMC,QAAQrP,GAAQ,MAAM,IAAIyN,WAAW,uCAChD,OAAO,IAAIzC,EAAShL,EAAMyK,IAAI0E,EAAOG,gBAMvCtE,EAAOuE,UAAA,SAAUC,GACf,IAAKA,EAAM7I,OAAQ,OAAOqE,EAASiC,MAEnC,IADAhC,IAAIwE,EAAQ9E,EAAO,EACV5L,EAAI,EAAGA,EAAIyQ,EAAM7I,OAAQ5H,IAAK,CACrCkM,IAAImB,EAAOoD,EAAMzQ,GACjB4L,GAAQyB,EAAKlB,SACTnM,GAAKqN,EAAKC,QAAUmD,EAAMzQ,EAAI,GAAG8N,WAAWT,IACzCqD,IAAQA,EAASD,EAAM1H,MAAM,EAAG/I,IACrC0Q,EAAOA,EAAO9I,OAAS,GAAKyF,EAAKU,SAAS2C,EAAOA,EAAO9I,OAAS,GAAGuF,KAAOE,EAAKF,OACvEuD,GACTA,EAAOrJ,KAAKgG,GAGhB,OAAO,IAAIpB,EAASyE,GAAUD,EAAO7E,IAQvCK,EAAON,KAAA,SAAKgF,GACV,IAAKA,EAAO,OAAO1E,EAASiC,MAC5B,GAAIyC,aAAiB1E,EAAU,OAAO0E,EACtC,GAAIN,MAAMC,QAAQK,GAAQ,OAAOxL,KAAKqL,UAAUG,GAChD,GAAIA,EAAMC,MAAO,OAAO,IAAI3E,EAAS,CAAC0E,GAAQA,EAAMxE,UACpD,MAAM,IAAIuC,WAAW,mBAAqBiC,EAAQ,kBAC5BA,EAAMvE,aAAe,mEAAqE,M,uCAIpHyE,IAAMhG,EAAQ,CAACuD,MAAO,EAAG0C,OAAQ,GACjC,SAASjB,EAASzB,EAAO0C,GAGvB,OAFAjG,EAAMuD,MAAQA,EACdvD,EAAMiG,OAASA,EACRjG,EE/QF,SAASkG,EAAYlC,EAAGC,GAC7B,GAAID,IAAMC,EAAG,OAAO,EACpB,IAAMD,GAAiB,iBAALA,IACZC,GAAiB,iBAALA,EAAgB,OAAO,EACzC5C,IAAIuE,EAAQJ,MAAMC,QAAQzB,GAC1B,GAAIwB,MAAMC,QAAQxB,IAAM2B,EAAO,OAAO,EACtC,GAAIA,EAAO,CACT,GAAI5B,EAAEjH,QAAUkH,EAAElH,OAAQ,OAAO,EACjC,IAAKsE,IAAIlM,EAAI,EAAGA,EAAI6O,EAAEjH,OAAQ5H,IAAK,IAAK+Q,EAAYlC,EAAE7O,GAAI8O,EAAE9O,IAAK,OAAO,MACnE,CACL,IAAKkM,IAAIpK,KAAK+M,EAAG,KAAM/M,KAAKgN,KAAOiC,EAAYlC,EAAE/M,GAAIgN,EAAEhN,IAAK,OAAO,EACnE,IAAKoK,IAAIpK,KAAKgN,EAAG,KAAMhN,KAAK+M,GAAI,OAAO,EAEzC,OAAO,EFyQT5C,EAASiC,MAAQ,IAAIjC,EAAS,GAAI,G,IG9QrB+E,EACX,SAAYpM,EAAMgM,GAGhB,KAAKhM,KAAOA,EAGV,KAAGgM,MAAQA,GCTV,SAASK,EAAaC,GAC3BhF,IAAIjJ,EAAMe,MAAM7D,KAAK,KAAM+Q,GAE3B,OADAjO,EAAImF,UAAY6I,EAAarP,UACtBqB,E,YDePkO,kBAASC,GAEL,IADFlF,IAAIoC,EAAM+C,GAAS,EACVrR,EAAI,EAAGA,EAAIoR,EAAIxJ,OAAQ5H,IAAK,CACnCkM,IAAIuB,EAAQ2D,EAAIpR,GAChB,GAAI,KAAKuO,GAAGd,GAAQ,OAAO2D,EAC3B,GAAI,KAAKxM,KAAK0M,SAAS7D,EAAM7I,MACtB0J,IAAMA,EAAO8C,EAAIrI,MAAM,EAAG/I,QAC1B,IAAIyN,EAAM7I,KAAK0M,SAAS,KAAK1M,MAClC,OAAOwM,GAEFC,GAAU5D,EAAM7I,KAAK2M,KAAO,KAAK3M,KAAK2M,OACpCjD,IAAMA,EAAO8C,EAAIrI,MAAM,EAAG/I,IAC/BsO,EAAKjH,KAAK,MACVgK,GAAS,GAEP/C,GAAMA,EAAKjH,KAAKoG,IAKxB,OAFKa,IAAMA,EAAO8C,EAAIrI,SACjBsI,GAAQ/C,EAAKjH,KAAK,MAChBiH,G,YAMTkD,uBAAcJ,GACV,IAAGlF,IAAIlM,EAAI,EAAGA,EAAIoR,EAAIxJ,OAAQ5H,IAC9B,GAAI,KAAKuO,GAAG6C,EAAIpR,IACd,OAAOoR,EAAIrI,MAAM,EAAG/I,GAAGmL,OAAOiG,EAAIrI,MAAM/I,EAAI,IAC9C,OAAKoR,G,YAKTK,iBAAQL,GACN,IAAKlF,IAAIlM,EAAI,EAAGA,EAAIoR,EAAIxJ,OAAQ5H,IAC9B,GAAI,KAAKuO,GAAG6C,EAAIpR,IAAK,OAAO,EAC5B,OAAK,G,YAMTuO,YAAGd,GACC,OAAK,MAAQA,GACZ,KAAK7I,MAAQ6I,EAAM7I,MAAQmM,EAAY,KAAKH,MAAOnD,EAAMmD,Q,YAK9DV,kBACEhE,IAAIpJ,EAAM,CAAC8B,KAAM,KAAKA,KAAKrE,MAC3B,IAAK2L,IAAIwF,KAAK,KAAKd,MAAO,CACxB9N,EAAI8N,MAAQ,KAAKA,MACjB,MAEF,OAAO9N,GAITkO,EAAOb,SAAA,SAASC,EAAQuB,GACtB,IAAKA,EAAM,MAAM,IAAIjD,WAAW,mCAChCxC,IAAItH,EAAOwL,EAAOwB,MAAMD,EAAK/M,MAC7B,IAAKA,EAAM,MAAM,IAAI8J,WAAU,yBAA0BiD,EAAK/M,KAAI,mBAClE,OAAOA,EAAKtD,OAAOqQ,EAAKf,QAK1BI,EAAOa,QAAA,SAAQhD,EAAGC,GACd,GAAED,GAAKC,EAAG,OAAO,EACjB,GAAED,EAAEjH,QAAUkH,EAAElH,OAAQ,OAAO,EAC/B,IAAGsE,IAAIlM,EAAI,EAAGA,EAAI6O,EAAEjH,OAAQ5H,IAC5B,IAAK6O,EAAE7O,GAAGuO,GAAGO,EAAE9O,IAAK,OAAO,EAC7B,OAAO,GAMTgR,EAAOc,QAAA,SAAQF,GACb,IAAKA,GAAyB,GAAhBA,EAAMhK,OAAa,OAAOoJ,EAAKe,KAC7C,GAAIH,aAAiBZ,EAAM,MAAO,CAACY,GACnC1F,IAAIoC,EAAOsD,EAAM7I,QAEjB,OADAuF,EAAK0D,MAAI,SAAEnD,EAAGC,GAAC,OAAKD,EAAEjK,KAAK2M,KAAOzC,EAAElK,KAAK2M,QAClCjD,GAKX0C,EAAKe,KAAO,GCvGZd,EAAarP,UAAYlB,OAAOY,OAAO0C,MAAMpC,WAC7CqP,EAAarP,UAAUqG,YAAcgJ,EACrCA,EAAarP,UAAUrB,KAAO,e,IAKjB0R,EAWX,SAAYtH,EAASuH,EAAWC,GAE9B,KAAKxH,QAAUA,EAEf,KAAKuH,UAAYA,EAEjB,KAAKC,QAAUA,G,2BAoFZ,SAASC,EAAQC,EAAOC,EAAKvJ,GAChC,GAAEA,EAAMmJ,UAAYG,EAAME,MAC1B,MAAM,IAAItB,EAAa,mDACvB,GAAEoB,EAAME,MAAQxJ,EAAMmJ,WAAaI,EAAIC,MAAQxJ,EAAMoJ,QACrD,MAAM,IAAIlB,EAAa,4BACzB,OAGF,SAASuB,EAAaH,EAAOC,EAAKvJ,EAAOwJ,GACvCrG,IAAIkC,EAAQiE,EAAMjE,MAAMmE,GAAQlF,EAAOgF,EAAMhF,KAAKkF,GAChD,GAAEnE,GAASkE,EAAIlE,MAAMmE,IAAUA,EAAQF,EAAME,MAAQxJ,EAAMmJ,UAAW,CACtEhG,IAAIgD,EAAQsD,EAAaH,EAAOC,EAAKvJ,EAAOwJ,EAAQ,GACpD,OAAOlF,EAAKiB,KAAKjB,EAAK1C,QAAQwD,aAAaC,EAAOc,IAC7C,GAAKnG,EAAM4B,QAAQiB,KAEnB,IAAK7C,EAAMmJ,WAAcnJ,EAAMoJ,SAAWE,EAAME,OAASA,GAASD,EAAIC,OAASA,EAG/E,CACL,IAAJ,EA8EA,SAAgCxJ,EAAO0J,GAGrC,IAFEvG,IAAEwG,EAAQD,EAAOF,MAAQxJ,EAAMmJ,UAC7B7E,EADiDoF,EAAOpF,KAAKqF,GAC/CpE,KAAKvF,EAAM4B,SACpB3K,EAAI0S,EAAQ,EAAG1S,GAAK,EAAGA,IAC9BqN,EAAOoF,EAAOpF,KAAKrN,GAAGsO,KAAKrC,EAASN,KAAK0B,IACzC,MAAK,CAACV,MAAOU,EAAKsF,eAAe5J,EAAMmJ,UAAYQ,GAC7ChG,IAAKW,EAAKsF,eAAetF,EAAK1C,QAAQiB,KAAO7C,EAAMoJ,QAAUO,IApFhDE,CAAuB7J,EAAOsJ,GAA5C,UAAO,QACR,OAAGQ,EAAMxF,EA8CjB,SAASyF,EAAgBT,EAAOU,EAAQC,EAAMV,EAAKC,GACjDrG,IAAIgG,EAAYG,EAAME,MAAQA,GAASU,EAASZ,EAAOU,EAAQR,EAAQ,GACnEJ,EAAUG,EAAIC,MAAQA,GAASU,EAASD,EAAMV,EAAKC,EAAQ,GAE3D5H,EAAU,GACZuI,EAAO,KAAMb,EAAOE,EAAO5H,GACzBuH,GAAaC,GAAWY,EAAO3E,MAAMmE,IAAUS,EAAK5E,MAAMmE,IAC5DY,EAAUjB,EAAWC,GACrBiB,EAAQP,EAAMX,EAAWY,EAAgBT,EAAOU,EAAQC,EAAMV,EAAKC,EAAQ,IAAK5H,KAE5EuH,GACFkB,EAAQP,EAAMX,EAAWmB,EAAchB,EAAOU,EAAQR,EAAQ,IAAK5H,GACrEuI,EAASH,EAAQC,EAAMT,EAAO5H,GAC1BwH,GACFiB,EAAQP,EAAMV,EAASkB,EAAcL,EAAMV,EAAKC,EAAQ,IAAK5H,IAG/D,OADAuI,EAAOZ,EAAK,KAAMC,EAAO5H,GACpB,IAAIsB,EAAStB,GA/DCmI,CAAgBT,EAAO1F,EAAOD,EAAK4F,EAAKC,IAJvDrG,IAAAK,EAAS8F,EAAM9F,OAAQ5B,EAAU4B,EAAO5B,QACxC,OAAGkI,EAAMtG,EAAQ5B,EAAQqD,IAAI,EAAGqE,EAAMiB,cAAcxH,OAAO/C,EAAM4B,SAASmB,OAAOnB,EAAQqD,IAAIsE,EAAIgB,gBAHjG,OAAGT,EAAMxF,EAAMgG,EAAchB,EAAOC,EAAKC,IATxCC,CAAaH,EAAOC,EAAKvJ,EAAO,GAmBzC,SAASoK,EAAUI,EAAMC,GACrB,IAAGA,EAAI5O,KAAK6O,kBAAkBF,EAAK3O,MAC/B,MAAE,IAAIqM,EAAa,eAAiBuC,EAAI5O,KAAKrE,KAAO,SAAWgT,EAAK3O,KAAKrE,MAGjF,SAAS0S,EAASS,EAASC,EAAQpB,GAC/BrG,IAAEmB,EAAOqG,EAAQrG,KAAKkF,GAEtB,OADAY,EAAQ9F,EAAMsG,EAAOtG,KAAKkF,IACrBlF,EAGT,SAAS+F,EAAQ3G,EAAOmH,GACpB1H,IAAEwB,EAAOkG,EAAOhM,OAAS,EACvB8F,GAAQ,GAAKjB,EAAMa,QAAUb,EAAMqB,WAAW8F,EAAOlG,IACvDkG,EAAOlG,GAAQjB,EAAMsB,SAAS6F,EAAOlG,GAAMP,KAAOV,EAAMU,MAExDyG,EAAOvM,KAAKoF,GAGhB,SAASyG,EAASH,EAAQC,EAAMT,EAAOqB,GACnC1H,IAAEmB,GAAQ2F,GAAQD,GAAQ1F,KAAKkF,GAC7BsB,EAAa,EAAGC,EAAWd,EAAOA,EAAK5E,MAAMmE,GAASlF,EAAKoB,WAC3DsE,IACEc,EAASd,EAAO3E,MAAMmE,GACtBQ,EAAOR,MAAQA,EACjBsB,IACSd,EAAOgB,aAChBX,EAAQL,EAAOiB,UAAWJ,GAC1BC,MAGF,IAAG3H,IAAIlM,EAAI6T,EAAY7T,EAAI8T,EAAU9T,IAAKoT,EAAQ/F,EAAKZ,MAAMzM,GAAI4T,GAC/DZ,GAAQA,EAAKT,OAASA,GAASS,EAAKe,YAClCX,EAAIJ,EAAKiB,WAAYL,GAG7B,SAASf,EAAMxF,EAAM1C,GACnB,IAAK0C,EAAKzI,KAAKsP,aAAavJ,GAC1B,MAAM,IAAIsG,EAAa,4BAA8B5D,EAAKzI,KAAKrE,MACjE,OAAO8M,EAAKiB,KAAK3D,GAuBnB,SAAS0I,EAAchB,EAAOC,EAAKC,GAC/BrG,IAAEvB,EAAU,IACZuI,EAAO,KAAMb,EAAOE,EAAO5H,GACzB0H,EAAME,MAAQA,IAEZa,EAAIP,EADGI,EAASZ,EAAOC,EAAKC,EAAQ,GACpBc,EAAchB,EAAOC,EAAKC,EAAQ,IAAK5H,GAG3D,OADAuI,EAAOZ,EAAK,KAAMC,EAAO5H,GACpB,IAAIsB,EAAStB,GA7KpB6D,EAAI5C,KAAA/K,IAAA,WACF,OAAO,KAAK8J,QAAQiB,KAAO,KAAKsG,UAAY/M,KAAKgN,S,YAGnDgC,kBAAS3H,EAAK4H,GACZlI,IAAIvB,EA4DR,SAAS0J,EAAW1J,EAAS2J,EAAMC,EAAQhI,GACzC,IAAF,EAAwB5B,EAAQgF,UAAU2E,GAAnC,UAAO,WAAmC7H,EAAQ9B,EAAQgE,WAAWP,GACxE,GAAE0C,GAAUwD,GAAQ7H,EAAMa,OAC1B,OAAIf,IAAWA,EAAOiI,WAAWpG,EAAOA,EAAOmG,GAAgB,KACxD5J,EAAQqD,IAAI,EAAGsG,GAAMxI,OAAOyI,GAAQzI,OAAOnB,EAAQqD,IAAIsG,IAEhEpI,IAAIgD,EAAQmF,EAAW5H,EAAM9B,QAAS2J,EAAOxD,EAAS,EAAGyD,GACvD,OAAKrF,GAASvE,EAAQwD,aAAaC,EAAO3B,EAAM6B,KAAKY,IAnEvCmF,CAAW,KAAK1J,QAAS6B,EAAM,KAAK0F,UAAWkC,EAAU,MACvE,OAAOzJ,GAAW,IAAIsH,EAAMtH,EAAS,KAAKuH,UAAW,KAAKC,U,YAG5DsC,uBAAc9I,EAAMU,GAClB,OAAO,IAAI4F,EA4Cf,SAASyC,EAAY/J,EAASgB,EAAMU,GAClC,IAAF,EAAwB1B,EAAQgF,UAAUhE,GAAnC,UAAO,WAAmCc,EAAQ9B,EAAQgE,WAAWP,GAC5E,EAA2CzD,EAAQgF,UAAUtD,GAA/C,UAAiB,WAC3B,GAAEyE,GAAUnF,GAAQc,EAAMa,OAAQ,CAClC,GAAIqH,GAAYtI,IAAO1B,EAAQ8B,MAAMmI,GAAStH,OAAQ,MAAM,IAAIoB,WAAW,2BAC3E,OAAO/D,EAAQqD,IAAI,EAAGrC,GAAMG,OAAOnB,EAAQqD,IAAI3B,IAE/C,GAAE+B,GAASwG,EAAS,MAAM,IAAIlG,WAAW,2BACzC,OAAK/D,EAAQwD,aAAaC,EAAO3B,EAAM6B,KAAKoG,EAAYjI,EAAM9B,QAASgB,EAAOmF,EAAS,EAAGzE,EAAKyE,EAAS,KApDvF4D,CAAY,KAAK/J,QAASgB,EAAO,KAAKuG,UAAW7F,EAAK,KAAK6F,WAAY,KAAKA,UAAW,KAAKC,U,YAK/G5D,YAAGd,GACD,OAAO,KAAK9C,QAAQ4D,GAAGd,EAAM9C,UAAY,KAAKuH,WAAazE,EAAMyE,WAAa,KAAKC,SAAW1E,EAAM0E,S,YAGtGpC,oBACE,OAAO,KAAKpF,QAAU,IAAM,KAAKuH,UAAY,IAAM,KAAKC,QAAU,K,YAKpEjC,kBACE,IAAK,KAAKvF,QAAQiB,KAAM,OAAO,KAC/BM,IAAIyF,EAAO,CAAChH,QAAS,KAAKA,QAAQuF,UAGlC,OAFI,KAAKgC,UAAY,IAAGP,EAAKO,UAAY,KAAKA,WAC1C,KAAKC,QAAU,IAAGR,EAAKQ,QAAU,KAAKA,SACnCR,GAKTM,EAAO9B,SAAA,SAASC,EAAQuB,GACtB,IAAKA,EAAM,OAAOM,EAAM/D,MACxBhC,IAAIgG,EAAYP,EAAKO,WAAa,EAAGC,EAAUR,EAAKQ,SAAW,EAC/D,GAAwB,iBAAbD,GAA2C,iBAAXC,EACzC,MAAM,IAAIzD,WAAW,oCACrB,OAAK,IAAIuD,EAAMhG,EAASkE,SAASC,EAAQuB,EAAKhH,SAAUuH,EAAWC,IAMvEF,EAAO4C,QAAA,SAAQT,EAAUU,Q,WAAc,GAErC,IADA5I,IAAIgG,EAAY,EAAGC,EAAU,EACpB1Q,EAAI2S,EAASvG,WAAYpM,IAAMA,EAAE8L,SAAWuH,IAAkBrT,EAAEmD,KAAKmQ,KAAKC,WAAYvT,EAAIA,EAAEoM,WAAYqE,IAC/G,IAAGhG,IAAIzK,EAAI2S,EAASzG,UAAWlM,IAAMA,EAAE8L,SAAWuH,IAAkBrT,EAAEmD,KAAKmQ,KAAKC,WAAYvT,EAAIA,EAAEkM,UAAWwE,IAC/G,OAAO,IAAIF,EAAMmC,EAAUlC,EAAWC,I,uCA2B1CF,EAAM/D,MAAQ,IAAI+D,EAAMhG,EAASiC,MAAO,EAAG,G,IC5G9B+G,EACX,SAAYzI,EAAK0I,EAAM5B,GAErBnO,KAAKqH,IAAMA,EACXrH,KAAK+P,KAAOA,EAKZ/P,KAAKoN,MAAQ2C,EAAKtN,OAAS,EAAI,EAE/BzC,KAAKmO,aAAeA,G,qJAGtB6B,sBAAaC,GACX,OAAW,MAAPA,EAAoBjQ,KAAKoN,MACzB6C,EAAM,EAAUjQ,KAAKoN,MAAQ6C,EAC1BA,GAOT5G,EAAIjC,OAAA1L,IAAA,WAAW,OAAOsE,KAAKkI,KAAKlI,KAAKoN,QAIrC/D,EAAI6G,IAAAxU,IAAA,WAAQ,OAAOsE,KAAKkI,KAAK,I,YAK7BA,cAAKkF,GAAS,OAAOpN,KAAK+P,KAAgC,EAA3B/P,KAAKgQ,aAAa5C,K,YAMjDnE,eAAMmE,GAAS,OAAOpN,KAAK+P,KAAgC,EAA3B/P,KAAKgQ,aAAa5C,GAAa,I,YAK/D+C,oBAAW/C,GAET,OADAA,EAAQpN,KAAKgQ,aAAa5C,GACnBpN,KAAKiJ,MAAMmE,IAAUA,GAASpN,KAAKoN,OAAUpN,KAAK4O,WAAiB,EAAJ,I,YAMxEpH,eAAM4F,GAEJ,OAAgB,IADhBA,EAAQpN,KAAKgQ,aAAa5C,IACN,EAAIpN,KAAK+P,KAAa,EAAR3C,EAAY,GAAK,G,YAMrD7F,aAAI6F,GAEF,OADAA,EAAQpN,KAAKgQ,aAAa5C,GACnBpN,KAAKwH,MAAM4F,GAASpN,KAAKkI,KAAKkF,GAAO5H,QAAQiB,M,YAOtD2J,gBAAOhD,GAEL,KADAA,EAAQpN,KAAKgQ,aAAa5C,IACd,MAAM,IAAI7D,WAAW,kDACjC,OAAO6D,GAASpN,KAAKoN,MAAQ,EAAIpN,KAAKqH,IAAMrH,KAAK+P,KAAa,EAAR3C,EAAY,I,YAMpEiD,eAAMjD,GAEJ,KADAA,EAAQpN,KAAKgQ,aAAa5C,IACd,MAAM,IAAI7D,WAAW,iDACjC,OAAO6D,GAASpN,KAAKoN,MAAQ,EAAIpN,KAAKqH,IAAMrH,KAAK+P,KAAa,EAAR3C,EAAY,GAAKpN,KAAK+P,KAAa,EAAR3C,GAAWpG,UAO9FqC,EAAIuF,WAAAlT,IAAA,WAAe,OAAOsE,KAAKqH,IAAMrH,KAAK+P,KAAK/P,KAAK+P,KAAKtN,OAAS,IAMlE4G,EAAIwF,UAAAnT,IAAA,WACFqL,IAAIK,EAASpH,KAAKoH,OAAQ6B,EAAQjJ,KAAKiJ,MAAMjJ,KAAKoN,OAClD,GAAInE,GAAS7B,EAAOkC,WAAY,OAAO,KACvCvC,IAAIuJ,EAAOtQ,KAAKqH,IAAMrH,KAAK+P,KAAK/P,KAAK+P,KAAKtN,OAAS,GAAI6E,EAAQF,EAAOE,MAAM2B,GAC5E,OAAOqH,EAAOlJ,EAAOE,MAAM2B,GAAOJ,IAAIyH,GAAQhJ,GAOhD+B,EAAIyF,WAAApT,IAAA,WACFqL,IAAIkC,EAAQjJ,KAAKiJ,MAAMjJ,KAAKoN,OACxBkD,EAAOtQ,KAAKqH,IAAMrH,KAAK+P,KAAK/P,KAAK+P,KAAKtN,OAAS,GACnD,OAAI6N,EAAatQ,KAAKoH,OAAOE,MAAM2B,GAAOJ,IAAI,EAAGyH,GACjC,GAATrH,EAAa,KAAOjJ,KAAKoH,OAAOE,MAAM2B,EAAQ,I,YAMvDsH,oBAAWtH,EAAOmE,GAChBA,EAAQpN,KAAKgQ,aAAa5C,GAE1B,IADArG,IAAImB,EAAOlI,KAAK+P,KAAa,EAAR3C,GAAY/F,EAAe,GAAT+F,EAAa,EAAIpN,KAAK+P,KAAa,EAAR3C,EAAY,GAAK,EAC1EvS,EAAI,EAAGA,EAAIoO,EAAOpO,IAAKwM,GAAOa,EAAKZ,MAAMzM,GAAGmM,SACrD,OAAOK,G,YAQToF,iBACE1F,IAAIK,EAASpH,KAAKoH,OAAQ6B,EAAQjJ,KAAKiJ,QAGvC,GAA2B,GAAvB7B,EAAO5B,QAAQiB,KAAW,OAAOoF,EAAKe,KAG1C,GAAI5M,KAAK4O,WAAY,OAAOxH,EAAOE,MAAM2B,GAAOwD,MAEhD1F,IAAIqH,EAAOhH,EAAOoC,WAAWP,EAAQ,GAAIX,EAAQlB,EAAOoC,WAAWP,GAGnE,IAAKmF,EAAM,CAAErH,IAAIyJ,EAAMpC,EAAMA,EAAO9F,EAAOA,EAAQkI,EAKnD,IADAzJ,IAAI0F,EAAQ2B,EAAK3B,MACR5R,EAAI,EAAGA,EAAI4R,EAAMhK,OAAQ5H,KACK,IAAjC4R,EAAM5R,GAAG4E,KAAKmQ,KAAKa,WAAyBnI,GAAUmE,EAAM5R,GAAGyR,QAAQhE,EAAMmE,SAC/EA,EAAQA,EAAM5R,KAAKwR,cAAcI,IAErC,OAAOA,G,YAUTiE,qBAAY7C,GACV9G,IAAIsJ,EAAQrQ,KAAKoH,OAAOoC,WAAWxJ,KAAKiJ,SACxC,IAAKoH,IAAUA,EAAMM,SAAU,OAAO,KAGtC,IADA5J,IAAI0F,EAAQ4D,EAAM5D,MAAOjL,EAAOqM,EAAKzG,OAAOoC,WAAWqE,EAAK5E,SACnDpO,EAAI,EAAGA,EAAI4R,EAAMhK,OAAQ5H,KACK,IAAjC4R,EAAM5R,GAAG4E,KAAKmQ,KAAKa,WAAyBjP,GAASiL,EAAM5R,GAAGyR,QAAQ9K,EAAKiL,SAC7EA,EAAQA,EAAM5R,KAAKwR,cAAcI,IACrC,OAAOA,G,YAMTmE,qBAAYvJ,GACV,IAAKN,IAAIqG,EAAQpN,KAAKoN,MAAOA,EAAQ,EAAGA,IACtC,GAAIpN,KAAKwH,MAAM4F,IAAU/F,GAAOrH,KAAKuH,IAAI6F,IAAU/F,EAAK,OAAO+F,EACjE,OAAO,G,YAWTyD,oBAAWvI,EAAcwI,GACvB,Q,UADiB9Q,MACbsI,EAAMjB,IAAMrH,KAAKqH,IAAK,OAAOiB,EAAMuI,WAAW7Q,MAClD,IAAK+G,IAAI5L,EAAI6E,KAAKoN,OAASpN,KAAKoH,OAAO2J,eAAiB/Q,KAAKqH,KAAOiB,EAAMjB,IAAM,EAAI,GAAIlM,GAAK,EAAGA,IAC9F,GAAImN,EAAMjB,KAAOrH,KAAKuH,IAAIpM,MAAQ2V,GAAQA,EAAK9Q,KAAKkI,KAAK/M,KACvD,OAAO,IAAI6V,EAAUhR,KAAMsI,EAAOnN,I,YAKxC8V,oBAAW3I,GACT,OAAOtI,KAAKqH,IAAMrH,KAAKmO,cAAgB7F,EAAMjB,IAAMiB,EAAM6F,c,YAK3DzG,aAAIY,GACF,OAAOA,EAAMjB,IAAMrH,KAAKqH,IAAMiB,EAAQtI,M,YAKxC2H,aAAIW,GACF,OAAOA,EAAMjB,IAAMrH,KAAKqH,IAAMiB,EAAQtI,M,YAGxC4K,oBAEE,IADA7D,IAAImK,EAAM,GACDrW,EAAI,EAAGA,GAAKmF,KAAKoN,MAAOvS,IAC/BqW,IAAQA,EAAM,IAAM,IAAMlR,KAAKkI,KAAKrN,GAAG4E,KAAKrE,KAAO,IAAM4E,KAAKiJ,MAAMpO,EAAI,GAC1E,OAAOqW,EAAM,IAAMlR,KAAKmO,cAG1B2B,EAAOlP,QAAA,SAAQsP,EAAK7I,GAClB,KAAMA,GAAO,GAAKA,GAAO6I,EAAI1K,QAAQiB,MAAO,MAAM,IAAI8C,WAAW,YAAclC,EAAM,iBAGrF,IAFAN,IAAIgJ,EAAO,GACPvI,EAAQ,EAAG2G,EAAe9G,EACrBa,EAAOgI,IAAO,CACvB,IAAJ,EAA4BhI,EAAK1C,QAAQgF,UAAU2D,GAAxClF,EAAA,EAAAA,MAAO0C,EAAA,EAAAA,OACRwF,EAAMhD,EAAexC,EAEzB,GADAoE,EAAK7N,KAAKgG,EAAMe,EAAOzB,EAAQmE,IAC1BwF,EAAK,MAEV,IADAjJ,EAAOA,EAAKZ,MAAM2B,IACTd,OAAQ,MACjBgG,EAAegD,EAAM,EACrB3J,GAASmE,EAAS,EAEpB,OAAO,IAAImE,EAAYzI,EAAK0I,EAAM5B,IAGpC2B,EAAOsB,cAAA,SAAclB,EAAK7I,GACxB,IAAKN,IAAIlM,EAAI,EAAGA,EAAIwW,EAAa5O,OAAQ5H,IAAK,CAC5CkM,IAAIuK,EAASD,EAAaxW,GAC1B,GAAIyW,EAAOjK,KAAOA,GAAOiK,EAAOpB,KAAOA,EAAK,OAAOoB,EAErDvK,IAAIhG,EAASsQ,EAAaE,GAAmBzB,EAAYlP,QAAQsP,EAAK7I,GAEtE,OADAkK,GAAmBA,EAAkB,GAAKC,EACnCzQ,G,uCAIXgG,IAAIsK,EAAe,GAAIE,EAAkB,EAAGC,EAAmB,GAIlDR,EAKX,SAAY9D,EAAOC,EAAKC,GAMtBpN,KAAKkN,MAAQA,EAGblN,KAAKmN,IAAMA,EAEXnN,KAAKoN,MAAQA,G,mIAIfqE,EAAIjK,MAAA9L,IAAA,WAAU,OAAOsE,KAAKkN,MAAMkD,OAAOpQ,KAAKoN,MAAQ,IAEpDqE,EAAIlK,IAAA7L,IAAA,WAAQ,OAAOsE,KAAKmN,IAAIkD,MAAMrQ,KAAKoN,MAAQ,IAG/CqE,EAAIrK,OAAA1L,IAAA,WAAW,OAAOsE,KAAKkN,MAAMhF,KAAKlI,KAAKoN,QAE3CqE,EAAI/C,WAAAhT,IAAA,WAAe,OAAOsE,KAAKkN,MAAMjE,MAAMjJ,KAAKoN,QAEhDqE,EAAI9C,SAAAjT,IAAA,WAAa,OAAOsE,KAAKmN,IAAIgD,WAAWnQ,KAAKoN,Q,uCC3RnD1B,IAAMgG,EAAanW,OAAOY,OAAO,MAcpBwV,EACX,SAAYlS,EAAMgM,EAAOjG,EAASiH,GAGhCzM,KAAKP,KAAOA,EAMZO,KAAKyL,MAAQA,EAIbzL,KAAKwF,QAAUA,GAAWsB,EAASiC,MAKnC/I,KAAKyM,MAAQA,GAASZ,EAAKe,M,iVAY7BvD,EAAIrC,SAAAtL,IAAA,WAAa,OAAOsE,KAAKoI,OAAS,EAAI,EAAIpI,KAAKwF,QAAQiB,MAI3D4C,EAAIC,WAAA5N,IAAA,WAAe,OAAOsE,KAAKwF,QAAQ8D,Y,YAKvChC,eAAM2B,GAAS,OAAOjJ,KAAKwF,QAAQ8B,MAAM2B,I,YAIzCO,oBAAWP,GAAS,OAAOjJ,KAAKwF,QAAQgE,WAAWP,I,YAKnD1I,iBAAQ8F,GAAKrG,KAAKwF,QAAQjF,QAAQ8F,I,YAUlCY,sBAAaT,EAAMU,EAAIb,EAAGuL,Q,UAAW,GACnC5R,KAAKwF,QAAQyB,aAAaT,EAAMU,EAAIb,EAAGuL,EAAU5R,O,YAMnD4H,qBAAYvB,GACVrG,KAAKiH,aAAa,EAAGjH,KAAKwF,QAAQiB,KAAMJ,IAM1CgD,EAAIwI,YAAAnW,IAAA,WAAgB,OAAOsE,KAAK6H,YAAY,EAAG7H,KAAKwF,QAAQiB,KAAM,K,YAOlEoB,qBAAYrB,EAAMU,EAAIY,EAAgBC,GACpC,OAAO/H,KAAKwF,QAAQqC,YAAYrB,EAAMU,EAAIY,EAAgBC,IAM5DsB,EAAIX,WAAAhN,IAAA,WAAe,OAAOsE,KAAKwF,QAAQkD,YAKvCW,EAAIb,UAAA9M,IAAA,WAAc,OAAOsE,KAAKwF,QAAQgD,W,YAItCY,YAAGd,GACD,OAAOtI,MAAQsI,GAAUtI,KAAK2I,WAAWL,IAAUtI,KAAKwF,QAAQ4D,GAAGd,EAAM9C,U,YAM3EmD,oBAAWL,GACT,OAAOtI,KAAK8R,UAAUxJ,EAAM7I,KAAM6I,EAAMmD,MAAOnD,EAAMmE,Q,YAMvDqF,mBAAUrS,EAAMgM,EAAOgB,GACrB,OAAOzM,KAAKP,MAAQA,GAClBmM,EAAY5L,KAAKyL,MAAOA,GAAShM,EAAKsS,cAAgBL,IACtD7F,EAAKa,QAAQ1M,KAAKyM,MAAOA,GAASZ,EAAKe,O,YAM3CzD,cAAK3D,GACH,Y,UADa,MACTA,GAAWxF,KAAKwF,QAAgBxF,KAC7B,IAAIA,KAAK8C,YAAY9C,KAAKP,KAAMO,KAAKyL,MAAOjG,EAASxF,KAAKyM,Q,YAMnE1J,cAAK0J,GACH,OAAOA,GAASzM,KAAKyM,MAAQzM,KAAO,IAAIA,KAAK8C,YAAY9C,KAAKP,KAAMO,KAAKyL,MAAOzL,KAAKwF,QAASiH,I,YAOhG5D,aAAIrC,EAAMU,GACR,OAAY,GAARV,GAAaU,GAAMlH,KAAKwF,QAAQiB,KAAazG,KAC1CA,KAAKmJ,KAAKnJ,KAAKwF,QAAQqD,IAAIrC,EAAMU,K,YAM1CtD,eAAM4C,EAAMU,EAAwB8K,GAClC,Q,UADehS,KAAKwF,QAAQiB,W,WAAuB,GAC/CD,GAAQU,EAAI,OAAO4F,EAAM/D,MAE7BhC,IAAImG,EAAQlN,KAAKY,QAAQ4F,GAAO2G,EAAMnN,KAAKY,QAAQsG,GAC/CkG,EAAQ4E,EAAiB,EAAI9E,EAAM0D,YAAY1J,GAC/CM,EAAQ0F,EAAM1F,MAAM4F,GACpB5H,EADmC0H,EAAMhF,KAAKkF,GAC/B5H,QAAQqD,IAAIqE,EAAM7F,IAAMG,EAAO2F,EAAI9F,IAAMG,GAC5D,OAAO,IAAIsF,EAAMtH,EAAS0H,EAAME,MAAQA,EAAOD,EAAIC,MAAQA,I,YAU7DH,iBAAQzG,EAAMU,EAAItD,GAChB,OAAOqJ,EAAQjN,KAAKY,QAAQ4F,GAAOxG,KAAKY,QAAQsG,GAAKtD,I,YAKvDqO,gBAAO5K,GACL,IAAKN,IAAImB,EAAOlI,OAAQ,CACxB,IAAJ,EAA4BkI,EAAK1C,QAAQgF,UAAUnD,GAAxC4B,EAAA,EAAAA,MAAO0C,EAAA,EAAAA,OAEZ,KADAzD,EAAOA,EAAKsB,WAAWP,IACZ,OAAO,KAClB,GAAI0C,GAAUtE,GAAOa,EAAKC,OAAQ,OAAOD,EACzCb,GAAOsE,EAAS,I,YAQpBuG,oBAAW7K,GACX,IAAF,EAA0BrH,KAAKwF,QAAQgF,UAAUnD,GAAxC4B,EAAA,EAAAA,MAAO0C,EAAA,EAAAA,OACZ,MAAO,CAACzD,KAAMlI,KAAKwF,QAAQgE,WAAWP,GAAMA,MAAEA,EAAK0C,OAAEA,I,YAOvDwG,qBAAY9K,GACV,GAAW,GAAPA,EAAU,MAAO,CAACa,KAAM,KAAMe,MAAO,EAAG0C,OAAQ,GACtD,IAAF,EAA0B3L,KAAKwF,QAAQgF,UAAUnD,GAAxC4B,EAAA,EAAAA,MAAO0C,EAAA,EAAAA,OACZ,GAAIA,EAAStE,EAAK,MAAO,CAACa,KAAMlI,KAAKwF,QAAQ8B,MAAM2B,GAAMA,MAAEA,EAAK0C,OAAEA,GAClE5E,IAAImB,EAAOlI,KAAKwF,QAAQ8B,MAAM2B,EAAQ,GACtC,MAAO,CAAAf,KAACA,EAAMe,MAAOA,EAAQ,EAAG0C,OAAQA,EAASzD,EAAKlB,W,YAMxDpG,iBAAQyG,GAAO,OAAOyI,EAAYsB,cAAcpR,KAAMqH,I,YAEtDmG,wBAAenG,GAAO,OAAOyI,EAAYlP,QAAQZ,KAAMqH,I,YAKvD+K,sBAAa5L,EAAMU,EAAIzH,GACrBsH,IAAIrB,GAAQ,EAKZ,OAJIwB,EAAKV,GAAMxG,KAAKiH,aAAaT,EAAMU,GAAE,SAAEgB,GAEzC,OADIzI,EAAK6M,QAAQpE,EAAKuE,SAAQ/G,GAAQ,IAC9BA,KAEHA,GAKT2D,EAAIhB,QAAA3M,IAAA,WAAY,OAAOsE,KAAKP,KAAK4I,SAKjCgB,EAAIgJ,YAAA3W,IAAA,WAAgB,OAAOsE,KAAKP,KAAK4S,aAIrChJ,EAAI0H,cAAArV,IAAA,WAAkB,OAAOsE,KAAKP,KAAKsR,eAKvC1H,EAAIsH,SAAAjV,IAAA,WAAa,OAAOsE,KAAKP,KAAKkR,UAIlCtH,EAAIlB,OAAAzM,IAAA,WAAW,OAAOsE,KAAKP,KAAK0I,QAIhCkB,EAAIjB,OAAA1M,IAAA,WAAW,OAAOsE,KAAKP,KAAK2I,QAQhCiB,EAAIiJ,OAAA5W,IAAA,WAAW,OAAOsE,KAAKP,KAAK6S,Q,YAKhC1H,oBACE,GAAI5K,KAAKP,KAAKmQ,KAAK2C,cAAe,OAAOvS,KAAKP,KAAKmQ,KAAK2C,cAAcvS,MACtE+G,IAAI3L,EAAO4E,KAAKP,KAAKrE,KAGrB,OAFI4E,KAAKwF,QAAQiB,OACfrL,GAAQ,IAAM4E,KAAKwF,QAAQqF,gBAAkB,KACxC2H,EAAUxS,KAAKyM,MAAOrR,I,YAK/BqX,wBAAexJ,GACblC,IAAI2L,EAAQ1S,KAAKP,KAAKkT,aAAaC,cAAc5S,KAAKwF,QAAS,EAAGyD,GAClE,IAAKyJ,EAAO,MAAM,IAAI7T,MAAM,wDAC5B,OAAO6T,G,YASTrD,oBAAW7I,EAAMU,EAAI2L,EAA8BrL,EAAWD,Q,UAA3BT,EAASiC,Y,UAAe,Q,UAAS8J,EAAYvJ,YAC9EvC,IAAI+L,EAAM9S,KAAKyS,eAAejM,GAAMoM,cAAcC,EAAarL,EAAOD,GAClEwL,EAAMD,GAAOA,EAAIF,cAAc5S,KAAKwF,QAAS0B,GACjD,IAAK6L,IAAQA,EAAIC,SAAU,OAAO,EAClC,IAAKjM,IAAIlM,EAAI2M,EAAO3M,EAAI0M,EAAK1M,IAAK,IAAKmF,KAAKP,KAAKwT,YAAYJ,EAAYvL,MAAMzM,GAAG4R,OAAQ,OAAO,EACjG,OAAO,G,YAMTyG,wBAAe1M,EAAMU,EAAIzH,EAAMgN,GAC7B,GAAIA,IAAUzM,KAAKP,KAAKwT,YAAYxG,GAAQ,OAAO,EACnD1F,IAAIS,EAAQxH,KAAKyS,eAAejM,GAAM2M,UAAU1T,GAC5C8H,EAAMC,GAASA,EAAMoL,cAAc5S,KAAKwF,QAAS0B,GACrD,QAAOK,GAAMA,EAAIyL,U,YAQnBI,mBAAU9K,GACR,OAAIA,EAAM9C,QAAQiB,KAAazG,KAAKqP,WAAWrP,KAAKsJ,WAAYtJ,KAAKsJ,WAAYhB,EAAM9C,SAC3ExF,KAAKP,KAAK6O,kBAAkBhG,EAAM7I,O,YAMhD4T,iBACE,IAAKrT,KAAKP,KAAKsP,aAAa/O,KAAKwF,SAC/B,MAAM,IAAI+D,WAAU,4BAA6BvJ,KAAKP,KAAKrE,KAAI,KAAK4E,KAAKwF,QAAQoF,WAAWhH,MAAM,EAAG,KAEvG,IADAmD,IAAIoC,EAAO0C,EAAKe,KACP/R,EAAI,EAAGA,EAAImF,KAAKyM,MAAMhK,OAAQ5H,IAAKsO,EAAOnJ,KAAKyM,MAAM5R,GAAGmR,SAAS7C,GAC1E,IAAK0C,EAAKa,QAAQvD,EAAMnJ,KAAKyM,OAC3B,MAAM,IAAIlD,WAAU,wCAAyCvJ,KAAKP,KAAKrE,KAAI,KAAK4E,KAAKyM,MAAMlG,KAAG,SAACtL,GAAA,OAAKA,EAAEwE,KAAKrE,SAC7G4E,KAAKwF,QAAQjF,SAAO,SAAC2H,GAAA,OAAQA,EAAKmL,Y,YAKpCtI,kBACEhE,IAAIpJ,EAAM,CAAC8B,KAAMO,KAAKP,KAAKrE,MAC3B,IAAK2L,IAAIwF,KAAKvM,KAAKyL,MAAO,CACxB9N,EAAI8N,MAAQzL,KAAKyL,MACjB,MAMF,OAJIzL,KAAKwF,QAAQiB,OACf9I,EAAI6H,QAAUxF,KAAKwF,QAAQuF,UACzB/K,KAAKyM,MAAMhK,SACb9E,EAAI8O,MAAQzM,KAAKyM,MAAMlG,KAAG,SAACjK,GAAA,OAAKA,EAAEyO,aAC7BpN,GAKTgU,EAAO3G,SAAA,SAASC,EAAQuB,GACtB,IAAKA,EAAM,MAAM,IAAIjD,WAAW,mCAChCxC,IAAI0F,EAAQ,KACZ,GAAID,EAAKC,MAAO,CACd,IAAKvB,MAAMC,QAAQqB,EAAKC,OAAQ,MAAM,IAAIlD,WAAW,uCACrDkD,EAAQD,EAAKC,MAAMlG,IAAI0E,EAAOqI,cAEhC,GAAiB,QAAb9G,EAAK/M,KAAgB,CACvB,GAAwB,iBAAb+M,EAAKxE,KAAkB,MAAM,IAAIuB,WAAW,6BACvD,OAAO0B,EAAOjD,KAAKwE,EAAKxE,KAAMyE,GAEhC1F,IAAIvB,EAAUsB,EAASkE,SAASC,EAAQuB,EAAKhH,SAC7C,OAAOyF,EAAOsI,SAAS/G,EAAK/M,MAAMtD,OAAOqQ,EAAKf,MAAOjG,EAASiH,I,uCAI3D,IAAM+G,EAAQ,YACnB,WAAY/T,EAAMgM,EAAOjG,EAASiH,GAGhC,GAFAgH,OAAK,KAAChU,EAAMgM,EAAO,KAAMgB,IAEpBjH,EAAS,MAAM,IAAI+D,WAAW,oCAEnCvJ,KAAKgI,KAAOxC,E,+JAGdgO,EAAFA,UAAE5I,SAAA,WACE,OAAI5K,KAAKP,KAAKmQ,KAAK2C,cAAsBvS,KAAKP,KAAKmQ,KAAK2C,cAAcvS,MAC/DwS,EAAUxS,KAAKyM,MAAOiH,KAAKC,UAAU3T,KAAKgI,QAGnDyJ,EAAII,YAAAnW,IAAA,WAAgB,OAAOsE,KAAKgI,MAEhCwL,EAAFA,UAAE3L,YAAA,SAAYrB,EAAMU,GAAM,OAAOlH,KAAKgI,KAAKpE,MAAM4C,EAAMU,IAErDuK,EAAIzK,SAAAtL,IAAA,WAAa,OAAOsE,KAAKgI,KAAKvF,QAElC+Q,EAAFA,UAAEzQ,KAAA,SAAK0J,GACH,OAAOA,GAASzM,KAAKyM,MAAQzM,KAAO,IAAIwT,EAASxT,KAAKP,KAAMO,KAAKyL,MAAOzL,KAAKgI,KAAMyE,IAGrF+G,EAAFA,UAAE5K,SAAA,SAASZ,GACP,OAAIA,GAAQhI,KAAKgI,KAAahI,KACvB,IAAIwT,EAASxT,KAAKP,KAAMO,KAAKyL,MAAOzD,EAAMhI,KAAKyM,QAGxD+G,EAAFA,UAAE3K,IAAA,SAAIrC,EAAUU,GACZ,Y,UADS,Q,UAAQlH,KAAKgI,KAAKvF,QACf,GAAR+D,GAAaU,GAAMlH,KAAKgI,KAAKvF,OAAezC,KACzCA,KAAK4I,SAAS5I,KAAKgI,KAAKpE,MAAM4C,EAAMU,KAG7CsM,EAAFA,UAAEpK,GAAA,SAAGd,GACD,OAAOtI,KAAK2I,WAAWL,IAAUtI,KAAKgI,MAAQM,EAAMN,MAGtDwL,EAAFA,UAAEzI,OAAA,WACEhE,IAAI6M,EAAOH,YAAM1I,OAAA/P,KAAM,MAEvB,OADA4Y,EAAK5L,KAAOhI,KAAKgI,KACV4L,G,yCAzCU,CAASjC,GA6C9B,SAASa,EAAU/F,EAAOyE,GACxB,IAAKnK,IAAIlM,EAAI4R,EAAMhK,OAAS,EAAG5H,GAAK,EAAGA,IACrCqW,EAAMzE,EAAM5R,GAAG4E,KAAKrE,KAAO,IAAM8V,EAAM,IACzC,OAAOA,E,IC3ZI2C,EACX,SAAYb,GAGVhT,KAAKgT,SAAWA,EAChBhT,KAAKwB,KAAO,GACZxB,KAAK8T,UAAY,I,8FAGnBD,EAAOE,MAAA,SAAMC,EAAQC,GACnBlN,IAAImN,EAAS,IAAIC,EAAYH,EAAQC,GACrC,GAAmB,MAAfC,EAAO1S,KAAc,OAAOqS,EAAa9K,MAC7ChC,IAAIqN,EAAOC,EAAUH,GACjBA,EAAO1S,MAAM0S,EAAOpW,IAAI,4BAC5BiJ,IAAI2L,EA4UR,SAAa4B,GACXvN,IAAIwN,EAAUhZ,OAAOY,OAAO,MAC5B,OAEA,SAASqY,EAAQC,GACf1N,IAAI2N,EAAM,GACVD,EAAOlU,SAAO,SAAC2H,GACboM,EAAIpM,GAAM3H,SAAO,Y,oBACf,GAAKoU,EAAL,CACA5N,IAAI6N,EAAQF,EAAIG,QAAQF,GAAO1I,EAAM2I,GAAS,GAAKF,EAAIE,EAAQ,GAC/DE,EAASR,EAAKpN,GAAI3G,SAAO,SAAC2H,GACnB+D,GAAKyI,EAAIxS,KAAKyS,EAAM1I,EAAM,KACL,GAAtBA,EAAI4I,QAAQ3M,IAAa+D,EAAI/J,KAAKgG,aAK5C,IADAnB,IAAIrI,EAAQ6V,EAAQE,EAAO3J,KAAK,MAAQ,IAAI+I,EAAaY,EAAOI,QAAQP,EAAI7R,OAAS,IAAM,GAClF5H,EAAI,EAAGA,EAAI6Z,EAAIjS,OAAQ5H,GAAK,EAAG,CACtCkM,IAAI0N,EAASC,EAAI7Z,EAAI,GAAGgS,KAAKkI,GAC7BrW,EAAM8C,KAAKU,KAAKwS,EAAI7Z,GAAI0Z,EAAQE,EAAO3J,KAAK,OAAS0J,EAAQC,IAE/D,OAAO/V,EAnBF8V,CAAQM,EAASR,EAAK,IA9UfU,CAyPhB,SAAaZ,GACXrN,IAAIuN,EAAM,CAAC,IAEX,OADAW,EAWA,SAASC,EAAQd,EAAM5N,GACrB,GAAiB,UAAb4N,EAAK3U,KACP,OAAO2U,EAAKe,MAAMC,QAAM,SAAEV,EAAKN,GAAI,OAAKM,EAAI1O,OAAOkP,EAAQd,EAAM5N,MAAQ,IACpE,GAAiB,OAAb4N,EAAK3U,KACd,IAAKsH,IAAIlM,EAAI,GAAIA,IAAK,CACpBkM,IAAIvF,EAAO0T,EAAQd,EAAKe,MAAMta,GAAI2L,GAClC,GAAI3L,GAAKuZ,EAAKe,MAAM1S,OAAS,EAAG,OAAOjB,EACvCyT,EAAQzT,EAAMgF,EAAO0B,SAElB,IAAiB,QAAbkM,EAAK3U,KAAgB,CAC9BsH,IAAIsO,EAAOnN,IAGX,OAFAoN,EAAK9O,EAAM6O,GACXJ,EAAQC,EAAQd,EAAKA,KAAMiB,GAAOA,GAC3B,CAACC,EAAKD,IACR,GAAiB,QAAbjB,EAAK3U,KAAgB,CAC9BsH,IAAIsO,EAAOnN,IAGX,OAFA+M,EAAQC,EAAQd,EAAKA,KAAM5N,GAAO6O,GAClCJ,EAAQC,EAAQd,EAAKA,KAAMiB,GAAOA,GAC3B,CAACC,EAAKD,IACR,GAAiB,OAAbjB,EAAK3U,KACd,MAAO,CAAC6V,EAAK9O,IAAOR,OAAOkP,EAAQd,EAAKA,KAAM5N,IACzC,GAAiB,SAAb4N,EAAK3U,KAAiB,CAE/B,IADAsH,IAAIwO,EAAM/O,EACD3L,EAAI,EAAGA,EAAIuZ,EAAKzM,IAAK9M,IAAK,CACjCkM,IAAIvF,EAAO0G,IACX+M,EAAQC,EAAQd,EAAKA,KAAMmB,GAAM/T,GACjC+T,EAAM/T,EAER,IAAiB,GAAb4S,EAAK1M,IACPuN,EAAQC,EAAQd,EAAKA,KAAMmB,GAAMA,QAEjC,IAAKxO,IAAIlM,EAAIuZ,EAAKzM,IAAK9M,EAAIuZ,EAAK1M,IAAK7M,IAAK,CACxCkM,IAAIvF,EAAO0G,IACXoN,EAAKC,EAAK/T,GACVyT,EAAQC,EAAQd,EAAKA,KAAMmB,GAAM/T,GACjC+T,EAAM/T,EAGV,MAAO,CAAC8T,EAAKC,IACR,GAAiB,QAAbnB,EAAK3U,KACd,MAAO,CAAC6V,EAAK9O,EAAM,KAAM4N,EAAKtY,SAnD1BoZ,CAAQd,EAAM,GAAIlM,KACnBoM,EAEP,SAASpM,IAAS,OAAOoM,EAAIpS,KAAK,IAAM,EACxC,SAASoT,EAAK9O,EAAMU,EAAIyN,GACtB5N,IAAIuO,EAAO,CAAAX,KAACA,EAAIzN,GAAEA,GAElB,OADAoN,EAAI9N,GAAMtE,KAAKoT,GACRA,EAET,SAASL,EAAQO,EAAOtO,GAAMsO,EAAMjV,SAAO,SAAC+U,GAAA,OAAQA,EAAKpO,GAAKA,MApQ5CoN,CAAIF,IAEpB,OAmWJ,SAA0B1B,EAAOwB,GAC/B,IAAKnN,IAAIlM,EAAI,EAAG4a,EAAO,CAAC/C,GAAQ7X,EAAI4a,EAAKhT,OAAQ5H,IAAK,CAEpD,IADAkM,IAAIrI,EAAQ+W,EAAK5a,GAAI6a,GAAQhX,EAAMsU,SAAUxH,EAAQ,GAC5C1B,EAAI,EAAGA,EAAIpL,EAAM8C,KAAKiB,OAAQqH,GAAK,EAAG,CAC7C/C,IAAImB,EAAOxJ,EAAM8C,KAAKsI,GAAItI,EAAO9C,EAAM8C,KAAKsI,EAAI,GAChD0B,EAAMtJ,KAAKgG,EAAK9M,OACZsa,GAAUxN,EAAKC,QAAUD,EAAKyN,qBAAqBD,GAAO,IACnC,GAAvBD,EAAKZ,QAAQrT,IAAaiU,EAAKvT,KAAKV,GAEtCkU,GAAMxB,EAAOpW,IAAI,+BAAiC0N,EAAMV,KAAK,MAAQ,mFA7WzE8K,CAAiBlD,EAAOwB,GACjBxB,G,YAMTS,mBAAU1T,GACR,IAAKsH,IAAIlM,EAAI,EAAGA,EAAImF,KAAKwB,KAAKiB,OAAQ5H,GAAK,EACzC,GAAImF,KAAKwB,KAAK3G,IAAM4E,EAAM,OAAOO,KAAKwB,KAAK3G,EAAI,GACjD,OAAO,M,YAMT+X,uBAAciD,EAAMrO,EAAWD,Q,UAAH,Q,UAASsO,EAAKvM,YAExC,IADAvC,IAAIwO,EAAMvV,KACDnF,EAAI2M,EAAO+N,GAAO1a,EAAI0M,EAAK1M,IAClC0a,EAAMA,EAAIpC,UAAU0C,EAAKvO,MAAMzM,GAAG4E,MACpC,OAAO8V,GAGTlM,EAAI0H,cAAArV,IAAA,WACFqL,IAAI0B,EAAQzI,KAAKwB,KAAK,GACtB,QAAOiH,GAAQA,EAAMkI,UAMvBtH,EAAIyM,YAAApa,IAAA,WACF,IAAKqL,IAAIlM,EAAI,EAAGA,EAAImF,KAAKwB,KAAKiB,OAAQ5H,GAAK,EAAG,CAC5CkM,IAAItH,EAAOO,KAAKwB,KAAK3G,GACrB,IAAM4E,EAAK0I,SAAU1I,EAAKkW,mBAAqB,OAAOlW,I,YAI1DsW,oBAAWzN,GACT,IAAKvB,IAAIlM,EAAI,EAAGA,EAAImF,KAAKwB,KAAKiB,OAAQ5H,GAAK,EACzC,IAAKkM,IAAI+C,EAAI,EAAGA,EAAIxB,EAAM9G,KAAKiB,OAAQqH,GAAK,EAC1C,GAAI9J,KAAKwB,KAAK3G,IAAMyN,EAAM9G,KAAKsI,GAAI,OAAO,EAC9C,OAAO,G,YAUTkM,oBAAW3F,EAAO4F,EAAevH,Q,WAAP,Q,UAAoB,GAC5C3H,IAAImP,EAAO,CAAClW,MAgBZ,OAfA,SAASmW,EAAOzD,EAAO0D,GACrBrP,IAAIsP,EAAW3D,EAAME,cAAcvC,EAAO3B,GAC1C,GAAI2H,KAAcJ,GAASI,EAASrD,UAClC,OAAOlM,EAASN,KAAK4P,EAAM7P,KAAG,SAAC+P,GAAA,OAAMA,EAAGC,oBAE1C,IAAKxP,IAAIlM,EAAI,EAAGA,EAAI6X,EAAMlR,KAAKiB,OAAQ5H,GAAK,EAAG,CAC7CkM,IAAItH,EAAOiT,EAAMlR,KAAK3G,GAAI2G,EAAOkR,EAAMlR,KAAK3G,EAAI,GAChD,IAAM4E,EAAK0I,SAAU1I,EAAKkW,qBAA8C,GAAvBO,EAAKrB,QAAQrT,GAAa,CACzE0U,EAAKhU,KAAKV,GACVuF,IAAIrB,EAAQyQ,EAAO3U,EAAM4U,EAAMpQ,OAAOvG,IACtC,GAAIiG,EAAO,OAAOA,IAKjByQ,CAAOnW,KAAM,K,YAQtBwW,sBAAa/H,GACX,IAAK1H,IAAIlM,EAAI,EAAGA,EAAImF,KAAK8T,UAAUrR,OAAQ5H,GAAK,EAC9C,GAAImF,KAAK8T,UAAUjZ,IAAM4T,EAAQ,OAAOzO,KAAK8T,UAAUjZ,EAAI,GAC7DkM,IAAI0P,EAAWzW,KAAK0W,gBAAgBjI,GAEpC,OADAzO,KAAK8T,UAAU5R,KAAKuM,EAAQgI,GACrBA,G,YAGTC,yBAAgBjI,GAEd,IADA1H,IAAImP,EAAO3a,OAAOY,OAAO,MAAOwa,EAAS,CAAC,CAACjE,MAAO1S,KAAMP,KAAM,KAAMmX,IAAK,OAClED,EAAOlU,QAAQ,CACpBsE,IAAImC,EAAUyN,EAAOE,QAASnE,EAAQxJ,EAAQwJ,MAC9C,GAAIA,EAAMS,UAAU1E,GAAS,CAE3B,IADA1H,IAAIhG,EAAS,GACJpD,EAAMuL,EAASvL,EAAI8B,KAAM9B,EAAMA,EAAIiZ,IAC1C7V,EAAOmB,KAAKvE,EAAI8B,MAClB,OAAOsB,EAAOwC,UAEhB,IAAKwD,IAAIlM,EAAI,EAAGA,EAAI6X,EAAMlR,KAAKiB,OAAQ5H,GAAK,EAAG,CAC7CkM,IAAItH,EAAOiT,EAAMlR,KAAK3G,GACjB4E,EAAK2I,QAAW3I,EAAKkW,oBAAwBlW,EAAKrE,QAAQ8a,GAAWhN,EAAQzJ,OAAQiT,EAAMlR,KAAK3G,EAAI,GAAGmY,WAC1G2D,EAAOzU,KAAK,CAACwQ,MAAOjT,EAAKkT,aAAYlT,KAAEA,EAAMmX,IAAK1N,IAClDgN,EAAKzW,EAAKrE,OAAQ,MAS1BiO,EAAIyN,UAAApb,IAAA,WACF,OAAOsE,KAAKwB,KAAKiB,QAAU,G,YAM7B6S,cAAKhZ,GACHyK,IAAIlM,EAAIyB,GAAK,EACb,GAAIzB,GAAKmF,KAAKwB,KAAKiB,OAAQ,MAAM,IAAI8G,WAAU,cAAejN,EAAC,iCAC/D,MAAO,CAACmD,KAAMO,KAAKwB,KAAK3G,GAAI2G,KAAMxB,KAAKwB,KAAK3G,EAAI,K,YAGlD+P,oBACE7D,IAAImP,EAAO,GAOX,OANA,SAASa,EAAK9b,GACZib,EAAKhU,KAAKjH,GACV,IAAK8L,IAAIlM,EAAI,EAAGA,EAAII,EAAEuG,KAAKiB,OAAQ5H,GAAK,GACN,GAA5Bqb,EAAKrB,QAAQ5Z,EAAEuG,KAAK3G,KAAWkc,EAAK9b,EAAEuG,KAAK3G,IAEnDkc,CAAK/W,MACEkW,EAAK3P,KAAG,SAAEtL,EAAGJ,GAElB,IADAkM,IAAI2N,EAAM7Z,GAAKI,EAAE+X,SAAW,IAAM,KAAO,IAChCnY,EAAI,EAAGA,EAAII,EAAEuG,KAAKiB,OAAQ5H,GAAK,EACtC6Z,IAAQ7Z,EAAI,KAAO,IAAMI,EAAEuG,KAAK3G,GAAGO,KAAO,KAAO8a,EAAKrB,QAAQ5Z,EAAEuG,KAAK3G,EAAI,IAC3E,OAAO6Z,KACN5J,KAAK,O,uCAIZ+I,EAAa9K,MAAQ,IAAI8K,GAAa,GAEtC,IAAMM,EACJ,SAAYH,EAAQC,GAClBjU,KAAKgU,OAASA,EACdhU,KAAKiU,UAAYA,EACjBjU,KAAKgX,OAAS,KACdhX,KAAKqH,IAAM,EACXrH,KAAKiX,OAASjD,EAAOkD,MAAM,kBACgB,IAAvClX,KAAKiX,OAAOjX,KAAKiX,OAAOxU,OAAS,IAAUzC,KAAKiX,OAAOzT,MACrC,IAAlBxD,KAAKiX,OAAO,IAAUjX,KAAKiX,OAAOJ,S,2BAU1C,SAASxC,EAAUH,GACjBnN,IAAIoO,EAAQ,GACZ,GAAKA,EAAMjT,KAAKiV,EAAajD,UACtBA,EAAOkD,IAAI,MAClB,OAAuB,GAAhBjC,EAAM1S,OAAc0S,EAAM,GAAK,CAAC1V,KAAM,SAAQ0V,MAAEA,GAGzD,SAASgC,EAAajD,GACpBnN,IAAIoO,EAAQ,GACZ,GAAKA,EAAMjT,KAAKmV,EAAmBnD,UAC5BA,EAAO1S,MAAuB,KAAf0S,EAAO1S,MAA8B,KAAf0S,EAAO1S,MACnD,OAAuB,GAAhB2T,EAAM1S,OAAc0S,EAAM,GAAK,CAAC1V,KAAM,MAAK0V,MAAEA,GAGtD,SAASkC,EAAmBnD,GAE1B,IADAnN,IAAIqN,EA4CN,SAAuBF,GACrB,GAAIA,EAAOkD,IAAI,KAAM,CACnBrQ,IAAIqN,EAAOC,EAAUH,GAErB,OADKA,EAAOkD,IAAI,MAAMlD,EAAOpW,IAAI,yBAC1BsW,EACF,IAAK,KAAKkD,KAAKpD,EAAO1S,MAAO,CAClCuF,IAAIoO,EAlBR,SAAqBjB,EAAQ9Y,GAC3B2L,IAAIqP,EAAQlC,EAAOD,UAAWxU,EAAO2W,EAAMhb,GAC3C,GAAIqE,EAAM,MAAO,CAACA,GAClBsH,IAAIhG,EAAS,GACb,IAAKgG,IAAIwQ,KAAYnB,EAAO,CAC1BrP,IAAItH,EAAO2W,EAAMmB,GACb9X,EAAK+X,OAAO3C,QAAQzZ,IAAS,GAAG2F,EAAOmB,KAAKzC,GAE7B,GAAjBsB,EAAO0B,QAAayR,EAAOpW,IAAI,0BAA4B1C,EAAO,WACtE,OAAO2F,EASO0W,CAAYvD,EAAQA,EAAO1S,MAAM+E,KAAG,SAAC9G,GAG/C,OAFqB,MAAjByU,EAAO8C,OAAgB9C,EAAO8C,OAASvX,EAAKkR,SACvCuD,EAAO8C,QAAUvX,EAAKkR,UAAUuD,EAAOpW,IAAI,mCAC7C,CAAC2B,KAAM,OAAQ3D,MAAO2D,MAG/B,OADAyU,EAAO7M,MACgB,GAAhB8N,EAAM1S,OAAc0S,EAAM,GAAK,CAAC1V,KAAM,SAAQ0V,MAAEA,GAEvDjB,EAAOpW,IAAI,qBAAuBoW,EAAO1S,KAAO,KA1DvCkW,CAAcxD,KAEvB,GAAIA,EAAOkD,IAAI,KACbhD,EAAO,CAAC3U,KAAM,OAAM2U,KAAEA,QACnB,GAAIF,EAAOkD,IAAI,KAClBhD,EAAO,CAAC3U,KAAM,OAAM2U,KAAEA,QACnB,GAAIF,EAAOkD,IAAI,KAClBhD,EAAO,CAAC3U,KAAM,MAAK2U,KAAEA,OAClB,KAAIF,EAAOkD,IAAI,KAEf,MADHhD,EAAOuD,EAAezD,EAAQE,GAGlC,OAAOA,EAGT,SAASwD,EAAS1D,GACZ,KAAKoD,KAAKpD,EAAO1S,OAAO0S,EAAOpW,IAAI,yBAA2BoW,EAAO1S,KAAO,KAChFuF,IAAIhG,EAAS8W,OAAO3D,EAAO1S,MAE3B,OADA0S,EAAO7M,MACAtG,EAGT,SAAS4W,EAAezD,EAAQE,GAC9BrN,IAAIY,EAAMiQ,EAAS1D,GAASxM,EAAMC,EAMlC,OALIuM,EAAOkD,IAAI,OACW1P,EAAL,KAAfwM,EAAO1S,KAAmBoW,EAAS1D,IAC3B,GAETA,EAAOkD,IAAI,MAAMlD,EAAOpW,IAAI,yBAC1B,CAAC2B,KAAM,QAAOkI,IAAEA,EAAGD,IAAEA,EAAG0M,KAAEA,GAwGnC,SAASW,EAAIrL,EAAGC,GAAK,OAAOA,EAAID,EAKhC,SAASoL,EAASR,EAAKpM,GACrBnB,IAAIhG,EAAS,GAEb,OAEA,SAASgW,EAAK7O,GACZnB,IAAIyO,EAAQlB,EAAIpM,GAChB,GAAoB,GAAhBsN,EAAM/S,SAAgB+S,EAAM,GAAGb,KAAM,OAAOoC,EAAKvB,EAAM,GAAGtO,IAC9DnG,EAAOmB,KAAKgG,GACZ,IAAKnB,IAAIlM,EAAI,EAAGA,EAAI2a,EAAM/S,OAAQ5H,IAAK,CACrC,IAAN,EAAuB2a,EAAM3a,GAAlB8Z,EAAA,EAAAA,KAAMzN,EAAA,EAAAA,GACNyN,IAA+B,GAAvB5T,EAAO8T,QAAQ3N,IAAW6P,EAAK7P,IAThD6P,CAAK7O,GACEnH,EAAO8L,KAAKkI,GCpUrB,SAAShD,EAAatG,GACpB1E,IAAI+Q,EAAWvc,OAAOY,OAAO,MAC7B,IAAK4K,IAAIgR,KAAYtM,EAAO,CAC1B1E,IAAIiR,EAAOvM,EAAMsM,GACjB,IAAKC,EAAKC,WAAY,OAAO,KAC7BH,EAASC,GAAYC,EAAI,QAE3B,OAAOF,EAGT,SAASI,EAAazM,EAAO3P,GAC3BiL,IAAIoR,EAAQ5c,OAAOY,OAAO,MAC1B,IAAK4K,IAAI3L,KAAQqQ,EAAO,CACtB1E,IAAIqR,EAAQtc,GAASA,EAAMV,GAC3B,QAAcgG,IAAVgX,EAAqB,CACvBrR,IAAIiR,EAAOvM,EAAMrQ,GACjB,IAAI4c,EAAKC,WACJ,MAAM,IAAI1O,WAAW,mCAAqCnO,GAD1Cgd,EAAQJ,EAAI,QAGnCG,EAAM/c,GAAQgd,EAEhB,OAAOD,EAGT,SAASE,EAAU5M,GACjB1E,IAAIhG,EAASxF,OAAOY,OAAO,MAC3B,GAAIsP,EAAO,IAAK1E,IAAI3L,KAAQqQ,EAAO1K,EAAO3F,GAAQ,IAAIkd,GAAU7M,EAAMrQ,IACtE,OAAO2F,EDsIP0Q,EAAIjQ,KAAA9F,IAAA,WAAS,OAAOsE,KAAKiX,OAAOjX,KAAKqH,M,YAErC+P,aAAImB,GAAO,OAAOvY,KAAKwB,MAAQ+W,IAAQvY,KAAKqH,QAAS,I,YAErDvJ,aAAIoT,GAAO,MAAM,IAAIsH,YAAYtH,EAAM,4BAA8BlR,KAAKgU,OAAS,O,2CCnIxEyE,EACX,SAAYrd,EAAM6P,EAAQ2E,GAGxB5P,KAAK5E,KAAOA,EAIZ4E,KAAKiL,OAASA,EAIdjL,KAAK4P,KAAOA,EAEZ5P,KAAKwX,OAAS5H,EAAK8I,MAAQ9I,EAAK8I,MAAMxB,MAAM,KAAO,GACnDlX,KAAKyL,MAAQ4M,EAAUzI,EAAKnE,OAE5BzL,KAAK+R,aAAeA,EAAa/R,KAAKyL,OAItCzL,KAAK2S,aAAe,KAKpB3S,KAAK2Y,QAAU,KAIf3Y,KAAK+Q,cAAgB,KAIrB/Q,KAAKqI,UAAYuH,EAAKoH,QAAkB,QAAR5b,GAIhC4E,KAAKmI,OAAiB,QAAR/M,G,6IAKhBiO,GAAIsH,SAAAjV,IAAA,WAAa,OAAQsE,KAAKqI,SAK9BgB,GAAIgJ,YAAA3W,IAAA,WAAgB,OAAOsE,KAAKqI,SAAWrI,KAAK+Q,eAIhD1H,GAAIjB,OAAA1M,IAAA,WAAW,OAAOsE,KAAK2S,cAAgBkB,EAAa9K,OAKxDM,GAAIiJ,OAAA5W,IAAA,WAAW,OAAOsE,KAAKoI,QAAUpI,KAAK4P,KAAKgJ,MAI/CvP,GAAIwP,WAAAnd,IAAA,WAAe,OAAOsE,KAAK4P,KAAKiJ,aAAe7Y,KAAK4P,KAAKkJ,KAAO,MAAQ,W,YAI5EnD,4BACE,IAAK5O,IAAIzK,KAAK0D,KAAKyL,MAAO,GAAIzL,KAAKyL,MAAMnP,GAAGyc,WAAY,OAAO,EAC/D,OAAO,G,YAGTzK,2BAAkBhG,GAChB,OAAOtI,MAAQsI,GAAStI,KAAK2S,aAAaoD,WAAWzN,EAAMqK,e,YAG7DuF,sBAAazM,GACX,OAAKA,GAASzL,KAAK+R,aAAqB/R,KAAK+R,aACjCmG,EAAalY,KAAKyL,MAAOA,I,YAUvCtP,gBAAOsP,EAAOjG,EAASiH,GACrB,GAAIzM,KAAKmI,OAAQ,MAAM,IAAItJ,MAAM,8CACjC,OAAO,IAAI8S,EAAK3R,KAAMA,KAAKkY,aAAazM,GAAQ3E,EAASN,KAAKhB,GAAUqG,EAAKc,QAAQF,K,YAOvFuM,uBAAcvN,EAAOjG,EAASiH,GAE5B,GADAjH,EAAUsB,EAASN,KAAKhB,IACnBxF,KAAK+O,aAAavJ,GACrB,MAAM,IAAI+D,WAAW,4BAA8BvJ,KAAK5E,MAC1D,OAAO,IAAIuW,EAAK3R,KAAMA,KAAKkY,aAAazM,GAAQjG,EAASqG,EAAKc,QAAQF,K,YAUxE8J,uBAAc9K,EAAOjG,EAASiH,GAG5B,GAFAhB,EAAQzL,KAAKkY,aAAazM,IAC1BjG,EAAUsB,EAASN,KAAKhB,IACZiB,KAAM,CAChBM,IAAIqJ,EAASpQ,KAAK2S,aAAaqD,WAAWxQ,GAC1C,IAAK4K,EAAQ,OAAO,KACpB5K,EAAU4K,EAAOzJ,OAAOnB,GAE1BuB,IAAIsJ,EAAQrQ,KAAK2S,aAAaC,cAAcpN,GAASwQ,WAAWlP,EAASiC,OAAO,GAChF,OAAKsH,EACE,IAAIsB,EAAK3R,KAAMyL,EAAOjG,EAAQmB,OAAO0J,GAAQxE,EAAKc,QAAQF,IAD9C,M,YAOrBsC,sBAAavJ,GACXuB,IAAIhG,EAASf,KAAK2S,aAAaC,cAAcpN,GAC7C,IAAKzE,IAAWA,EAAOiS,SAAU,OAAO,EACxC,IAAKjM,IAAIlM,EAAI,EAAGA,EAAI2K,EAAQ8D,WAAYzO,IACtC,IAAKmF,KAAKiT,YAAYzN,EAAQ8B,MAAMzM,GAAG4R,OAAQ,OAAO,EACxD,OAAO,G,YAKTwM,wBAAeC,GACb,OAAuB,MAAhBlZ,KAAK2Y,SAAmB3Y,KAAK2Y,QAAQ9D,QAAQqE,IAAa,G,YAKnEjG,qBAAYxG,GACV,GAAoB,MAAhBzM,KAAK2Y,QAAiB,OAAO,EACjC,IAAK5R,IAAIlM,EAAI,EAAGA,EAAI4R,EAAMhK,OAAQ5H,IAAK,IAAKmF,KAAKiZ,eAAexM,EAAM5R,GAAG4E,MAAO,OAAO,EACvF,OAAO,G,YAKT0Z,sBAAa1M,GACX,GAAoB,MAAhBzM,KAAK2Y,QAAiB,OAAOlM,EAEjC,IADA1F,IAAIoC,EACKtO,EAAI,EAAGA,EAAI4R,EAAMhK,OAAQ5H,IAC3BmF,KAAKiZ,eAAexM,EAAM5R,GAAG4E,MAEvB0J,GACTA,EAAKjH,KAAKuK,EAAM5R,IAFXsO,IAAMA,EAAOsD,EAAM7I,MAAM,EAAG/I,IAKrC,OAAQsO,EAAeA,EAAK1G,OAAS0G,EAAO0C,EAAK9C,MAAlC0D,GAGjBgM,EAAOvD,QAAA,SAAQ1J,EAAOP,GACpBlE,IAAIhG,EAASxF,OAAOY,OAAO,MAC3BqP,EAAMjL,SAAO,SAAEnF,EAAMwU,GAAI,OAAK7O,EAAO3F,GAAQ,IAAIqd,EAASrd,EAAM6P,EAAQ2E,MAExE7I,IAAIqS,EAAUnO,EAAO2E,KAAKyJ,SAAW,MACrC,IAAKtY,EAAOqY,GAAU,MAAM,IAAI7P,WAAW,yCAA2C6P,EAAU,MAChG,IAAKrY,EAAOiH,KAAM,MAAM,IAAIuB,WAAW,oCACvC,IAAKxC,IAAIwF,KAAKxL,EAAOiH,KAAKyD,MAAO,MAAM,IAAIlC,WAAW,iDAEtD,OAAOxI,G,wCAMX,IAAMuX,GACJ,SAAYgB,GACVtZ,KAAKiY,WAAa1c,OAAOkB,UAAUC,eAAe1B,KAAKse,EAAS,WAChEtZ,KAAA,QAAesZ,EAAO,S,kCAGxB7H,GAAIsH,WAAArd,IAAA,WACF,OAAQsE,KAAKiY,Y,6CAUJsB,GACX,SAAYne,EAAMgR,EAAMnB,EAAQ2E,GAG9B5P,KAAK5E,KAAOA,EAIZ4E,KAAKiL,OAASA,EAIdjL,KAAK4P,KAAOA,EAEZ5P,KAAKyL,MAAQ4M,EAAUzI,EAAKnE,OAE5BzL,KAAKoM,KAAOA,EACZpM,KAAKwZ,SAAW,KAChBzS,IAAI+Q,EAAW/F,EAAa/R,KAAKyL,OACjCzL,KAAKyZ,SAAW3B,GAAY,IAAIjM,EAAK7L,KAAM8X,I,aAO7C3b,gBAAOsP,GACL,OAAKA,GAASzL,KAAKyZ,SAAiBzZ,KAAKyZ,SAClC,IAAI5N,EAAK7L,KAAMkY,EAAalY,KAAKyL,MAAOA,KAGjD8N,GAAOrE,QAAA,SAAQzI,EAAOxB,GACpBlE,IAAIhG,EAASxF,OAAOY,OAAO,MAAOiQ,EAAO,EAEzC,OADAK,EAAMlM,SAAO,SAAEnF,EAAMwU,GAAI,OAAK7O,EAAO3F,GAAQ,IAAIme,GAASne,EAAMgR,IAAQnB,EAAQ2E,MACzE7O,G,aAMTsL,uBAAcJ,GACZ,IAAK,IAAIpR,EAAI,EAAGA,EAAIoR,EAAIxJ,OAAQ5H,IAASoR,EAAIpR,GAAG4E,MAAQO,OACtDiM,EAAMA,EAAIrI,MAAM,EAAG/I,GAAGmL,OAAOiG,EAAIrI,MAAM/I,EAAI,IAC3CA,KAEF,OAAOoR,G,aAKTK,iBAAQL,GACN,IAAKlF,IAAIlM,EAAI,EAAGA,EAAIoR,EAAIxJ,OAAQ5H,IAC9B,GAAIoR,EAAIpR,GAAG4E,MAAQO,KAAM,OAAOiM,EAAIpR,I,aAMxCsR,kBAAS7D,GACP,OAAOtI,KAAKwZ,SAAS3E,QAAQvM,IAAU,G,IAoL9BoR,GAGX,SAAY9J,GAQV,IAAK7I,IAAIH,KADT5G,KAAK4P,KAAO,GACKA,EAAM5P,KAAK4P,KAAKhJ,GAAQgJ,EAAKhJ,GAC9C5G,KAAK4P,KAAKpE,MAAQjG,EAAWiB,KAAKoJ,EAAKpE,OACvCxL,KAAK4P,KAAKnD,MAAQlH,EAAWiB,KAAKoJ,EAAKnD,OAIvCzM,KAAKwL,MAAQiN,EAASvD,QAAQlV,KAAK4P,KAAKpE,MAAOxL,MAI/CA,KAAKyM,MAAQ8M,GAASrE,QAAQlV,KAAK4P,KAAKnD,MAAOzM,MAE/C+G,IAAI4S,EAAmBpe,OAAOY,OAAO,MACrC,IAAK4K,IAAIH,KAAQ5G,KAAKwL,MAAO,CAC3B,GAAI5E,KAAQ5G,KAAKyM,MACf,MAAM,IAAIlD,WAAW3C,EAAO,sCAC9BG,IAAItH,EAAOO,KAAKwL,MAAM5E,GAAOgT,EAAcna,EAAKmQ,KAAKpK,SAAW,GAAIqU,EAAWpa,EAAKmQ,KAAKnD,MACzFhN,EAAKkT,aAAegH,EAAiBC,KAClCD,EAAiBC,GAAe/F,EAAaE,MAAM6F,EAAa5Z,KAAKwL,QACxE/L,EAAKsR,cAAgBtR,EAAKkT,aAAa5B,cACvCtR,EAAKkZ,QAAsB,KAAZkB,EAAkB,KAC/BA,EAAWC,GAAY9Z,KAAM6Z,EAAS3C,MAAM,MAChC,IAAZ2C,GAAmBpa,EAAKsR,cAAqB,KAAL,GAE5C,IAAKhK,IAAIH,KAAQ5G,KAAKyM,MAAO,CAC3B1F,IAAItH,EAAOO,KAAKyM,MAAM7F,GAAOmT,EAAOta,EAAKmQ,KAAKzD,SAC9C1M,EAAK+Z,SAAmB,MAARO,EAAe,CAACta,GAAgB,IAARsa,EAAa,GAAKD,GAAY9Z,KAAM+Z,EAAK7C,MAAM,MAGzFlX,KAAKoL,aAAepL,KAAKoL,aAAa/O,KAAK2D,MAC3CA,KAAKsT,aAAetT,KAAKsT,aAAajX,KAAK2D,MAK3CA,KAAKga,YAAcha,KAAKwL,MAAMxL,KAAK4P,KAAKyJ,SAAW,OAMnDrZ,KAAKsR,OAAS/V,OAAOY,OAAO,MAC5B6D,KAAKsR,OAAO2I,UAAY1e,OAAOY,OAAO,OAuD1C,SAAS2d,GAAY7O,EAAQwB,GAE3B,IADA1F,IAAIrB,EAAQ,GACH7K,EAAI,EAAGA,EAAI4R,EAAMhK,OAAQ5H,IAAK,CACrCkM,IAAI3L,EAAOqR,EAAM5R,GAAIkI,EAAOkI,EAAOwB,MAAMrR,GAAO8e,EAAKnX,EACrD,GAAIA,EACF2C,EAAMxD,KAAKa,QAEX,IAAKgE,IAAIH,KAAQqE,EAAOwB,MAAO,CAC7B1F,IAAIhE,EAAOkI,EAAOwB,MAAM7F,IACZ,KAARxL,GAAgB2H,EAAK6M,KAAK8I,OAAS3V,EAAK6M,KAAK8I,MAAMxB,MAAM,KAAKrC,QAAQzZ,IAAS,IACjFsK,EAAMxD,KAAKgY,EAAKnX,GAGtB,IAAKmX,EAAI,MAAM,IAAI1B,YAAY,uBAAyB/L,EAAM5R,GAAK,KAErE,OAAO6K,E,aA9DPwC,cAAKzI,EAAMgM,EAAOjG,EAASiH,GACzB,GAAmB,iBAARhN,EACTA,EAAOO,KAAKuT,SAAS9T,OAClB,MAAMA,aAAgBgZ,GACzB,MAAM,IAAIlP,WAAW,sBAAwB9J,GAC1C,GAAIA,EAAKwL,QAAUjL,KACtB,MAAM,IAAIuJ,WAAW,yCAA2C9J,EAAKrE,KAAO,KAE9E,OAAOqE,EAAKuZ,cAAcvN,EAAOjG,EAASiH,I,aAM5CzE,cAAKA,EAAMyE,GACT1F,IAAItH,EAAOO,KAAKwL,MAAMxD,KACtB,OAAO,IAAIwL,EAAS/T,EAAMA,EAAKsS,aAAc/J,EAAM6D,EAAKc,QAAQF,K,aAKlE1J,cAAKtD,EAAMgM,GAET,MADmB,iBAARhM,IAAkBA,EAAOO,KAAKyM,MAAMhN,IACxCA,EAAKtD,OAAOsP,I,aAMrBL,sBAAaoB,GACX,OAAOmF,EAAK3G,SAAShL,KAAMwM,I,aAM7B8G,sBAAa9G,GACX,OAAOX,EAAKb,SAAShL,KAAMwM,I,aAG7B+G,kBAASnY,GACP2L,IAAIrB,EAAQ1F,KAAKwL,MAAMpQ,GACvB,IAAKsK,EAAO,MAAM,IAAI6D,WAAW,sBAAwBnO,GACzD,OAAOsK,G,IChbEyU,GAIX,SAAYlP,EAAQmP,G,WAGlBpa,KAAKiL,OAASA,EAIdjL,KAAKoa,MAAQA,EACbpa,KAAKqa,KAAO,GACZra,KAAKsa,OAAS,GAEdF,EAAM7Z,SAAO,SAACga,GACRA,EAAKC,IAAKxa,EAAKqa,KAAKnY,KAAKqY,GACpBA,EAAKE,OAAOza,EAAKsa,OAAOpY,KAAKqY,MAIxCva,KAAK0a,gBAAkB1a,KAAKqa,KAAKM,MAAI,SAAChf,GACpC,IAAK,aAAa2b,KAAK3b,EAAE6e,OAAS7e,EAAEuM,KAAM,OAAO,EACjDnB,IAAImB,EAAO+C,EAAOO,MAAM7P,EAAEuM,MAC1B,OAAOA,EAAKyK,aAAaQ,UAAUjL,O,aAMvC6L,eAAM6G,EAAKtB,Q,UAAU,IACnBvS,IAAIxI,EAAU,IAAIsc,GAAa7a,KAAMsZ,GAAS,GAE9C,OADA/a,EAAQuc,OAAOF,EAAK,KAAMtB,EAAQ9S,KAAM8S,EAAQpS,IACzC3I,EAAQiG,U,aAUjBuW,oBAAWH,EAAKtB,Q,UAAU,IACxBvS,IAAIxI,EAAU,IAAIsc,GAAa7a,KAAMsZ,GAAS,GAE9C,OADA/a,EAAQuc,OAAOF,EAAK,KAAMtB,EAAQ9S,KAAM8S,EAAQpS,IACzC4F,EAAM4C,QAAQnR,EAAQiG,W,aAG/BwW,kBAASJ,EAAKrc,EAAS8R,GACrB,IAAKtJ,IAAIlM,EAAIwV,EAAQrQ,KAAKqa,KAAKxF,QAAQxE,GAAS,EAAI,EAAGxV,EAAImF,KAAKqa,KAAK5X,OAAQ5H,IAAK,CAChFkM,IAAIwT,EAAOva,KAAKqa,KAAKxf,GACrB,GAAIogB,GAAQL,EAAKL,EAAKC,YACEpZ,IAAnBmZ,EAAKW,WAA2BN,EAAIO,cAAgBZ,EAAKW,cACxDX,EAAKhc,SAAWA,EAAQ6c,eAAeb,EAAKhc,UAAW,CAC3D,GAAIgc,EAAKc,SAAU,CACjBtU,IAAIhG,EAASwZ,EAAKc,SAAST,GAC3B,IAAe,IAAX7Z,EAAkB,SACtBwZ,EAAK9O,MAAQ1K,EAEf,OAAOwZ,K,aAKbe,oBAAW1U,EAAM9K,EAAOyC,EAAS8R,GAC/B,IAAKtJ,IAAIlM,EAAIwV,EAAQrQ,KAAKsa,OAAOzF,QAAQxE,GAAS,EAAI,EAAGxV,EAAImF,KAAKsa,OAAO7X,OAAQ5H,IAAK,CACpFkM,IAAIwT,EAAOva,KAAKsa,OAAOzf,GACvB,KAAgC,GAA5B0f,EAAKE,MAAM5F,QAAQjO,IACnB2T,EAAKhc,UAAYA,EAAQ6c,eAAeb,EAAKhc,UAI7Cgc,EAAKE,MAAMhY,OAASmE,EAAKnE,SACc,IAAtC8X,EAAKE,MAAMc,WAAW3U,EAAKnE,SAAiB8X,EAAKE,MAAM7W,MAAMgD,EAAKnE,OAAS,IAAM3G,IANtF,CAQA,GAAIye,EAAKc,SAAU,CACjBtU,IAAIhG,EAASwZ,EAAKc,SAASvf,GAC3B,IAAe,IAAXiF,EAAkB,SACtBwZ,EAAK9O,MAAQ1K,EAEf,OAAOwZ,KAKXJ,GAAOqB,YAAA,SAAYvQ,GACjBlE,IAAIhG,EAAS,GACb,SAASqO,EAAOmL,GAEd,IADAxT,IAAI0U,EAA4B,MAAjBlB,EAAKkB,SAAmB,GAAKlB,EAAKkB,SAAU5gB,EAAI,EACxDA,EAAIkG,EAAO0B,OAAQ5H,IAAK,CAC7BkM,IAAIvF,EAAOT,EAAOlG,GAClB,IADsD,MAAjB2G,EAAKia,SAAmB,GAAKja,EAAKia,UACpDA,EAAU,MAE/B1a,EAAO+E,OAAOjL,EAAG,EAAG0f,GAGxB,IAAF,cACMxT,IAAIqT,EAAQnP,EAAOwB,MAAMrR,GAAMwU,KAAK8L,SAChCtB,GAAOA,EAAM7Z,SAAO,SAACga,GACvBnL,EAAOmL,EAAOpR,GAAKoR,IACnBA,EAAKxX,KAAO3H,MAJhB,IAAK2L,IAAI3L,KAAQ6P,EAAOwB,MAAK4I,KAO/B,IACQ+E,EADN,IAAKrT,IAAI3L,KAAQ6P,EAAOO,MAClB4O,YAAQnP,EAAOO,MAAMpQ,GAAMwU,KAAK8L,WACzBtB,EAAM7Z,SAAO,SAACga,GACvBnL,EAAOmL,EAAOpR,GAAKoR,IACnBA,EAAKrS,KAAO9M,KAGhB,OAAO2F,GAOToZ,GAAOwB,WAAA,SAAW1Q,GAChB,OAAOA,EAAOqG,OAAOsK,YAClB3Q,EAAOqG,OAAOsK,UAAY,IAAIzB,GAAUlP,EAAQkP,GAAUqB,YAAYvQ,MAK7ES,IAAMmQ,GAAY,CAChBC,SAAS,EAAMC,SAAS,EAAMC,OAAO,EAAMC,YAAY,EAAMC,QAAQ,EACrEC,IAAI,EAAMC,KAAK,EAAMC,IAAI,EAAMC,UAAU,EAAMC,YAAY,EAAMC,QAAQ,EACzEC,QAAQ,EAAMC,MAAM,EAAMC,IAAI,EAAMC,IAAI,EAAMC,IAAI,EAAMC,IAAI,EAAMC,IAAI,EACtEC,IAAI,EAAMC,QAAQ,EAAMC,QAAQ,EAAMC,IAAI,EAAMC,IAAI,EAAMC,UAAU,EAAMC,IAAI,EAC9EC,QAAQ,EAAM5gB,GAAG,EAAM6gB,KAAK,EAAMC,SAAS,EAAMC,OAAO,EAAMC,OAAO,EAAMC,IAAI,GAI3EC,GAAa,CACjBC,MAAM,EAAMT,UAAU,EAAM9gB,QAAQ,EAAMwhB,QAAQ,EAAMtD,OAAO,EAAMuD,OAAO,GAIxEC,GAAW,CAACX,IAAI,EAAMM,IAAI,GAKhC,SAASM,GAAaze,EAAM0e,EAAoBvK,GAC9C,OAA0B,MAAtBuK,GAAoCA,EAHlB,EAGyD,IACrD,SAAvBA,EAJ6C,EAIU,GACnD1e,GAA2B,OAAnBA,EAAKoZ,WAAsBuF,GAAgD,EAAPxK,EAGrF,IAAMyK,GACJ,SAAY5e,EAAMgM,EAAOgB,EAAO6R,EAAcC,EAAO7L,EAAO4G,GAC1DtZ,KAAKP,KAAOA,EACZO,KAAKyL,MAAQA,EACbzL,KAAKue,MAAQA,EACbve,KAAK0S,MAAQA,IAboD,EAa1C4G,EAA0B,KAAO7Z,EAAKkT,cAC7D3S,KAAKsZ,QAAUA,EACftZ,KAAKwF,QAAU,GAEfxF,KAAKyM,MAAQA,EAEbzM,KAAKwe,YAAc3S,EAAKe,KAExB5M,KAAKse,aAAeA,EAEpBte,KAAKye,WAAa,I,aAGpBjI,sBAAatO,GACX,IAAKlI,KAAK0S,MAAO,CACf,IAAK1S,KAAKP,KAAM,MAAO,GACvBsH,IAAI2X,EAAO1e,KAAKP,KAAKkT,aAAaqD,WAAWlP,EAASN,KAAK0B,IAC3D,IAAIwW,EAEG,CACL3X,IAAoChJ,EAAhCyJ,EAAQxH,KAAKP,KAAKkT,aACtB,OAAI5U,EAAOyJ,EAAMgP,aAAatO,EAAKzI,QACjCO,KAAK0S,MAAQlL,EACNzJ,GAEA,KAPTiC,KAAK0S,MAAQ1S,KAAKP,KAAKkT,aAAaC,cAAc8L,GAWtD,OAAO1e,KAAK0S,MAAM8D,aAAatO,EAAKzI,O,aAGtC+E,gBAAOwI,GACL,KA9CoB,EA8CdhN,KAAKsZ,SAA4B,CACrCvS,IAAkD9L,EAA9CsN,EAAOvI,KAAKwF,QAAQxF,KAAKwF,QAAQ/C,OAAS,GAC1C8F,GAAQA,EAAKJ,SAAWlN,EAAI,oBAAoB0jB,KAAKpW,EAAKP,SACxDO,EAAKP,KAAKvF,QAAUxH,EAAE,GAAGwH,OAAQzC,KAAKwF,QAAQhC,MAC7CxD,KAAKwF,QAAQxF,KAAKwF,QAAQ/C,OAAS,GAAK8F,EAAKK,SAASL,EAAKP,KAAKpE,MAAM,EAAG2E,EAAKP,KAAKvF,OAASxH,EAAE,GAAGwH,UAG1GsE,IAAIvB,EAAUsB,EAASN,KAAKxG,KAAKwF,SAGjC,OAFKwH,GAAWhN,KAAK0S,QACnBlN,EAAUA,EAAQmB,OAAO3G,KAAK0S,MAAMsD,WAAWlP,EAASiC,OAAO,KAC1D/I,KAAKP,KAAOO,KAAKP,KAAKtD,OAAO6D,KAAKyL,MAAOjG,EAASxF,KAAKyM,OAASjH,G,aAGzEoZ,0BAAiB7b,GACf,IAAKgE,IAAIlM,EAAImF,KAAKye,WAAWhc,OAAS,EAAG5H,GAAK,EAAGA,IAC/C,GAAIkI,EAAKqG,GAAGpJ,KAAKye,WAAW5jB,IAAK,OAAOmF,KAAKye,WAAW3Y,OAAOjL,EAAG,GAAG,I,aAGzEgkB,sBAAaC,GACX,IAAK/X,IAAIlM,EAAI,EAAGkkB,EAAU/e,KAAKse,aAAczjB,EAAIkkB,EAAQtc,OAAQ5H,IAAK,CACpEkM,IAAIhE,EAAOgc,EAAQlkB,IACdmF,KAAKP,KAAOO,KAAKP,KAAKwZ,eAAelW,EAAKtD,MAAQuf,GAAajc,EAAKtD,KAAMqf,MAC1E/b,EAAKuJ,QAAQtM,KAAKwe,eACrBxe,KAAKwe,YAAczb,EAAKiJ,SAAShM,KAAKwe,aACtCxe,KAAKse,aAAevb,EAAKsJ,cAAcrM,KAAKse,iB,aAKlDW,uBAAc/W,GACZ,OAAIlI,KAAKP,KAAaO,KAAKP,KAAKsR,cAC5B/Q,KAAKwF,QAAQ/C,OAAezC,KAAKwF,QAAQ,GAAGmL,SACzCzI,EAAKgX,aAAerD,GAAUnf,eAAewL,EAAKgX,WAAWC,SAASC,gBAIjF,IAAMvE,GAEJ,SAAYwE,EAAQ/F,EAASgG,GAE3Btf,KAAKqf,OAASA,EAEdrf,KAAKsZ,QAAUA,EACftZ,KAAKuf,OAASD,EACdvY,IAA+ByY,EAA3BnG,EAAUC,EAAQD,QAClBoG,EAAavB,GAAa,KAAM5E,EAAQ6E,mBAAoB,IAAMmB,EA3FL,EA2F4B,GAE3FE,EADEnG,EACW,IAAIgF,GAAYhF,EAAQ5Z,KAAM4Z,EAAQ5N,MAAOI,EAAKe,KAAMf,EAAKe,MAAM,EACnD0M,EAAQoG,UAAYrG,EAAQ5Z,KAAKkT,aAAc8M,GAE/D,IAAIpB,GADViB,EACsB,KAEAD,EAAOpU,OAAO+O,YAFR,KAAMnO,EAAKe,KAAMf,EAAKe,MAAM,EAAM,KAAM6S,GAG7Ezf,KAAKwL,MAAQ,CAACgU,GAEdxf,KAAKsf,KAAO,EACZtf,KAAKyF,KAAO6T,EAAQqG,cACpB3f,KAAK4f,YAAa,G,wDAoYtB,SAAS3E,GAAQL,EAAKiF,GACpB,OAAQjF,EAAIK,SAAWL,EAAIkF,mBAAqBlF,EAAImF,uBAAyBnF,EAAIoF,oBAAoBhlB,KAAK4f,EAAKiF,GAWjH,SAAS1W,GAAKxL,GACZoJ,IAAIoC,EAAO,GACX,IAAKpC,IAAIH,KAAQjJ,EAAKwL,EAAKvC,GAAQjJ,EAAIiJ,GACvC,OAAOuC,EAMT,SAAS6V,GAAa9F,EAAU3F,GAC9BxM,IAAIyE,EAAQ+H,EAAStI,OAAOO,MAC9B,cACIzE,IAAIK,EAASoE,EAAMpQ,GACnB,GAAKgM,EAAO6R,eAAeC,GAA3B,CACAnS,IAAImP,EAAO,GAQX,OARsB,SAAPa,EAAOrE,GACpBwD,EAAKhU,KAAKwQ,GACV,IAAK3L,IAAIlM,EAAI,EAAGA,EAAI6X,EAAMoE,UAAWjc,IAAK,CACxC,IAAR,EAA2B6X,EAAM4C,KAAKza,GAAzB4E,EAAA,EAAAA,KAAM+B,EAAA,EAAAA,KACX,GAAI/B,GAAQ8T,EAAU,OAAO,EAC7B,GAAI2C,EAAKrB,QAAQrT,GAAQ,GAAKuV,EAAKvV,GAAO,OAAO,GAGjDuV,CAAK3P,EAAOuL,cAAe,CAAAsN,GAAO,QAAtC,IAXF,IAAKlZ,IAAI3L,KAAQoQ,EAAK,C,4BAxZtBnC,GAAI6W,IAAAxkB,IAAA,WACF,OAAOsE,KAAKwL,MAAMxL,KAAKsf,O,aAOzBa,gBAAOvF,GACL,GAAoB,GAAhBA,EAAIrH,SACNvT,KAAKogB,YAAYxF,QACZ,GAAoB,GAAhBA,EAAIrH,SAAe,CAC5BxM,IAAI0T,EAAQG,EAAIyF,aAAa,SACzB5T,EAAQgO,EAAQza,KAAKsgB,WA0X/B,SAAqB7F,GACnB1T,IAAuC9L,EAAnCslB,EAAK,6BAAiCxf,EAAS,GACnD,KAAO9F,EAAIslB,EAAG5B,KAAKlE,IAAQ1Z,EAAOmB,KAAKjH,EAAE,GAAIA,EAAE,GAAGulB,QAClD,OAAOzf,EA7XiC0f,CAAYhG,IAAU,KAAMyF,EAAMlgB,KAAKkgB,IAC3E,GAAa,MAATzT,EAAe,IAAK1F,IAAIlM,EAAI,EAAGA,EAAI4R,EAAMhK,OAAQ5H,IAAKmF,KAAK0gB,eAAejU,EAAM5R,IAEpF,GADAmF,KAAK2gB,WAAW/F,GACH,MAATnO,EAAe,IAAK1F,IAAIlM,EAAI,EAAGA,EAAI4R,EAAMhK,OAAQ5H,IAAKmF,KAAK4gB,kBAAkBnU,EAAM5R,GAAIqlB,K,aAI/FE,qBAAYxF,GACV7T,IAAIjL,EAAQ8e,EAAIiG,UACZX,EAAMlgB,KAAKkgB,IACf,GAjI8C,EAiI1CA,EAAI5G,SACJ4G,EAAIjB,cAAcrE,IAClB,mBAAmBtD,KAAKxb,GAAQ,CAClC,GApIkB,EAoIZokB,EAAI5G,QAgBRxd,EApJ0C,EAiJ/BokB,EAAI5G,QAGPxd,EAAMmR,QAAQ,SAAU,MAFxBnR,EAAMmR,QAAQ,YAAa,UATnC,GAJAnR,EAAQA,EAAMmR,QAAQ,oBAAqB,KAIvC,mBAAmBqK,KAAKxb,IAAUkE,KAAKsf,MAAQtf,KAAKwL,MAAM/I,OAAS,EAAG,CACxEsE,IAAI+H,EAAaoR,EAAI1a,QAAQ0a,EAAI1a,QAAQ/C,OAAS,GAC9Cqe,EAAgBlG,EAAImG,kBACnBjS,GACAgS,GAA2C,MAA1BA,EAAc3B,UAC/BrQ,EAAW3G,QAAU,mBAAmBmP,KAAKxI,EAAW9G,SAC3DlM,EAAQA,EAAM8H,MAAM,IAOtB9H,GAAOkE,KAAKghB,WAAWhhB,KAAKqf,OAAOpU,OAAOjD,KAAKlM,IACnDkE,KAAKihB,WAAWrG,QAEhB5a,KAAKkhB,WAAWtG,I,aAOpB+F,oBAAW/F,EAAKuG,GACdpa,IAAuCqa,EAAnChmB,EAAOwf,EAAIuE,SAASC,cACpBnB,GAASvhB,eAAetB,IAAS4E,KAAKqf,OAAO3E,gBA0TrD,SAAuBE,GACrB,IAAK7T,IAAIO,EAAQsT,EAAIlS,WAAY2Y,EAAW,KAAM/Z,EAAOA,EAAQA,EAAMga,YAAa,CAClFva,IAAI3L,EAAyB,GAAlBkM,EAAMiM,SAAgBjM,EAAM6X,SAASC,cAAgB,KAC5DhkB,GAAQ6iB,GAASvhB,eAAetB,IAASimB,GAC3CA,EAASE,YAAYja,GACrBA,EAAQ+Z,GACS,MAARjmB,EACTimB,EAAW/Z,EACFlM,IACTimB,EAAW,OAnUoDG,CAAc5G,GAC/E7T,IAAIwT,EAAQva,KAAKsZ,QAAQmI,cAAgBzhB,KAAKsZ,QAAQmI,aAAa7G,KAC9DwG,EAASphB,KAAKqf,OAAOrE,SAASJ,EAAK5a,KAAMmhB,IAC9C,GAAI5G,EAAOA,EAAKmH,OAAS7D,GAAWnhB,eAAetB,GACjD4E,KAAKkhB,WAAWtG,GAChB5a,KAAK2hB,eAAe/G,QACf,IAAKL,GAAQA,EAAKqH,MAAQrH,EAAKsH,YAAa,CAC7CtH,GAAQA,EAAKsH,YAAa7hB,KAAKsf,KAAO7X,KAAKC,IAAI,EAAG1H,KAAKsf,KAAO,GACzD/E,GAAQA,EAAKqH,KAAKrO,WAAUqH,EAAML,EAAKqH,MAChD7a,IAAI+a,EAAM5B,EAAMlgB,KAAKkgB,IAAK6B,EAAgB/hB,KAAK4f,WAC/C,GAAI/D,GAAUnf,eAAetB,GAC3B0mB,GAAO,EACF5B,EAAIzgB,OAAMO,KAAK4f,YAAa,QAC5B,IAAKhF,EAAIlS,WAEd,YADA1I,KAAKgiB,aAAapH,GAGpB5a,KAAK8a,OAAOF,GACRkH,GAAM9hB,KAAK8hB,KAAK5B,GACpBlgB,KAAK4f,WAAamC,OAElB/hB,KAAKiiB,iBAAiBrH,EAAKL,GAAyB,IAAnBA,EAAK2H,UAAsBd,EAAS,O,aAKzEY,sBAAapH,GACS,MAAhBA,EAAIuE,UAAoBnf,KAAKkgB,IAAIzgB,MAAQO,KAAKkgB,IAAIzgB,KAAKsR,eACzD/Q,KAAKogB,YAAYxF,EAAIuH,cAAcC,eAAe,Q,aAItDT,wBAAe/G,GAEO,MAAhBA,EAAIuE,UAAsBnf,KAAKkgB,IAAIzgB,MAASO,KAAKkgB,IAAIzgB,KAAKsR,eAC5D/Q,KAAKqiB,UAAUriB,KAAKqf,OAAOpU,OAAOjD,KAAK,O,aAM3CsY,oBAAWhG,GACTvT,IAAI0F,EAAQZ,EAAKe,KACjB6N,EAAO,IAAK1T,IAAIlM,EAAI,EAAGA,EAAIyf,EAAO7X,OAAQ5H,GAAK,EAC7C,IAAKkM,IAAIsJ,EAAQ,OAAQ,CACvBtJ,IAAIwT,EAAOva,KAAKqf,OAAO/D,WAAWhB,EAAOzf,GAAIyf,EAAOzf,EAAI,GAAImF,KAAMqQ,GAClE,IAAKkK,EAAM,SAASE,EACpB,GAAIF,EAAKmH,OAAQ,OAAO,KAExB,GADAjV,EAAQzM,KAAKqf,OAAOpU,OAAOwB,MAAM8N,EAAKxX,MAAM5G,OAAOoe,EAAK9O,OAAOO,SAASS,IACjD,IAAnB8N,EAAK2H,UACJ,MADyB7R,EAAQkK,EAI1C,OAAO9N,G,aAOTwV,0BAAiBrH,EAAKL,EAAM+H,G,IACtBR,EAAMvO,EAAoBxQ,E,OAC1BwX,EAAKrS,MACPqL,EAAWvT,KAAKqf,OAAOpU,OAAOO,MAAM+O,EAAKrS,OAC3BE,OAEFpI,KAAKghB,WAAWzN,EAASpX,OAAOoe,EAAK9O,SAC/CzL,KAAKgiB,aAAapH,GAFlBkH,EAAO9hB,KAAKuiB,MAAMhP,EAAUgH,EAAK9O,MAAO8O,EAAK4D,qBAM/Cpb,EADW/C,KAAKqf,OAAOpU,OAAOwB,MAAM8N,EAAKxX,MACzB5G,OAAOoe,EAAK9O,OAC5BzL,KAAK0gB,eAAe3d,IAEtBgE,IAAIyb,EAAUxiB,KAAKkgB,IAEnB,GAAI3M,GAAYA,EAASnL,OACvBpI,KAAKkhB,WAAWtG,QACX,GAAI0H,EACTtiB,KAAK2gB,WAAW/F,EAAK0H,QAChB,GAAI/H,EAAKkI,WACdziB,KAAKkhB,WAAWtG,GAChBL,EAAKkI,WAAW7H,EAAK5a,KAAKqf,OAAOpU,QAAQ1K,SAAO,SAAC2H,GAAA,OAAQlI,EAAKghB,WAAW9Y,UACpE,CACLnB,IAAI2b,EAAanI,EAAKoI,eACG,iBAAdD,EAAwBA,EAAa9H,EAAIgI,cAAcF,GACpC,mBAAdA,IAA0BA,EAAaA,EAAW9H,IAC7D8H,IAAYA,EAAa9H,GAC9B5a,KAAK6iB,WAAWjI,EAAK8H,GAAY,GACjC1iB,KAAK8a,OAAO4H,EAAYZ,GAEtBA,IAAQ9hB,KAAK8hB,KAAKU,GAAUxiB,KAAKsf,QACjCvc,GAAM/C,KAAK4gB,kBAAkB7d,EAAMyf,I,aAOzC1H,gBAAO1T,EAAQ0a,EAAMpT,EAAYC,GAE/B,IADA5H,IAAIkC,EAAQyF,GAAc,EACjBkM,EAAMlM,EAAatH,EAAO0b,WAAWpU,GAActH,EAAOsB,WAC1DnB,EAAkB,MAAZoH,EAAmB,KAAOvH,EAAO0b,WAAWnU,GACtDiM,GAAOrT,EAAKqT,EAAMA,EAAI0G,cAAerY,EACxCjJ,KAAK+iB,YAAY3b,EAAQ6B,GACzBjJ,KAAKmgB,OAAOvF,GACRkH,GAAQjG,GAAUnf,eAAeke,EAAIuE,SAASC,gBAChDpf,KAAK8hB,KAAKA,GAEd9hB,KAAK+iB,YAAY3b,EAAQ6B,I,aAM3BoZ,mBAAUna,GAER,IADAnB,IAAIic,EAAOlB,EACF1U,EAAQpN,KAAKsf,KAAMlS,GAAS,EAAGA,IAAS,CAC/CrG,IAAIkc,EAAKjjB,KAAKwL,MAAM4B,GAChB1H,EAAQud,EAAGzM,aAAatO,GAC5B,GAAIxC,KAAWsd,GAASA,EAAMvgB,OAASiD,EAAMjD,UAC3CugB,EAAQtd,EACRoc,EAAOmB,GACFvd,EAAMjD,QAAQ,MAErB,GAAIwgB,EAAG1E,MAAO,MAEhB,IAAKyE,EAAO,OAAO,EACnBhjB,KAAK8hB,KAAKA,GACV,IAAK/a,IAAIlM,EAAI,EAAGA,EAAImoB,EAAMvgB,OAAQ5H,IAChCmF,KAAKkjB,WAAWF,EAAMnoB,GAAI,MAAM,GAClC,OAAO,G,aAKTmmB,oBAAW9Y,GACT,GAAIA,EAAKyI,UAAY3Q,KAAK4f,aAAe5f,KAAKkgB,IAAIzgB,KAAM,CACtDsH,IAAIoc,EAAQnjB,KAAKojB,uBACbD,GAAOnjB,KAAKkjB,WAAWC,GAE7B,GAAInjB,KAAKqiB,UAAUna,GAAO,CACxBlI,KAAKqjB,aACLtc,IAAImZ,EAAMlgB,KAAKkgB,IACfA,EAAIrB,aAAa3W,EAAKzI,MAClBygB,EAAIxN,QAAOwN,EAAIxN,MAAQwN,EAAIxN,MAAMS,UAAUjL,EAAKzI,OAEpD,IADAsH,IAAI0F,EAAQyT,EAAI1B,YACP3jB,EAAI,EAAGA,EAAIqN,EAAKuE,MAAMhK,OAAQ5H,IAChCqlB,EAAIzgB,OAAQygB,EAAIzgB,KAAKwZ,eAAe/Q,EAAKuE,MAAM5R,GAAG4E,QACrDgN,EAAQvE,EAAKuE,MAAM5R,GAAGmR,SAASS,IAEnC,OADAyT,EAAI1a,QAAQtD,KAAKgG,EAAKnF,KAAK0J,KACpB,EAET,OAAO,G,aAMT8V,eAAM9iB,EAAMgM,EAAO6X,GACjBvc,IAAImT,EAAKla,KAAKqiB,UAAU5iB,EAAKtD,OAAOsP,IAEpC,OADIyO,GAAIla,KAAKkjB,WAAWzjB,EAAMgM,GAAO,EAAM6X,GACpCpJ,G,aAITgJ,oBAAWzjB,EAAMgM,EAAO8S,EAAO+E,GAC7BtjB,KAAKqjB,aACLtc,IAAImZ,EAAMlgB,KAAKkgB,IACfA,EAAIrB,aAAapf,GACjBygB,EAAIxN,MAAQwN,EAAIxN,OAASwN,EAAIxN,MAAMS,UAAU1T,EAAMgM,GACnD1E,IAAIuS,EAAU4E,GAAaze,EAAM6jB,EAAYpD,EAAI5G,SA7UgB,EA8U5D4G,EAAI5G,SAAkD,GAAtB4G,EAAI1a,QAAQ/C,SAAa6W,GA9UG,GA+UjEtZ,KAAKwL,MAAMtJ,KAAK,IAAImc,GAAY5e,EAAMgM,EAAOyU,EAAI1B,YAAa0B,EAAI5B,aAAcC,EAAO,KAAMjF,IAC7FtZ,KAAKsf,Q,aAKP+D,oBAAWrW,GACTjG,IAAIlM,EAAImF,KAAKwL,MAAM/I,OAAS,EAC5B,GAAI5H,EAAImF,KAAKsf,KAAM,CACjB,KAAOzkB,EAAImF,KAAKsf,KAAMzkB,IAAKmF,KAAKwL,MAAM3Q,EAAI,GAAG2K,QAAQtD,KAAKlC,KAAKwL,MAAM3Q,GAAG2J,OAAOwI,IAC/EhN,KAAKwL,MAAM/I,OAASzC,KAAKsf,KAAO,I,aAIpC9a,kBAGE,OAFAxE,KAAKsf,KAAO,EACZtf,KAAKqjB,WAAWrjB,KAAKuf,QACdvf,KAAKwL,MAAM,GAAGhH,OAAOxE,KAAKuf,QAAUvf,KAAKsZ,QAAQiK,U,aAG1DzB,cAAK5a,GACH,IAAKH,IAAIlM,EAAImF,KAAKsf,KAAMzkB,GAAK,EAAGA,IAAK,GAAImF,KAAKwL,MAAM3Q,IAAMqM,EAExD,YADAlH,KAAKsf,KAAOzkB,IAKhBwO,GAAIma,WAAA9nB,IAAA,WACFsE,KAAKqjB,aAEL,IADAtc,IAAIM,EAAM,EACDxM,EAAImF,KAAKsf,KAAMzkB,GAAK,EAAGA,IAAK,CAEnC,IADAkM,IAAIvB,EAAUxF,KAAKwL,MAAM3Q,GAAG2K,QACnBsE,EAAItE,EAAQ/C,OAAS,EAAGqH,GAAK,EAAGA,IACvCzC,GAAO7B,EAAQsE,GAAG9C,SAChBnM,GAAGwM,IAET,OAAOA,G,aAGT0b,qBAAY3b,EAAQuE,GAClB,GAAI3L,KAAKyF,KAAM,IAAKsB,IAAIlM,EAAI,EAAGA,EAAImF,KAAKyF,KAAKhD,OAAQ5H,IAC/CmF,KAAKyF,KAAK5K,GAAGqN,MAAQd,GAAUpH,KAAKyF,KAAK5K,GAAG8Q,QAAUA,IACxD3L,KAAKyF,KAAK5K,GAAGwM,IAAMrH,KAAKwjB,a,aAI9BtC,oBAAW9Z,GACT,GAAIpH,KAAKyF,KAAM,IAAKsB,IAAIlM,EAAI,EAAGA,EAAImF,KAAKyF,KAAKhD,OAAQ5H,IAC3B,MAApBmF,KAAKyF,KAAK5K,GAAGwM,KAAkC,GAAnBD,EAAOmM,UAAiBnM,EAAOqc,SAASzjB,KAAKyF,KAAK5K,GAAGqN,QACnFlI,KAAKyF,KAAK5K,GAAGwM,IAAMrH,KAAKwjB,a,aAI9BX,oBAAWzb,EAAQ5B,EAAS4K,GAC1B,GAAIhJ,GAAU5B,GAAWxF,KAAKyF,KAAM,IAAKsB,IAAIlM,EAAI,EAAGA,EAAImF,KAAKyF,KAAKhD,OAAQ5H,IAAK,CAC7E,GAAwB,MAApBmF,KAAKyF,KAAK5K,GAAGwM,KAAkC,GAAnBD,EAAOmM,UAAiBnM,EAAOqc,SAASzjB,KAAKyF,KAAK5K,GAAGqN,MACzE1C,EAAQke,wBAAwB1jB,KAAKyF,KAAK5K,GAAGqN,OAC5CkI,EAAS,EAAI,KACtBpQ,KAAKyF,KAAK5K,GAAGwM,IAAMrH,KAAKwjB,c,aAKhCvC,oBAAW0C,GACT,GAAI3jB,KAAKyF,KAAM,IAAKsB,IAAIlM,EAAI,EAAGA,EAAImF,KAAKyF,KAAKhD,OAAQ5H,IAC/CmF,KAAKyF,KAAK5K,GAAGqN,MAAQyb,IACvB3jB,KAAKyF,KAAK5K,GAAGwM,IAAMrH,KAAKwjB,YAAcG,EAAS9C,UAAUpe,OAASzC,KAAKyF,KAAK5K,GAAG8Q,U,aAOrFyP,wBAAe7c,G,WACb,GAAIA,EAAQsW,QAAQ,MAAQ,EAC1B,OAAOtW,EAAQ2Y,MAAM,YAAYyD,KAAK3a,KAAKob,eAAgBpb,MAE7D+G,IAAI6c,EAAQrlB,EAAQ2Y,MAAM,KACtB2M,EAAS7jB,KAAKsZ,QAAQ/a,QACtBulB,IAAW9jB,KAAKuf,QAAYsE,GAAUA,EAAOzc,OAAO3H,MAAQO,KAAKwL,MAAM,GAAG/L,MAC1EskB,IAAaF,EAASA,EAAOzW,MAAQ,EAAI,IAAM0W,EAAU,EAAI,GAoBjE,OAnBY,SAARpR,EAAS7X,EAAGuS,GACd,KAAOvS,GAAK,EAAGA,IAAK,CAClBkM,IAAIid,EAAOJ,EAAM/oB,GACjB,GAAY,IAARmpB,EAAY,CACd,GAAInpB,GAAK+oB,EAAMnhB,OAAS,GAAU,GAAL5H,EAAQ,SACrC,KAAOuS,GAAS2W,EAAU3W,IACxB,GAAIsF,EAAM7X,EAAI,EAAGuS,GAAQ,OAAO,EAClC,OAAO,EAEPrG,IAAIvF,EAAO4L,EAAQ,GAAe,GAATA,GAAc0W,EAAW9jB,EAAKwL,MAAM4B,GAAO3N,KAC9DokB,GAAUzW,GAAS2W,EAAWF,EAAO3b,KAAKkF,EAAQ2W,GAAUtkB,KAC5D,KACN,IAAK+B,GAASA,EAAKpG,MAAQ4oB,IAAsC,GAA9BxiB,EAAKgW,OAAO3C,QAAQmP,GACrD,OAAO,EACT5W,IAGJ,OAAO,EAEFsF,CAAMkR,EAAMnhB,OAAS,EAAGzC,KAAKsf,O,aAGtC8D,gCACErc,IAAIkd,EAAWjkB,KAAKsZ,QAAQ/a,QAC5B,GAAI0lB,EAAU,IAAKld,IAAI5L,EAAI8oB,EAAS7W,MAAOjS,GAAK,EAAGA,IAAK,CACtD4L,IAAImd,EAAQD,EAAS/b,KAAK/M,GAAGsX,eAAewR,EAAS9T,WAAWhV,IAAI2a,YACpE,GAAIoO,GAASA,EAAM7R,aAAe6R,EAAMnS,aAAc,OAAOmS,EAE/D,IAAKnd,IAAI3L,KAAQ4E,KAAKqf,OAAOpU,OAAOO,MAAO,CACzCzE,IAAItH,EAAOO,KAAKqf,OAAOpU,OAAOO,MAAMpQ,GACpC,GAAIqE,EAAK4S,aAAe5S,EAAKsS,aAAc,OAAOtS,I,aAItDihB,wBAAe3d,GACbgE,IAAIrB,EA8ER,SAA2B3C,EAAMkJ,GAC/B,IAAKlF,IAAIlM,EAAI,EAAGA,EAAIoR,EAAIxJ,OAAQ5H,IAC9B,GAAIkI,EAAKqG,GAAG6C,EAAIpR,IAAK,OAAOoR,EAAIpR,GAhFpBspB,CAAkBphB,EAAM/C,KAAKkgB,IAAI5B,cACzC5Y,GAAO1F,KAAKkgB,IAAIzB,WAAWvc,KAAKwD,GACpC1F,KAAKkgB,IAAI5B,aAAevb,EAAKiJ,SAAShM,KAAKkgB,IAAI5B,e,aAGjDsC,2BAAkB7d,EAAMqhB,GACtB,IAAKrd,IAAIqG,EAAQpN,KAAKsf,KAAMlS,GAAS,EAAGA,IAAS,CAC/CrG,IAAIsd,EAAQrkB,KAAKwL,MAAM4B,GAEvB,GADYiX,EAAM/F,aAAagG,YAAYvhB,IAC9B,EACXshB,EAAM/F,aAAevb,EAAKsJ,cAAcgY,EAAM/F,kBACzC,CACL+F,EAAM7F,YAAczb,EAAKsJ,cAAcgY,EAAM7F,aAC7CzX,IAAIwd,EAAYF,EAAMzF,iBAAiB7b,GACnCwhB,GAAaF,EAAM5kB,MAAQ4kB,EAAM5kB,KAAKwZ,eAAesL,EAAU9kB,QACjE4kB,EAAM7F,YAAc+F,EAAUvY,SAASqY,EAAM7F,cAEjD,GAAI6F,GAASD,EAAM,Q,6CCpuBZI,GASX,SAAYhZ,EAAOiB,GAGjBzM,KAAKwL,MAAQA,GAAS,GAGtBxL,KAAKyM,MAAQA,GAAS,IAmJ1B,SAASgY,GAAY9mB,GACnBoJ,IAAIhG,EAAS,GACb,IAAKgG,IAAI3L,KAAQuC,EAAK,CACpBoJ,IAAI2d,EAAQ/mB,EAAIvC,GAAMwU,KAAK8U,MACvBA,IAAO3jB,EAAO3F,GAAQspB,GAE5B,OAAO3jB,EAGT,SAASmP,GAAIoJ,GAEX,OAAOA,EAAQqL,UAAYC,OAAOD,S,aAtJlCE,2BAAkB5V,EAAUqK,EAAc7K,G,0BAAJ,IAC/BA,IAAQA,EAASyB,GAAIoJ,GAASwL,0BAEnC/d,IAAImZ,EAAMzR,EAAQkI,EAAS,KA4B3B,OA3BA1H,EAAS1O,SAAO,SAAC2H,GACf,GAAIyO,GAAUzO,EAAKuE,MAAMhK,OAAQ,CAC1BkU,IAAQA,EAAS,IAEtB,IADA5P,IAAIge,EAAO,EAAGC,EAAW,EAClBD,EAAOpO,EAAOlU,QAAUuiB,EAAW9c,EAAKuE,MAAMhK,QAAQ,CAC3DsE,IAAIvF,EAAO0G,EAAKuE,MAAMuY,GACtB,GAAKhlB,EAAKyM,MAAMjL,EAAK/B,KAAKrE,MAA1B,CACA,IAAKoG,EAAK4H,GAAGuN,EAAOoO,MAAsC,IAA5BvjB,EAAK/B,KAAKmQ,KAAKqV,SAAoB,MACjEF,GAAQ,EAAGC,SAFwBA,IAIrC,KAAOD,EAAOpO,EAAOlU,QACnByd,EAAMvJ,EAAOnT,MACbmT,EAAOnT,MAET,KAAOwhB,EAAW9c,EAAKuE,MAAMhK,QAAQ,CACnCsE,IAAIme,EAAMhd,EAAKuE,MAAMuY,KACjBG,EAAUnlB,EAAKolB,cAAcF,EAAKhd,EAAKyI,SAAU2I,GACjD6L,IACFxO,EAAOzU,KAAKgjB,EAAKhF,GACjBA,EAAIqB,YAAY4D,EAAQvK,KACxBsF,EAAMiF,EAAQzC,YAAcyC,EAAQvK,MAI1CsF,EAAIqB,YAAYvhB,EAAKqlB,mBAAmBnd,EAAMoR,OAGzC7K,G,aAGT4W,4BAAmBnd,EAAMoR,Q,UAAU,IACnC,IAAF,EACQkL,GAAcc,WAAWpV,GAAIoJ,GAAUtZ,KAAKwL,MAAMtD,EAAKzI,KAAKrE,MAAM8M,IADjE0S,EAAA,EAAAA,IAAK8H,EAAA,EAAAA,WAEV,GAAIA,EAAY,CACd,GAAIxa,EAAKE,OACP,MAAM,IAAImB,WAAW,gDACnB+P,EAAQiM,UACVjM,EAAQiM,UAAUrd,EAAMwa,EAAYpJ,GAEpCtZ,KAAK6kB,kBAAkB3c,EAAK1C,QAAS8T,EAASoJ,GAElD,OAAO9H,G,aAST4K,uBAActd,EAAMoR,Q,UAAU,IAE5B,IADAvS,IAAI6T,EAAM5a,KAAKqlB,mBAAmBnd,EAAMoR,GAC/Bze,EAAIqN,EAAKuE,MAAMhK,OAAS,EAAG5H,GAAK,EAAGA,IAAK,CAC/CkM,IAAIhJ,EAAOiC,KAAKolB,cAAcld,EAAKuE,MAAM5R,GAAIqN,EAAKyI,SAAU2I,GACxDvb,KACAA,EAAK2kB,YAAc3kB,EAAK6c,KAAK2G,YAAY3G,GAC3CA,EAAM7c,EAAK6c,KAGf,OAAOA,G,aAGTwK,uBAAcriB,EAAMiU,EAAQsC,Q,UAAU,IACpCvS,IAAI2d,EAAQ1kB,KAAKyM,MAAM1J,EAAKtD,KAAKrE,MACjC,OAAOspB,GAASF,GAAcc,WAAWpV,GAAIoJ,GAAUoL,EAAM3hB,EAAMiU,KAOrEwN,GAAOc,WAAA,SAAWpV,EAAKuV,EAAWC,GAChC,Q,UADwC,MAChB,iBAAbD,EACT,MAAO,CAAC7K,IAAK1K,EAAIkS,eAAeqD,IAClC,GAA0B,MAAtBA,EAAUlS,SACZ,MAAO,CAACqH,IAAK6K,GACf,GAAIA,EAAU7K,KAAiC,MAA1B6K,EAAU7K,IAAIrH,SACjC,OAAOkS,EACT1e,IAAI4e,EAAUF,EAAU,GAAIG,EAAQD,EAAQ9Q,QAAQ,KAChD+Q,EAAQ,IACVF,EAAQC,EAAQ/hB,MAAM,EAAGgiB,GACzBD,EAAUA,EAAQ/hB,MAAMgiB,EAAQ,IAElC7e,IAAI2b,EAAa,KAAM9H,EAAM8K,EAAQxV,EAAI2V,gBAAgBH,EAAOC,GAAWzV,EAAI4V,cAAcH,GACzFla,EAAQga,EAAU,GAAIje,EAAQ,EAClC,GAAIiE,GAAyB,iBAATA,GAAuC,MAAlBA,EAAM8H,WAAqBrI,MAAMC,QAAQM,GAEhF,IAAK1E,IAAI3L,KADToM,EAAQ,EACSiE,EAAO,GAAmB,MAAfA,EAAMrQ,GAAe,CAC/C2L,IAAI6e,EAAQxqB,EAAKyZ,QAAQ,KACrB+Q,EAAQ,EAAGhL,EAAImL,eAAe3qB,EAAKwI,MAAM,EAAGgiB,GAAQxqB,EAAKwI,MAAMgiB,EAAQ,GAAIna,EAAMrQ,IAChFwf,EAAIoL,aAAa5qB,EAAMqQ,EAAMrQ,IAGtC,IAAK2L,IAAIlM,EAAI2M,EAAO3M,EAAI4qB,EAAUhjB,OAAQ5H,IAAK,CAC7CkM,IAAIO,EAAQme,EAAU5qB,GACtB,GAAc,IAAVyM,EAAa,CACf,GAAIzM,EAAI4qB,EAAUhjB,OAAS,GAAK5H,EAAI2M,EAClC,MAAM,IAAI+B,WAAW,0DACvB,MAAO,CAAAqR,IAACA,EAAK8H,WAAY9H,GAE3B,IAAN,EAAqD4J,GAAcc,WAAWpV,EAAK5I,EAAOoe,GAAxE3b,EAAA,MAAmBkc,EAAA,aAE7B,GADArL,EAAI2G,YAAYxX,GACZkc,EAAc,CAChB,GAAIvD,EAAY,MAAM,IAAInZ,WAAW,0BACrCmZ,EAAauD,GAInB,MAAO,CAAArL,IAACA,EAAG8H,WAAEA,IAMf8B,GAAO7I,WAAA,SAAW1Q,GAChB,OAAOA,EAAOqG,OAAO4U,gBAClBjb,EAAOqG,OAAO4U,cAAgB,IAAI1B,GAAcxkB,KAAKmmB,gBAAgBlb,GAASjL,KAAKomB,gBAAgBnb,MAMxGuZ,GAAO2B,gBAAA,SAAgBlb,GACrBlE,IAAIhG,EAAS0jB,GAAYxZ,EAAOO,OAEhC,OADKzK,EAAOiH,OAAMjH,EAAOiH,KAAI,SAAGE,GAAA,OAAQA,EAAKF,OACtCjH,GAKTyjB,GAAO4B,gBAAA,SAAgBnb,GACrB,OAAOwZ,GAAYxZ,EAAOwB,QCtJ9Bf,IACM2a,GAAW5e,KAAK6e,IAAI,EAAG,IAG7B,SAASC,GAAazqB,GAAS,OAJf,MAIsBA,E,IAKzB0qB,GACX,SAAYnf,EAAKof,EAAiBC,Q,WAAP,Q,UAAiB,MAE1C1mB,KAAKqH,IAAMA,EAGXrH,KAAKymB,QAAUA,EACfzmB,KAAK0mB,QAAUA,GASNC,GAKX,WAAYC,EAAQC,GAClB,Q,WAD6B,IACxBD,EAAOnkB,QAAUkkB,EAAQ5d,MAAO,OAAO4d,EAAQ5d,MACpD/I,KAAK4mB,OAASA,EACd5mB,KAAK6mB,SAAWA,G,aAGlBH,iBAAQ5qB,GACNiL,IAAI+f,EAAO,EAAG7d,EAAQsd,GAAazqB,GACnC,IAAKkE,KAAK6mB,SAAU,IAAK9f,IAAIlM,EAAI,EAAGA,EAAIoO,EAAOpO,IAC7CisB,GAAQ9mB,KAAK4mB,OAAW,EAAJ/rB,EAAQ,GAAKmF,KAAK4mB,OAAW,EAAJ/rB,EAAQ,GACvD,OAAOmF,KAAK4mB,OAAe,EAAR3d,GAAa6d,EAnCpC,SAAuBhrB,GAAS,OAAQA,GALxB,MAKiCA,IAAoBuqB,GAmC1BU,CAAcjrB,I,aAIvDkrB,mBAAU3f,EAAK4f,GAAa,Y,UAAL,GAAYjnB,KAAKknB,KAAK7f,EAAK4f,GAAO,I,aAGzD1gB,aAAIc,EAAK4f,GAAa,Y,UAAL,GAAYjnB,KAAKknB,KAAK7f,EAAK4f,GAAO,I,aAEnDC,cAAK7f,EAAK4f,EAAOE,GAEf,IADApgB,IAAI+f,EAAO,EAAGM,EAAWpnB,KAAK6mB,SAAW,EAAI,EAAGQ,EAAWrnB,KAAK6mB,SAAW,EAAI,EACtEhsB,EAAI,EAAGA,EAAImF,KAAK4mB,OAAOnkB,OAAQ5H,GAAK,EAAG,CAC9CkM,IAAIS,EAAQxH,KAAK4mB,OAAO/rB,IAAMmF,KAAK6mB,SAAWC,EAAO,GACrD,GAAItf,EAAQH,EAAK,MACjBN,IAAIugB,EAAUtnB,KAAK4mB,OAAO/rB,EAAIusB,GAAWG,EAAUvnB,KAAK4mB,OAAO/rB,EAAIwsB,GAAW9f,EAAMC,EAAQ8f,EAC5F,GAAIjgB,GAAOE,EAAK,CACdR,IACIhG,EAASyG,EAAQsf,IADTQ,EAAkBjgB,GAAOG,GAAS,EAAIH,GAAOE,EAAM,EAAI0f,EAA7CA,GACc,EAAI,EAAIM,GAC5C,GAAIJ,EAAQ,OAAOpmB,EACnBgG,IAAI2f,EAAUrf,IAAQ4f,EAAQ,EAAIzf,EAAQD,GAAO,KAAmB1M,EAAI,GAAGwM,EAAMG,GAxD3B6e,GAyDtD,OAAO,IAAIG,GAAUzlB,EAAQkmB,EAAQ,EAAI5f,GAAOG,EAAQH,GAAOE,EAAKmf,GAEtEI,GAAQS,EAAUD,EAEpB,OAAOH,EAAS9f,EAAMyf,EAAO,IAAIN,GAAUnf,EAAMyf,I,aAGnDU,iBAAQngB,EAAKqf,GAGX,IAFA3f,IAAI+f,EAAO,EAAG7d,EAAQsd,GAAaG,GAC/BU,EAAWpnB,KAAK6mB,SAAW,EAAI,EAAGQ,EAAWrnB,KAAK6mB,SAAW,EAAI,EAC5DhsB,EAAI,EAAGA,EAAImF,KAAK4mB,OAAOnkB,OAAQ5H,GAAK,EAAG,CAC9CkM,IAAIS,EAAQxH,KAAK4mB,OAAO/rB,IAAMmF,KAAK6mB,SAAWC,EAAO,GACrD,GAAItf,EAAQH,EAAK,MACjBN,IAAIugB,EAAUtnB,KAAK4mB,OAAO/rB,EAAIusB,GAC9B,GAAI/f,GAD2CG,EAAQ8f,GACrCzsB,GAAa,EAARoO,EAAW,OAAO,EACzC6d,GAAQ9mB,KAAK4mB,OAAO/rB,EAAIwsB,GAAYC,EAEtC,OAAO,G,aAMT/mB,iBAAQ8F,GAEN,IADAU,IAAIqgB,EAAWpnB,KAAK6mB,SAAW,EAAI,EAAGQ,EAAWrnB,KAAK6mB,SAAW,EAAI,EAC5DhsB,EAAI,EAAGisB,EAAO,EAAGjsB,EAAImF,KAAK4mB,OAAOnkB,OAAQ5H,GAAK,EAAG,CACxDkM,IAAIS,EAAQxH,KAAK4mB,OAAO/rB,GAAI4sB,EAAWjgB,GAASxH,KAAK6mB,SAAWC,EAAO,GAAIY,EAAWlgB,GAASxH,KAAK6mB,SAAW,EAAIC,GAC/GQ,EAAUtnB,KAAK4mB,OAAO/rB,EAAIusB,GAAWG,EAAUvnB,KAAK4mB,OAAO/rB,EAAIwsB,GACnEhhB,EAAEohB,EAAUA,EAAWH,EAASI,EAAUA,EAAWH,GACrDT,GAAQS,EAAUD,I,aAOtBK,kBACE,OAAO,IAAIhB,GAAQ3mB,KAAK4mB,QAAS5mB,KAAK6mB,W,aAGxCjc,oBACE,OAAQ5K,KAAK6mB,SAAW,IAAM,IAAMnT,KAAKC,UAAU3T,KAAK4mB,SAO1DD,GAAOhb,OAAA,SAAOrP,GACZ,OAAY,GAALA,EAASqqB,GAAQ5d,MAAQ,IAAI4d,GAAQrqB,EAAI,EAAI,CAAC,GAAIA,EAAG,GAAK,CAAC,EAAG,EAAGA,KAI5EqqB,GAAQ5d,MAAQ,IAAI4d,GAAQ,I,IASfiB,GAGX,SAAYC,EAAMC,EAAQthB,EAAMU,GAG9BlH,KAAK6nB,KAAOA,GAAQ,GAIpB7nB,KAAKwG,KAAOA,GAAQ,EAGpBxG,KAAKkH,GAAW,MAANA,EAAalH,KAAK6nB,KAAKplB,OAASyE,EAC1ClH,KAAK8nB,OAASA,GClKX,SAASC,GAAehc,GAC7BhF,IAAIjJ,EAAMe,MAAM7D,KAAKgF,KAAM+L,GAE3B,OADAjO,EAAImF,UAAY8kB,GAAetrB,UACxBqB,E,aDoKP8F,eAAM4C,EAAUU,GACd,Y,UADW,Q,UAAQlH,KAAK6nB,KAAKplB,QACtB,IAAImlB,GAAQ5nB,KAAK6nB,KAAM7nB,KAAK8nB,OAAQthB,EAAMU,I,aAGnDiC,gBACE,OAAO,IAAIye,GAAQ5nB,KAAK6nB,KAAKjkB,QAAS5D,KAAK8nB,QAAU9nB,KAAK8nB,OAAOlkB,QAAS5D,KAAKwG,KAAMxG,KAAKkH,K,aAO5F8gB,mBAAUzhB,EAAK0hB,GACbjoB,KAAKkH,GAAKlH,KAAK6nB,KAAK3lB,KAAKqE,GACV,MAAX0hB,GAAiBjoB,KAAKkoB,UAAUloB,KAAK6nB,KAAKplB,OAAS,EAAGwlB,I,aAM5DE,uBAAcC,GACZ,IAAKrhB,IAAIlM,EAAI,EAAGwtB,EAAYroB,KAAK6nB,KAAKplB,OAAQ5H,EAAIutB,EAAQP,KAAKplB,OAAQ5H,IAAK,CAC1EkM,IAAIuhB,EAAOF,EAAQG,UAAU1tB,GAC7BmF,KAAKgoB,UAAUI,EAAQP,KAAKhtB,GAAY,MAARytB,GAAgBA,EAAOztB,EAAIwtB,EAAYC,EAAO,Q,aAQlFC,mBAAUjsB,GACR,GAAI0D,KAAK8nB,OAAQ,IAAK/gB,IAAIlM,EAAI,EAAGA,EAAImF,KAAK8nB,OAAOrlB,OAAQ5H,IACvD,GAAImF,KAAK8nB,OAAOjtB,IAAMyB,EAAG,OAAO0D,KAAK8nB,OAAOjtB,GAAKA,EAAI,GAAK,EAAI,K,aAGlEqtB,mBAAU5rB,EAAGrB,GACN+E,KAAK8nB,SAAQ9nB,KAAK8nB,OAAS,IAChC9nB,KAAK8nB,OAAO5lB,KAAK5F,EAAGrB,I,aAKtButB,+BAAsBJ,GACpB,IAAKrhB,IAAIlM,EAAIutB,EAAQP,KAAKplB,OAAS,EAAGgmB,EAAYzoB,KAAK6nB,KAAKplB,OAAS2lB,EAAQP,KAAKplB,OAAQ5H,GAAK,EAAGA,IAAK,CACrGkM,IAAIuhB,EAAOF,EAAQG,UAAU1tB,GAC7BmF,KAAKgoB,UAAUI,EAAQP,KAAKhtB,GAAG8sB,SAAkB,MAARW,GAAgBA,EAAOztB,EAAI4tB,EAAYH,EAAO,EAAI,Q,aAM/FX,kBACE5gB,IAAI2hB,EAAU,IAAId,GAElB,OADAc,EAAQF,sBAAsBxoB,MACvB0oB,G,aAKTniB,aAAIc,EAAK4f,GACP,Q,UADe,GACXjnB,KAAK8nB,OAAQ,OAAO9nB,KAAKknB,KAAK7f,EAAK4f,GAAO,GAC9C,IAAKlgB,IAAIlM,EAAImF,KAAKwG,KAAM3L,EAAImF,KAAKkH,GAAIrM,IACnCwM,EAAMrH,KAAK6nB,KAAKhtB,GAAG0L,IAAIc,EAAK4f,GAC9B,OAAO5f,G,aAMT2f,mBAAU3f,EAAK4f,GAAa,Y,UAAL,GAAYjnB,KAAKknB,KAAK7f,EAAK4f,GAAO,I,aAEzDC,cAAK7f,EAAK4f,EAAOE,GAGf,IAFApgB,IAAI0f,GAAU,EAEL5rB,EAAImF,KAAKwG,KAAM3L,EAAImF,KAAKkH,GAAIrM,IAAK,CACxCkM,IAAwBhG,EAAdf,KAAK6nB,KAAKhtB,GAAiBmsB,UAAU3f,EAAK4f,GACpD,GAAsB,MAAlBlmB,EAAO2lB,QAAiB,CAC1B3f,IAAI4hB,EAAO3oB,KAAKuoB,UAAU1tB,GAC1B,GAAY,MAAR8tB,GAAgBA,EAAO9tB,GAAK8tB,EAAO3oB,KAAKkH,GAAI,CAC9CrM,EAAI8tB,EACJthB,EAAMrH,KAAK6nB,KAAKc,GAAMjC,QAAQ3lB,EAAO2lB,SACrC,UAIA3lB,EAAO0lB,UAASA,GAAU,GAC9Bpf,EAAMtG,EAAOsG,IAGf,OAAO8f,EAAS9f,EAAM,IAAImf,GAAUnf,EAAKof,IC3P7CsB,GAAetrB,UAAYlB,OAAOY,OAAO0C,MAAMpC,WAC/CsrB,GAAetrB,UAAUqG,YAAcilB,GACvCA,GAAetrB,UAAUrB,KAAO,iB,IAOnBwtB,GAGX,SAAY1Y,GAIVlQ,KAAKkQ,IAAMA,EAGXlQ,KAAK6oB,MAAQ,GAGb7oB,KAAK8oB,KAAO,GAGZ9oB,KAAKooB,QAAU,IAAIR,I,2DC7BvB,SAASmB,KAAiB,MAAM,IAAIlqB,MAAM,eDiCxCwK,GAAI+G,OAAA1U,IAAA,WAAW,OAAOsE,KAAK8oB,KAAKrmB,OAASzC,KAAK8oB,KAAK,GAAK9oB,KAAKkQ,K,aAK7D8Y,cAAKzsB,GACHwK,IAAIhG,EAASf,KAAKipB,UAAU1sB,GAC5B,GAAIwE,EAAOmoB,OAAQ,MAAM,IAAInB,GAAehnB,EAAOmoB,QACnD,OAAOlpB,M,aAMTipB,mBAAUD,GACRjiB,IAAIhG,EAASioB,EAAK1jB,MAAMtF,KAAKkQ,KAE7B,OADKnP,EAAOmoB,QAAQlpB,KAAKmpB,QAAQH,EAAMjoB,EAAOmP,KACvCnP,GAMTsI,GAAI+f,WAAA1tB,IAAA,WACF,OAAOsE,KAAK6oB,MAAMpmB,OAAS,G,aAG7B0mB,iBAAQH,EAAM9Y,GACZlQ,KAAK8oB,KAAK5mB,KAAKlC,KAAKkQ,KACpBlQ,KAAK6oB,MAAM3mB,KAAK8mB,GAChBhpB,KAAKooB,QAAQJ,UAAUgB,EAAKK,UAC5BrpB,KAAKkQ,IAAMA,G,yCC9DfxE,IAAM4d,GAAY/tB,OAAOY,OAAO,MAWnBotB,GAAI,a,aAMfjkB,eAAMkkB,GAAQ,OAAOT,M,aAMrBM,kBAAW,OAAO1C,GAAQ5d,O,aAK1B4e,gBAAO6B,GAAQ,OAAOT,M,aAMtBxiB,aAAIkjB,GAAY,OAAOV,M,aAMvBW,eAAMC,GAAU,OAAO,M,aAOvB5e,kBAAW,OAAOge,MAKlBQ,GAAOve,SAAA,SAASC,EAAQuB,GACtB,IAAKA,IAASA,EAAKod,SAAU,MAAM,IAAIrgB,WAAW,mCAClDxC,IAAItH,EAAO6pB,GAAU9c,EAAKod,UAC1B,IAAKnqB,EAAM,MAAM,IAAI8J,WAAU,gBAAiBiD,EAAKod,SAAQ,YAC7D,OAAOnqB,EAAKuL,SAASC,EAAQuB,IAQ/B+c,GAAOM,OAAA,SAAOC,EAAIC,GAChB,GAAID,KAAMR,GAAW,MAAM,IAAI/f,WAAW,iCAAmCugB,GAG7E,OAFAR,GAAUQ,GAAMC,EAChBA,EAAUttB,UAAUotB,OAASC,EACtBC,G,IAMEC,GAEX,SAAY9Z,EAAKgZ,GAEflpB,KAAKkQ,IAAMA,EAEXlQ,KAAKkpB,OAASA,GAKhBc,GAAO9P,GAAA,SAAGhK,GAAO,OAAO,IAAI8Z,GAAW9Z,EAAK,OAI5C8Z,GAAOC,KAAA,SAAKle,GAAW,OAAO,IAAIie,GAAW,KAAMje,IAMnDie,GAAOE,YAAA,SAAYha,EAAK1J,EAAMU,EAAItD,GAChC,IACE,OAAOomB,GAAW9P,GAAGhK,EAAIjD,QAAQzG,EAAMU,EAAItD,IAC3C,MAAOumB,GACP,GAAIA,aAAare,EAAc,OAAOke,GAAWC,KAAKE,EAAEpe,SACxD,MAAMoe,I,ICpGCC,GAAW,YAStB,WAAY5jB,EAAMU,EAAItD,EAAO6hB,GAC3BhS,OAAK,MAGLzT,KAAKwG,KAAOA,EAGZxG,KAAKkH,GAAKA,EAGVlH,KAAK4D,MAAQA,EACb5D,KAAKylB,YAAcA,E,8FAGrB2E,EAAFA,UAAE9kB,MAAA,SAAM4K,GACJ,OAAIlQ,KAAKylB,WAAa4E,GAAena,EAAKlQ,KAAKwG,KAAMxG,KAAKkH,IACjD8iB,GAAWC,KAAK,6CAClBD,GAAWE,YAAYha,EAAKlQ,KAAKwG,KAAMxG,KAAKkH,GAAIlH,KAAK4D,QAG9DwmB,EAAFA,UAAEf,OAAA,WACE,OAAO,IAAI1C,GAAQ,CAAC3mB,KAAKwG,KAAMxG,KAAKkH,GAAKlH,KAAKwG,KAAMxG,KAAK4D,MAAM6C,QAGjE2jB,EAAFA,UAAEzC,OAAA,SAAOzX,GACL,OAAO,IAAIka,EAAYpqB,KAAKwG,KAAMxG,KAAKwG,KAAOxG,KAAK4D,MAAM6C,KAAMyJ,EAAItM,MAAM5D,KAAKwG,KAAMxG,KAAKkH,MAG3FkjB,EAAFA,UAAE7jB,IAAA,SAAI6hB,GACFrhB,IAAIP,EAAO4hB,EAAQpB,UAAUhnB,KAAKwG,KAAM,GAAIU,EAAKkhB,EAAQpB,UAAUhnB,KAAKkH,IAAK,GAC7E,OAAIV,EAAKigB,SAAWvf,EAAGuf,QAAgB,KAChC,IAAI2D,EAAY5jB,EAAKa,IAAKI,KAAKC,IAAIlB,EAAKa,IAAKH,EAAGG,KAAMrH,KAAK4D,QAGpEwmB,EAAFA,UAAEV,MAAA,SAAMphB,GACJ,KAAMA,aAAiB8hB,IAAgB9hB,EAAMmd,WAAazlB,KAAKylB,UAAW,OAAO,KAEjF,GAAIzlB,KAAKwG,KAAOxG,KAAK4D,MAAM6C,MAAQ6B,EAAM9B,MAASxG,KAAK4D,MAAMoJ,SAAY1E,EAAM1E,MAAMmJ,UAI9E,IAAIzE,EAAMpB,IAAMlH,KAAKwG,MAASxG,KAAK4D,MAAMmJ,WAAczE,EAAM1E,MAAMoJ,QAKxE,OAAO,KAJPjG,IAAInD,EAAQ5D,KAAK4D,MAAM6C,KAAO6B,EAAM1E,MAAM6C,MAAQ,EAAIqG,EAAM/D,MACtD,IAAI+D,EAAMxE,EAAM1E,MAAM4B,QAAQmB,OAAO3G,KAAK4D,MAAM4B,SAAU8C,EAAM1E,MAAMmJ,UAAW/M,KAAK4D,MAAMoJ,SAClG,OAAO,IAAIod,EAAY9hB,EAAM9B,KAAMxG,KAAKkH,GAAItD,EAAO5D,KAAKylB,WANxD1e,IAAInD,EAAQ5D,KAAK4D,MAAM6C,KAAO6B,EAAM1E,MAAM6C,MAAQ,EAAIqG,EAAM/D,MACtD,IAAI+D,EAAM9M,KAAK4D,MAAM4B,QAAQmB,OAAO2B,EAAM1E,MAAM4B,SAAUxF,KAAK4D,MAAMmJ,UAAWzE,EAAM1E,MAAMoJ,SAClG,OAAO,IAAIod,EAAYpqB,KAAKwG,KAAMxG,KAAKkH,IAAMoB,EAAMpB,GAAKoB,EAAM9B,MAAO5C,EAAO5D,KAAKylB,YAUrF2E,EAAFA,UAAErf,OAAA,WACEhE,IAAIyF,EAAO,CAACod,SAAU,UAAWpjB,KAAMxG,KAAKwG,KAAMU,GAAIlH,KAAKkH,IAG3D,OAFIlH,KAAK4D,MAAM6C,OAAM+F,EAAK5I,MAAQ5D,KAAK4D,MAAMmH,UACzC/K,KAAKylB,YAAWjZ,EAAKiZ,WAAY,GAC9BjZ,GAGT4d,EAAOpf,SAAA,SAASC,EAAQuB,GACtB,GAAwB,iBAAbA,EAAKhG,MAAsC,iBAAXgG,EAAKtF,GAC9C,MAAM,IAAIqC,WAAW,0CACvB,OAAO,IAAI6gB,EAAY5d,EAAKhG,KAAMgG,EAAKtF,GAAI4F,EAAM9B,SAASC,EAAQuB,EAAK5I,SAAU4I,EAAKiZ,Y,EArElE,CAAS8D,IAyEjCA,GAAKM,OAAO,UAAWO,I,IAKVE,GAAiB,YAM5B,WAAY9jB,EAAMU,EAAIqjB,EAASC,EAAO5mB,EAAOwL,EAAQqW,GACnDhS,OAAK,MAGLzT,KAAKwG,KAAOA,EAGZxG,KAAKkH,GAAKA,EAGVlH,KAAKuqB,QAAUA,EAGfvqB,KAAKwqB,MAAQA,EAGbxqB,KAAK4D,MAAQA,EAIb5D,KAAKoP,OAASA,EACdpP,KAAKylB,YAAcA,E,8FAGrB6E,EAAFA,UAAEhlB,MAAA,SAAM4K,GACJ,GAAIlQ,KAAKylB,YAAc4E,GAAena,EAAKlQ,KAAKwG,KAAMxG,KAAKuqB,UACpCF,GAAena,EAAKlQ,KAAKwqB,MAAOxqB,KAAKkH,KAC1D,OAAO8iB,GAAWC,KAAK,iDAEzBljB,IAAI0jB,EAAMva,EAAItM,MAAM5D,KAAKuqB,QAASvqB,KAAKwqB,OACvC,GAAIC,EAAI1d,WAAa0d,EAAIzd,QACvB,OAAOgd,GAAWC,KAAK,2BACzBljB,IAAI2jB,EAAW1qB,KAAK4D,MAAMoL,SAAShP,KAAKoP,OAAQqb,EAAIjlB,SACpD,OAAKklB,EACEV,GAAWE,YAAYha,EAAKlQ,KAAKwG,KAAMxG,KAAKkH,GAAIwjB,GADjCV,GAAWC,KAAK,gCAIxCK,EAAFA,UAAEjB,OAAA,WACE,OAAO,IAAI1C,GAAQ,CAAC3mB,KAAKwG,KAAMxG,KAAKuqB,QAAUvqB,KAAKwG,KAAMxG,KAAKoP,OAC1CpP,KAAKwqB,MAAOxqB,KAAKkH,GAAKlH,KAAKwqB,MAAOxqB,KAAK4D,MAAM6C,KAAOzG,KAAKoP,UAG/Ekb,EAAFA,UAAE3C,OAAA,SAAOzX,GACLnJ,IAAI0jB,EAAMzqB,KAAKwqB,MAAQxqB,KAAKuqB,QAC5B,OAAO,IAAID,EAAkBtqB,KAAKwG,KAAMxG,KAAKwG,KAAOxG,KAAK4D,MAAM6C,KAAOgkB,EACzCzqB,KAAKwG,KAAOxG,KAAKoP,OAAQpP,KAAKwG,KAAOxG,KAAKoP,OAASqb,EACnDva,EAAItM,MAAM5D,KAAKwG,KAAMxG,KAAKkH,IAAIoI,cAActP,KAAKuqB,QAAUvqB,KAAKwG,KAAMxG,KAAKwqB,MAAQxqB,KAAKwG,MACxFxG,KAAKuqB,QAAUvqB,KAAKwG,KAAMxG,KAAKylB,YAG9D6E,EAAFA,UAAE/jB,IAAA,SAAI6hB,GACFrhB,IAAIP,EAAO4hB,EAAQpB,UAAUhnB,KAAKwG,KAAM,GAAIU,EAAKkhB,EAAQpB,UAAUhnB,KAAKkH,IAAK,GACzEqjB,EAAUnC,EAAQ7hB,IAAIvG,KAAKuqB,SAAU,GAAIC,EAAQpC,EAAQ7hB,IAAIvG,KAAKwqB,MAAO,GAC7E,OAAKhkB,EAAKigB,SAAWvf,EAAGuf,SAAY8D,EAAU/jB,EAAKa,KAAOmjB,EAAQtjB,EAAGG,IAAY,KAC1E,IAAIijB,EAAkB9jB,EAAKa,IAAKH,EAAGG,IAAKkjB,EAASC,EAAOxqB,KAAK4D,MAAO5D,KAAKoP,OAAQpP,KAAKylB,YAG/F6E,EAAFA,UAAEvf,OAAA,WACEhE,IAAIyF,EAAO,CAACod,SAAU,gBAAiBpjB,KAAMxG,KAAKwG,KAAMU,GAAIlH,KAAKkH,GACrDqjB,QAASvqB,KAAKuqB,QAASC,MAAOxqB,KAAKwqB,MAAOpb,OAAQpP,KAAKoP,QAGnE,OAFIpP,KAAK4D,MAAM6C,OAAM+F,EAAK5I,MAAQ5D,KAAK4D,MAAMmH,UACzC/K,KAAKylB,YAAWjZ,EAAKiZ,WAAY,GAC9BjZ,GAGT8d,EAAOtf,SAAA,SAASC,EAAQuB,GACtB,GAAwB,iBAAbA,EAAKhG,MAAsC,iBAAXgG,EAAKtF,IACrB,iBAAhBsF,EAAK+d,SAA4C,iBAAd/d,EAAKge,OAA2C,iBAAfhe,EAAK4C,OAClF,MAAM,IAAI7F,WAAW,gDACvB,OAAO,IAAI+gB,EAAkB9d,EAAKhG,KAAMgG,EAAKtF,GAAIsF,EAAK+d,QAAS/d,EAAKge,MACvC1d,EAAM9B,SAASC,EAAQuB,EAAK5I,OAAQ4I,EAAK4C,SAAU5C,EAAKiZ,Y,EA5E3D,CAAS8D,IAkFvC,SAASc,GAAena,EAAK1J,EAAMU,GAEjC,IADAH,IAAImG,EAAQgD,EAAItP,QAAQ4F,GAAO2I,EAAOjI,EAAKV,EAAM4G,EAAQF,EAAME,MACxD+B,EAAO,GAAK/B,EAAQ,GAAKF,EAAMiD,WAAW/C,IAAUF,EAAMhF,KAAKkF,GAAO9D,YAC3E8D,IACA+B,IAEF,GAAIA,EAAO,EAET,IADApI,IAAIvF,EAAO0L,EAAMhF,KAAKkF,GAAO5D,WAAW0D,EAAMiD,WAAW/C,IAClD+B,EAAO,GAAG,CACf,IAAK3N,GAAQA,EAAK4G,OAAQ,OAAO,EACjC5G,EAAOA,EAAKkH,WACZyG,IAGJ,OAAO,EC/KT,SAASwb,GAAOziB,EAAMV,EAAOD,GAC3B,OAAiB,GAATC,GAAcU,EAAKmH,WAAW7H,EAAOU,EAAKoB,eAC/C/B,GAAOW,EAAKoB,YAAcpB,EAAKmH,WAAW,EAAG9H,IAO3C,SAASqjB,GAAWC,GAGzB,IAFA9jB,IACIvB,EADSqlB,EAAMzjB,OACE5B,QAAQsD,WAAW+hB,EAAMnc,WAAYmc,EAAMlc,UACvDvB,EAAQyd,EAAMzd,SAAUA,EAAO,CACtCrG,IAAImB,EAAO2iB,EAAM3d,MAAMhF,KAAKkF,GACxBnE,EAAQ4hB,EAAM3d,MAAMjE,MAAMmE,GAAQuB,EAAWkc,EAAM1d,IAAIgD,WAAW/C,GACtE,GAAIA,EAAQyd,EAAMzd,OAASlF,EAAKmH,WAAWpG,EAAO0F,EAAUnJ,GAC1D,OAAO4H,EACT,GAAa,GAATA,GAAclF,EAAKzI,KAAKmQ,KAAKC,YAAc8a,GAAOziB,EAAMe,EAAO0F,GAAW,OA6I3E,SAASmc,GAAS5a,EAAK7I,EAAK+F,EAAW2d,Q,UAAH,GACzChkB,IAAIikB,EAAO9a,EAAItP,QAAQyG,GAAMuM,EAAOoX,EAAK5d,MAAQA,EAC7C6d,EAAaF,GAAcA,EAAWA,EAAWtoB,OAAS,IAAOuoB,EAAK5jB,OAC1E,GAAIwM,EAAO,GAAKoX,EAAK5jB,OAAO3H,KAAKmQ,KAAKC,YACjCmb,EAAK5jB,OAAOiI,WAAW2b,EAAK/hB,QAAS+hB,EAAK5jB,OAAOkC,cACjD2hB,EAAUxrB,KAAKsP,aAAaic,EAAK5jB,OAAO5B,QAAQsD,WAAWkiB,EAAK/hB,QAAS+hB,EAAK5jB,OAAOkC,aACxF,OAAO,EACT,IAAKvC,IAAI5L,EAAI6vB,EAAK5d,MAAQ,EAAGvS,EAAIuS,EAAQ,EAAGjS,EAAIyY,EAAMzY,IAAKN,IAAK,CAC9DkM,IAAImB,EAAO8iB,EAAK9iB,KAAK/M,GAAI8N,EAAQ+hB,EAAK/hB,MAAM9N,GAC5C,GAAI+M,EAAKzI,KAAKmQ,KAAKC,UAAW,OAAO,EACrC9I,IAAImkB,EAAOhjB,EAAK1C,QAAQsD,WAAWG,EAAOf,EAAKoB,YAC3C+G,EAAS0a,GAAcA,EAAWlwB,IAAOqN,EAE7C,GADImI,GAASnI,IAAMgjB,EAAOA,EAAKliB,aAAa,EAAGqH,EAAM5Q,KAAKtD,OAAOkU,EAAM5E,UAClEvD,EAAKmH,WAAWpG,EAAQ,EAAGf,EAAKoB,cAAgB+G,EAAM5Q,KAAKsP,aAAamc,GAC3E,OAAO,EAEXnkB,IAAIkC,EAAQ+hB,EAAK7a,WAAWyD,GACxBuX,EAAWJ,GAAcA,EAAW,GACxC,OAAOC,EAAK9iB,KAAK0L,GAAMV,eAAejK,EAAOA,EAAOkiB,EAAWA,EAAS1rB,KAAOurB,EAAK9iB,KAAK0L,EAAO,GAAGnU,MAsB9F,SAAS2rB,GAAQlb,EAAK7I,GAC3BN,IAAIikB,EAAO9a,EAAItP,QAAQyG,GAAM4B,EAAQ+hB,EAAK/hB,QAC1C,OAAO6E,GAASkd,EAAKlc,WAAYkc,EAAKnc,YACpCmc,EAAK5jB,OAAOiI,WAAWpG,EAAOA,EAAQ,GAG1C,SAAS6E,GAASpE,EAAGC,GACnB,OAAOD,GAAKC,IAAMD,EAAEtB,QAAUsB,EAAE0J,UAAUzJ,GC/M5C,SAAS0hB,GAAYpc,EAAU5I,EAAGe,GAEhC,IADAL,IAAIukB,EAAS,GACJzwB,EAAI,EAAGA,EAAIoU,EAAS3F,WAAYzO,IAAK,CAC5CkM,IAAIO,EAAQ2H,EAAS3H,MAAMzM,GACvByM,EAAM9B,QAAQiB,OAAMa,EAAQA,EAAM6B,KAAKkiB,GAAY/jB,EAAM9B,QAASa,EAAGiB,KACrEA,EAAMqJ,WAAUrJ,EAAQjB,EAAEiB,EAAOF,EAAQvM,IAC7CywB,EAAOppB,KAAKoF,GAEd,OAAOR,EAASuE,UAAUigB,GFyJ5B/B,GAAKM,OAAO,gBAAiBS,ICpI7B1B,GAAUnsB,UAAU8uB,KAAO,SAASV,EAAOpc,GAOzC,IANK,IAAAvB,EAAA,EAAAA,MAAOC,EAAA,EAAAA,IAAKC,EAAA,EAAAA,MAEboe,EAAWte,EAAMkD,OAAOhD,EAAQ,GAAIqe,EAASte,EAAIkD,MAAMjD,EAAQ,GAC/D5F,EAAQgkB,EAAUjkB,EAAMkkB,EAExBrb,EAAStJ,EAASiC,MAAOgE,EAAY,EAChC5R,EAAIiS,EAAOse,GAAY,EAAOvwB,EAAIsT,EAAQtT,IAC7CuwB,GAAaxe,EAAMjE,MAAM9N,GAAK,GAChCuwB,GAAY,EACZtb,EAAStJ,EAASN,KAAK0G,EAAMhF,KAAK/M,GAAGgO,KAAKiH,IAC1CrD,KAEAvF,IAGJ,IADAT,IAAIsJ,EAAQvJ,EAASiC,MAAOiE,EAAU,EAC7B7R,EAAIiS,EAAOse,GAAY,EAAOvwB,EAAIsT,EAAQtT,IAC7CuwB,GAAave,EAAIkD,MAAMlV,EAAI,GAAKgS,EAAI5F,IAAIpM,IAC1CuwB,GAAY,EACZrb,EAAQvJ,EAASN,KAAK2G,EAAIjF,KAAK/M,GAAGgO,KAAKkH,IACvCrD,KAEAzF,IAGJ,OAAOvH,KAAKgpB,KAAK,IAAIsB,GAAkB9iB,EAAOD,EAAKikB,EAAUC,EACtB,IAAI3e,EAAMsD,EAAOzJ,OAAO0J,GAAQtD,EAAWC,GAC3CoD,EAAO3J,KAAOsG,GAAW,KA4ClE6b,GAAUnsB,UAAUsB,KAAO,SAAS8sB,EAAOc,GAEzC,IADA5kB,IAAIvB,EAAUsB,EAASiC,MACdlO,EAAI8wB,EAASlpB,OAAS,EAAG5H,GAAK,EAAGA,IAAK,CAC7C,GAAI2K,EAAQiB,KAAM,CAChBM,IAAI2L,EAAQiZ,EAAS9wB,GAAG4E,KAAKkT,aAAaC,cAAcpN,GACxD,IAAKkN,IAAUA,EAAMM,SACnB,MAAM,IAAIzJ,WAAW,0FAEzB/D,EAAUsB,EAASN,KAAKmlB,EAAS9wB,GAAG4E,KAAKtD,OAAOwvB,EAAS9wB,GAAG4Q,MAAOjG,IAGrEuB,IAAIS,EAAQqjB,EAAMrjB,MAAOD,EAAMsjB,EAAMtjB,IACrC,OAAOvH,KAAKgpB,KAAK,IAAIsB,GAAkB9iB,EAAOD,EAAKC,EAAOD,EAAK,IAAIuF,EAAMtH,EAAS,EAAG,GAAImmB,EAASlpB,QAAQ,KAM5GmmB,GAAUnsB,UAAUmvB,aAAe,SAASplB,EAAMU,EAAWzH,EAAMgM,G,WACjE,Q,UADqDjF,IAChD/G,EAAK4S,YAAa,MAAM,IAAI9I,WAAW,oDAC5CxC,IAAI8kB,EAAU7rB,KAAK6oB,MAAMpmB,OAYzB,OAXAzC,KAAKkQ,IAAIjJ,aAAaT,EAAMU,GAAE,SAAGgB,EAAMb,GACrC,GAAIa,EAAKmK,cAAgBnK,EAAK4J,UAAUrS,EAAMgM,IAalD,SAAuByE,EAAK7I,EAAK5H,GAC/BsH,IAAIikB,EAAO9a,EAAItP,QAAQyG,GAAM4B,EAAQ+hB,EAAK/hB,QAC1C,OAAO+hB,EAAK5jB,OAAO8L,eAAejK,EAAOA,EAAQ,EAAGxJ,GAfMqsB,CAAc9rB,EAAKkQ,IAAKlQ,EAAKooB,QAAQxkB,MAAMioB,GAAStlB,IAAIc,GAAM5H,GAAO,CAE3HO,EAAK+rB,kBAAkB/rB,EAAKooB,QAAQxkB,MAAMioB,GAAStlB,IAAIc,EAAK,GAAI5H,GAChEsH,IAAIqhB,EAAUpoB,EAAKooB,QAAQxkB,MAAMioB,GAC7BG,EAAS5D,EAAQ7hB,IAAIc,EAAK,GAAI4kB,EAAO7D,EAAQ7hB,IAAIc,EAAMa,EAAKlB,SAAU,GAG1E,OAFAhH,EAAKgpB,KAAK,IAAIsB,GAAkB0B,EAAQC,EAAMD,EAAS,EAAGC,EAAO,EACjC,IAAInf,EAAMhG,EAASN,KAAK/G,EAAKtD,OAAOsP,EAAO,KAAMvD,EAAKuE,QAAS,EAAG,GAAI,GAAG,KAClG,MAGJzM,MAWT4oB,GAAUnsB,UAAUyvB,cAAgB,SAAS7kB,EAAK5H,EAAMgM,EAAOgB,GAC7D1F,IAAImB,EAAOlI,KAAKkQ,IAAI+B,OAAO5K,GAC3B,IAAKa,EAAM,MAAM,IAAIqB,WAAW,6BAC3B9J,IAAMA,EAAOyI,EAAKzI,MACvBsH,IAAIolB,EAAU1sB,EAAKtD,OAAOsP,EAAO,KAAMgB,GAASvE,EAAKuE,OACrD,GAAIvE,EAAKE,OACP,OAAOpI,KAAKosB,YAAY/kB,EAAKA,EAAMa,EAAKlB,SAAUmlB,GAEpD,IAAK1sB,EAAKsP,aAAa7G,EAAK1C,SAC1B,MAAM,IAAI+D,WAAW,iCAAmC9J,EAAKrE,MAE/D,OAAO4E,KAAKgpB,KAAK,IAAIsB,GAAkBjjB,EAAKA,EAAMa,EAAKlB,SAAUK,EAAM,EAAGA,EAAMa,EAAKlB,SAAW,EACzD,IAAI8F,EAAMhG,EAASN,KAAK2lB,GAAU,EAAG,GAAI,GAAG,KAgCrFvD,GAAUnsB,UAAUya,MAAQ,SAAS7P,EAAK+F,EAAW2d,Q,UAAH,GAEhD,IADAhkB,IAAIikB,EAAOhrB,KAAKkQ,IAAItP,QAAQyG,GAAM+I,EAAStJ,EAASiC,MAAOsH,EAAQvJ,EAASiC,MACnE5N,EAAI6vB,EAAK5d,MAAO+c,EAAIa,EAAK5d,MAAQA,EAAOvS,EAAIuS,EAAQ,EAAGjS,EAAIgvB,EAAGhvB,IAAKN,IAAK,CAC/EuV,EAAStJ,EAASN,KAAKwkB,EAAK9iB,KAAK/M,GAAGgO,KAAKiH,IACzCrJ,IAAIslB,EAAYtB,GAAcA,EAAWlwB,GACzCwV,EAAQvJ,EAASN,KAAK6lB,EAAYA,EAAU5sB,KAAKtD,OAAOkwB,EAAU5gB,MAAO4E,GAAS2a,EAAK9iB,KAAK/M,GAAGgO,KAAKkH,IAEtG,OAAOrQ,KAAKgpB,KAAK,IAAIoB,GAAY/iB,EAAKA,EAAK,IAAIyF,EAAMsD,EAAOzJ,OAAO0J,GAAQjD,EAAOA,IAAQ,KA6C5Fwb,GAAUnsB,UAAUqO,KAAO,SAASzD,EAAK+F,Q,UAAQ,GAC/CrG,IAAIiiB,EAAO,IAAIoB,GAAY/iB,EAAM+F,EAAO/F,EAAM+F,EAAON,EAAM/D,OAAO,GAClE,OAAO/I,KAAKgpB,KAAKA,I,ICrONsD,GAAW,YAEtB,WAAY9lB,EAAMU,EAAInE,GACpB0Q,OAAK,MAGLzT,KAAKwG,KAAOA,EAGZxG,KAAKkH,GAAKA,EAGVlH,KAAK+C,KAAOA,E,8FAGdupB,EAAFA,UAAEhnB,MAAA,SAAM4K,G,WACAqc,EAAWrc,EAAItM,MAAM5D,KAAKwG,KAAMxG,KAAKkH,IAAKgG,EAAQgD,EAAItP,QAAQZ,KAAKwG,MACnEY,EAAS8F,EAAMhF,KAAKgF,EAAM0D,YAAY5Q,KAAKkH,KAC3CtD,EAAQ,IAAIkJ,EAAMue,GAAYkB,EAAS/mB,SAAO,SAAG0C,EAAMd,GACzD,OAAKc,EAAKoK,QAAWlL,EAAO3H,KAAKwZ,eAAejZ,EAAK+C,KAAKtD,MACnDyI,EAAKnF,KAAK/C,EAAK+C,KAAKiJ,SAAS9D,EAAKuE,QAD+BvE,IAEvEd,GAASmlB,EAASxf,UAAWwf,EAASvf,SACzC,OAAOgd,GAAWE,YAAYha,EAAKlQ,KAAKwG,KAAMxG,KAAKkH,GAAItD,IAGzD0oB,EAAFA,UAAE3E,OAAA,WACE,OAAO,IAAI6E,GAAexsB,KAAKwG,KAAMxG,KAAKkH,GAAIlH,KAAK+C,OAGrDupB,EAAFA,UAAE/lB,IAAA,SAAI6hB,GACFrhB,IAAIP,EAAO4hB,EAAQpB,UAAUhnB,KAAKwG,KAAM,GAAIU,EAAKkhB,EAAQpB,UAAUhnB,KAAKkH,IAAK,GAC7E,OAAIV,EAAKigB,SAAWvf,EAAGuf,SAAWjgB,EAAKa,KAAOH,EAAGG,IAAY,KACtD,IAAIilB,EAAY9lB,EAAKa,IAAKH,EAAGG,IAAKrH,KAAK+C,OAGhDupB,EAAFA,UAAE5C,MAAA,SAAMphB,GACJ,GAAIA,aAAiBgkB,GACjBhkB,EAAMvF,KAAKqG,GAAGpJ,KAAK+C,OACnB/C,KAAKwG,MAAQ8B,EAAMpB,IAAMlH,KAAKkH,IAAMoB,EAAM9B,KAC5C,OAAO,IAAI8lB,EAAY7kB,KAAKE,IAAI3H,KAAKwG,KAAM8B,EAAM9B,MAC1BiB,KAAKC,IAAI1H,KAAKkH,GAAIoB,EAAMpB,IAAKlH,KAAK+C,OAG7DupB,EAAFA,UAAEvhB,OAAA,WACE,MAAO,CAAC6e,SAAU,UAAW7mB,KAAM/C,KAAK+C,KAAKgI,SACrCvE,KAAMxG,KAAKwG,KAAMU,GAAIlH,KAAKkH,KAGpColB,EAAOthB,SAAA,SAASC,EAAQuB,GACtB,GAAwB,iBAAbA,EAAKhG,MAAsC,iBAAXgG,EAAKtF,GAC9C,MAAM,IAAIqC,WAAW,0CACvB,OAAO,IAAI+iB,EAAY9f,EAAKhG,KAAMgG,EAAKtF,GAAI+D,EAAOqI,aAAa9G,EAAKzJ,Q,EAnDhD,CAASwmB,IAuDjCA,GAAKM,OAAO,UAAWyC,I,IAGVE,GAAc,YAEzB,WAAYhmB,EAAMU,EAAInE,GACpB0Q,OAAK,MAGLzT,KAAKwG,KAAOA,EAGZxG,KAAKkH,GAAKA,EAGVlH,KAAK+C,KAAOA,E,8FAGdypB,EAAFA,UAAElnB,MAAA,SAAM4K,G,WACAqc,EAAWrc,EAAItM,MAAM5D,KAAKwG,KAAMxG,KAAKkH,IACrCtD,EAAQ,IAAIkJ,EAAMue,GAAYkB,EAAS/mB,SAAO,SAAE0C,GAClD,OAAOA,EAAKnF,KAAK/C,EAAK+C,KAAKsJ,cAAcnE,EAAKuE,WAC5C8f,EAASxf,UAAWwf,EAASvf,SACjC,OAAOgd,GAAWE,YAAYha,EAAKlQ,KAAKwG,KAAMxG,KAAKkH,GAAItD,IAGzD4oB,EAAFA,UAAE7E,OAAA,WACE,OAAO,IAAI2E,GAAYtsB,KAAKwG,KAAMxG,KAAKkH,GAAIlH,KAAK+C,OAGlDypB,EAAFA,UAAEjmB,IAAA,SAAI6hB,GACFrhB,IAAIP,EAAO4hB,EAAQpB,UAAUhnB,KAAKwG,KAAM,GAAIU,EAAKkhB,EAAQpB,UAAUhnB,KAAKkH,IAAK,GAC7E,OAAIV,EAAKigB,SAAWvf,EAAGuf,SAAWjgB,EAAKa,KAAOH,EAAGG,IAAY,KACtD,IAAImlB,EAAehmB,EAAKa,IAAKH,EAAGG,IAAKrH,KAAK+C,OAGnDypB,EAAFA,UAAE9C,MAAA,SAAMphB,GACJ,GAAIA,aAAiBkkB,GACjBlkB,EAAMvF,KAAKqG,GAAGpJ,KAAK+C,OACnB/C,KAAKwG,MAAQ8B,EAAMpB,IAAMlH,KAAKkH,IAAMoB,EAAM9B,KAC5C,OAAO,IAAIgmB,EAAe/kB,KAAKE,IAAI3H,KAAKwG,KAAM8B,EAAM9B,MAC1BiB,KAAKC,IAAI1H,KAAKkH,GAAIoB,EAAMpB,IAAKlH,KAAK+C,OAGhEypB,EAAFA,UAAEzhB,OAAA,WACE,MAAO,CAAC6e,SAAU,aAAc7mB,KAAM/C,KAAK+C,KAAKgI,SACxCvE,KAAMxG,KAAKwG,KAAMU,GAAIlH,KAAKkH,KAGpCslB,EAAOxhB,SAAA,SAASC,EAAQuB,GACtB,GAAwB,iBAAbA,EAAKhG,MAAsC,iBAAXgG,EAAKtF,GAC9C,MAAM,IAAIqC,WAAW,6CACvB,OAAO,IAAIijB,EAAehgB,EAAKhG,KAAMgG,EAAKtF,GAAI+D,EAAOqI,aAAa9G,EAAKzJ,Q,EAjDhD,CAASwmB,IZ9D7B,SAASkD,GAAYvc,EAAK1J,EAAMU,EAAWtD,GAChD,Q,UAD0C4C,Q,UAAcsG,EAAM/D,OAC1DvC,GAAQU,IAAOtD,EAAM6C,KAAM,OAAO,KAEtCM,IAAImG,EAAQgD,EAAItP,QAAQ4F,GAAO2G,EAAM+C,EAAItP,QAAQsG,GAEjD,OAAIwlB,GAAcxf,EAAOC,EAAKvJ,GAAe,IAAIwmB,GAAY5jB,EAAMU,EAAItD,GAChE,IAAI+oB,GAAOzf,EAAOC,EAAKvJ,GAAOgpB,MA+BvC,SAASF,GAAcxf,EAAOC,EAAKvJ,GACjC,OAAQA,EAAMmJ,YAAcnJ,EAAMoJ,SAAWE,EAAM1F,SAAW2F,EAAI3F,SAChE0F,EAAM9F,OAAOiI,WAAWnC,EAAMjE,QAASkE,EAAIlE,QAASrF,EAAM4B,SY4E9D+jB,GAAKM,OAAO,aAAc2C,IbtH1B5D,GAAUnsB,UAAUowB,QAAU,SAASrmB,EAAMU,EAAInE,G,WAC3C+pB,EAAU,GAAIC,EAAQ,GAAIC,EAAW,KAAMC,EAAS,KA0BxD,OAzBAjtB,KAAKkQ,IAAIjJ,aAAaT,EAAMU,GAAE,SAAGgB,EAAMb,EAAKD,GAC1C,GAAKc,EAAKyI,SAAV,CACA5J,IAAI0F,EAAQvE,EAAKuE,MACjB,IAAK1J,EAAKuJ,QAAQG,IAAUrF,EAAO3H,KAAKwZ,eAAelW,EAAKtD,MAAO,CAIjE,IAHAsH,IAAIS,EAAQC,KAAKC,IAAIL,EAAKb,GAAOe,EAAME,KAAKE,IAAIN,EAAMa,EAAKlB,SAAUE,GACjEgmB,EAASnqB,EAAKiJ,SAASS,GAElB5R,EAAI,EAAGA,EAAI4R,EAAMhK,OAAQ5H,IAC3B4R,EAAM5R,GAAGyR,QAAQ4gB,KAChBF,GAAYA,EAAS9lB,IAAMM,GAASwlB,EAASjqB,KAAKqG,GAAGqD,EAAM5R,IAC7DmyB,EAAS9lB,GAAKK,EAEdulB,EAAQ5qB,KAAK8qB,EAAW,IAAIR,GAAehlB,EAAOD,EAAKkF,EAAM5R,MAI/DoyB,GAAUA,EAAO/lB,IAAMM,EACzBylB,EAAO/lB,GAAKK,EAEZwlB,EAAM7qB,KAAK+qB,EAAS,IAAIX,GAAY9kB,EAAOD,EAAKxE,SAItD+pB,EAAQvsB,SAAO,SAAC3D,GAAA,OAAKoD,EAAKgpB,KAAKpsB,MAC/BmwB,EAAMxsB,SAAO,SAAC3D,GAAA,OAAKoD,EAAKgpB,KAAKpsB,MACtBoD,MAQT4oB,GAAUnsB,UAAU0wB,WAAa,SAAS3mB,EAAMU,EAAInE,G,0BAAO,MACzDgE,IAAIqmB,EAAU,GAAIpE,EAAO,EAkCzB,OAjCAhpB,KAAKkQ,IAAIjJ,aAAaT,EAAMU,GAAE,SAAGgB,EAAMb,GACrC,GAAKa,EAAKyI,SAAV,CACAqY,IACAjiB,IAAIsmB,EAAW,KACf,GAAItqB,aAAgBwW,GAElB,IADAxS,IAAsBrB,EAAlBuG,EAAM/D,EAAKuE,MACR/G,EAAQ3C,EAAKuJ,QAAQL,KACxBohB,IAAaA,EAAW,KAAKnrB,KAAKwD,GACpCuG,EAAMvG,EAAM2G,cAAcJ,QAEnBlJ,EACLA,EAAKuJ,QAAQpE,EAAKuE,SAAQ4gB,EAAW,CAACtqB,IAE1CsqB,EAAWnlB,EAAKuE,MAElB,GAAI4gB,GAAYA,EAAS5qB,OAEvB,IADAsE,IAAIQ,EAAME,KAAKE,IAAIN,EAAMa,EAAKlB,SAAUE,GAC/BrM,EAAI,EAAGA,EAAIwyB,EAAS5qB,OAAQ5H,IAAK,CAExC,IADAkM,IAAI0T,EAAQ4S,EAASxyB,GAAI6K,SAChBoE,EAAI,EAAGA,EAAIsjB,EAAQ3qB,OAAQqH,IAAK,CACvC/C,IAAI9L,EAAImyB,EAAQtjB,GACZ7O,EAAE+tB,MAAQA,EAAO,GAAKvO,EAAMrR,GAAGgkB,EAAQtjB,GAAG2Q,SAAQ/U,EAAQzK,GAE5DyK,GACFA,EAAMwB,GAAKK,EACX7B,EAAMsjB,KAAOA,GAEboE,EAAQlrB,KAAK,CAAAuY,MAACA,EAAOjU,KAAMiB,KAAKC,IAAIL,EAAKb,GAAOU,GAAIK,EAAGyhB,KAAEA,SAKjEoE,EAAQ7sB,SAAO,SAACtF,GAAA,OAAK+E,EAAKgpB,KAAK,IAAIwD,GAAevxB,EAAEuL,KAAMvL,EAAEiM,GAAIjM,EAAEwf,WAC3Dza,MAQT4oB,GAAUnsB,UAAUsvB,kBAAoB,SAAS1kB,EAAKimB,EAAY5a,Q,UAAQ4a,EAAW3a,cAGnF,IAFA5L,IAAImB,EAAOlI,KAAKkQ,IAAI+B,OAAO5K,GACvBkmB,EAAW,GAAIhY,EAAMlO,EAAM,EACtBxM,EAAI,EAAGA,EAAIqN,EAAKoB,WAAYzO,IAAK,CACxCkM,IAAIO,EAAQY,EAAKZ,MAAMzM,GAAI0M,EAAMgO,EAAMjO,EAAMN,SACzCwmB,EAAU9a,EAAMS,UAAU7L,EAAM7H,KAAM6H,EAAMmE,OAChD,GAAK+hB,EAEE,CACL9a,EAAQ8a,EACR,IAAKzmB,IAAI+C,EAAI,EAAGA,EAAIxC,EAAMmF,MAAMhK,OAAQqH,IAAUwjB,EAAWrU,eAAe3R,EAAMmF,MAAM3C,GAAGrK,OACzFO,KAAKgpB,KAAK,IAAIwD,GAAejX,EAAKhO,EAAKD,EAAMmF,MAAM3C,UAJrDyjB,EAASrrB,KAAK,IAAIkoB,GAAY7U,EAAKhO,EAAKuF,EAAM/D,QAMhDwM,EAAMhO,EAER,IAAKmL,EAAMM,SAAU,CACnBjM,IAAI2X,EAAOhM,EAAMsD,WAAWlP,EAASiC,OAAO,GAC5C/I,KAAKiN,QAAQsI,EAAKA,EAAK,IAAIzI,EAAM4R,EAAM,EAAG,IAE5C,IAAK3X,IAAIlM,EAAI0yB,EAAS9qB,OAAS,EAAG5H,GAAK,EAAGA,IAAKmF,KAAKgpB,KAAKuE,EAAS1yB,IAClE,OAAOmF,MCnFT4oB,GAAUnsB,UAAUwQ,QAAU,SAASzG,EAAMU,EAAWtD,Q,UAAN4C,Q,UAAcsG,EAAM/D,OACpEhC,IAAIiiB,EAAOyD,GAAYzsB,KAAKkQ,IAAK1J,EAAMU,EAAItD,GAE3C,OADIolB,GAAMhpB,KAAKgpB,KAAKA,GACbhpB,MAMT4oB,GAAUnsB,UAAU2vB,YAAc,SAAS5lB,EAAMU,EAAI1B,GACnD,OAAOxF,KAAKiN,QAAQzG,EAAMU,EAAI,IAAI4F,EAAMhG,EAASN,KAAKhB,GAAU,EAAG,KAKrEojB,GAAUnsB,UAAV,OAA6B,SAAS+J,EAAMU,GAC1C,OAAOlH,KAAKiN,QAAQzG,EAAMU,EAAI4F,EAAM/D,QAKtC6f,GAAUnsB,UAAU2S,OAAS,SAAS/H,EAAK7B,GACzC,OAAOxF,KAAKosB,YAAY/kB,EAAKA,EAAK7B,IA4BpC,IAAMmnB,GACJ,SAAYzf,EAAOC,EAAKvJ,GACtB5D,KAAKmN,IAAMA,EACXnN,KAAKkN,MAAQA,EACblN,KAAKytB,SAAW7pB,EAEhB5D,KAAK0tB,SAAW,GAChB,IAAK3mB,IAAIlM,EAAI,EAAGA,GAAKqS,EAAME,MAAOvS,IAAK,CACrCkM,IAAImB,EAAOgF,EAAMhF,KAAKrN,GACtBmF,KAAK0tB,SAASxrB,KAAK,CACjBzC,KAAMyI,EAAKzI,KACXiT,MAAOxK,EAAKuK,eAAevF,EAAMiD,WAAWtV,MAIhDmF,KAAKkM,OAASpF,EAASiC,MACvB,IAAKhC,IAAIlM,EAAIqS,EAAME,MAAOvS,EAAI,EAAGA,IAC/BmF,KAAKkM,OAASpF,EAASN,KAAK0G,EAAMhF,KAAKrN,GAAGsO,KAAKnJ,KAAKkM,U,6BA8M1D,SAASyhB,GAAiB1e,EAAU7B,EAAOwgB,GACzC,OAAa,GAATxgB,EAAmB6B,EAASnG,WAAW8kB,GACpC3e,EAASjG,aAAa,EAAGiG,EAASvG,WAAWS,KAAKwkB,GAAiB1e,EAASvG,WAAWlD,QAAS4H,EAAQ,EAAGwgB,KAGpH,SAASC,GAAc5e,EAAU7B,EAAO5H,GACtC,OAAa,GAAT4H,EAAmB6B,EAAStI,OAAOnB,GAChCyJ,EAASjG,aAAaiG,EAAS3F,WAAa,EACtB2F,EAASzG,UAAUW,KAAK0kB,GAAc5e,EAASzG,UAAUhD,QAAS4H,EAAQ,EAAG5H,KAG5G,SAASsoB,GAAU7e,EAAU7B,GAC3B,IAAKrG,IAAIlM,EAAI,EAAGA,EAAIuS,EAAOvS,IAAKoU,EAAWA,EAASvG,WAAWlD,QAC/D,OAAOyJ,EAGT,SAAS8e,GAAe7lB,EAAM6E,EAAWC,GACvC,GAAID,GAAa,EAAG,OAAO7E,EAC3BnB,IAAI8O,EAAO3N,EAAK1C,QAOhB,OANIuH,EAAY,IACd8I,EAAOA,EAAK7M,aAAa,EAAG+kB,GAAelY,EAAKnN,WAAYqE,EAAY,EAAsB,GAAnB8I,EAAKvM,WAAkB0D,EAAU,EAAI,KAC9GD,EAAY,IACd8I,EAAO3N,EAAKzI,KAAKkT,aAAaqD,WAAWH,GAAMlP,OAAOkP,GAClD7I,GAAW,IAAG6I,EAAOA,EAAKlP,OAAOuB,EAAKzI,KAAKkT,aAAaC,cAAciD,GAAMG,WAAWlP,EAASiC,OAAO,MAEtGb,EAAKiB,KAAK0M,GAGnB,SAASmY,GAAiB7gB,EAAKC,EAAO3N,EAAMiT,EAAO4M,GACjDvY,IAAImB,EAAOiF,EAAIjF,KAAKkF,GAAQnE,EAAQqW,EAAOnS,EAAIgD,WAAW/C,GAASD,EAAIlE,MAAMmE,GAC7E,GAAInE,GAASf,EAAKoB,aAAe7J,EAAK6O,kBAAkBpG,EAAKzI,MAAO,OAAO,KAC3EsH,IAAI6lB,EAAMla,EAAMsD,WAAW9N,EAAK1C,SAAS,EAAMyD,GAC/C,OAAO2jB,IAGT,SAAsBntB,EAAMwP,EAAUzH,GACpC,IAAKT,IAAIlM,EAAI2M,EAAO3M,EAAIoU,EAAS3F,WAAYzO,IAC3C,IAAK4E,EAAKwT,YAAYhE,EAAS3H,MAAMzM,GAAG4R,OAAQ,OAAO,EACzD,OAAO,EANQwhB,CAAaxuB,EAAMyI,EAAK1C,QAASyD,GAAS2jB,EAAM,KAiGjE,SAASsB,GAAcjf,EAAU7B,EAAO+gB,EAASC,EAAShnB,GACxD,GAAIgG,EAAQ+gB,EAAS,CACnBpnB,IAAI0B,EAAQwG,EAASvG,WACrBuG,EAAWA,EAASjG,aAAa,EAAGP,EAAMU,KAAK+kB,GAAczlB,EAAMjD,QAAS4H,EAAQ,EAAG+gB,EAASC,EAAS3lB,KAE3G,GAAI2E,EAAQghB,EAAS,CACnBrnB,IAAI2L,EAAQtL,EAAOqL,eAAe,GAC9BjL,EAAQkL,EAAMsD,WAAW/G,GAAUtI,OAAOsI,GAC9CA,EAAWzH,EAAMb,OAAO+L,EAAME,cAAcpL,GAAOwO,WAAWlP,EAASiC,OAAO,IAEhF,OAAOkG,EA0CT,SAASof,GAAcnhB,EAAOC,GAE5B,IADApG,IAAIhG,EAAS,GACJ5F,EADmBsM,KAAKE,IAAIuF,EAAME,MAAOD,EAAIC,OAC/BjS,GAAK,EAAGA,IAAK,CAClC4L,IAAIS,EAAQ0F,EAAM1F,MAAMrM,GACxB,GAAIqM,EAAQ0F,EAAM7F,KAAO6F,EAAME,MAAQjS,IACnCgS,EAAI5F,IAAIpM,GAAKgS,EAAI9F,KAAO8F,EAAIC,MAAQjS,IACpC+R,EAAMhF,KAAK/M,GAAGsE,KAAKmQ,KAAKC,WACxB1C,EAAIjF,KAAK/M,GAAGsE,KAAKmQ,KAAKC,UAAW,OACjCrI,GAAS2F,EAAI3F,MAAMrM,IAClBA,GAAK+R,EAAME,OAASjS,GAAKgS,EAAIC,OAASF,EAAM9F,OAAO2J,eAAiB5D,EAAI/F,OAAO2J,eAC/E5V,GAAKgS,EAAI3F,MAAMrM,EAAI,IAAMqM,EAAQ,IACpCzG,EAAOmB,KAAK/G,GAEhB,OAAO4F,EA7YPsI,GAAI+D,MAAA1R,IAAA,WAAU,OAAOsE,KAAK0tB,SAASjrB,OAAS,G,aAE5CmqB,eAIE,KAAO5sB,KAAKytB,SAAShnB,MAAM,CACzBM,IAAI6lB,EAAM5sB,KAAKsuB,eACX1B,EAAK5sB,KAAKuuB,WAAW3B,GACpB5sB,KAAKwuB,YAAcxuB,KAAKyuB,WAO/B1nB,IAAI2nB,EAAa1uB,KAAK2uB,iBAAkBC,EAAa5uB,KAAKkM,OAAOzF,KAAOzG,KAAKoN,MAAQpN,KAAKkN,MAAME,MAC5FF,EAAQlN,KAAKkN,MAAOC,EAAMnN,KAAK0N,MAAMghB,EAAa,EAAI1uB,KAAKmN,IAAMD,EAAMgD,IAAItP,QAAQ8tB,IACvF,IAAKvhB,EAAK,OAAO,KAIjB,IADApG,IAAIvB,EAAUxF,KAAKkM,OAAQa,EAAYG,EAAME,MAAOJ,EAAUG,EAAIC,MAC3DL,GAAaC,GAAiC,GAAtBxH,EAAQ8D,YACrC9D,EAAUA,EAAQkD,WAAWlD,QAC7BuH,IAAaC,IAEfjG,IAAInD,EAAQ,IAAIkJ,EAAMtH,EAASuH,EAAWC,GAC1C,OAAI0hB,GAAc,EACT,IAAIpE,GAAkBpd,EAAM7F,IAAKqnB,EAAY1uB,KAAKmN,IAAI9F,IAAKrH,KAAKmN,IAAI5F,MAAO3D,EAAOgrB,GACvFhrB,EAAM6C,MAAQyG,EAAM7F,KAAOrH,KAAKmN,IAAI9F,IAC/B,IAAI+iB,GAAYld,EAAM7F,IAAK8F,EAAI9F,IAAKzD,QAD7C,G,aAOF0qB,wBAGE,IAAKvnB,IAAI8nB,EAAO,EAAGA,GAAQ,EAAGA,IAC5B,IAAK9nB,IAAI+nB,EAAa9uB,KAAKytB,SAAS1gB,UAAW+hB,GAAc,EAAGA,IAS9D,IARA/nB,IAAcK,SAOVqB,GANAqmB,GACF1nB,EAAS0mB,GAAU9tB,KAAKytB,SAASjoB,QAASspB,EAAa,GAAGpmB,YACxClD,QAEPxF,KAAKytB,SAASjoB,SAENkD,WACZqmB,EAAgB/uB,KAAKoN,MAAO2hB,GAAiB,EAAGA,IAAiB,CAC1E,IAAR,EAA8B/uB,KAAK0tB,SAASqB,GAA7BtvB,EAAA,EAAAA,KAAMiT,EAAA,EAAAA,MAAuC3U,SAAMixB,SAIxD,GAAY,GAARH,IAAcpmB,EAAQiK,EAAMS,UAAU1K,EAAMhJ,QAAUuvB,EAAStc,EAAMsD,WAAWlP,EAASN,KAAKiC,IAAQ,IACtFhJ,EAAK6O,kBAAkBlH,EAAO3H,OAChD,MAAO,CAAAqvB,WAACA,EAAUC,cAAEA,EAAa3nB,OAAEA,EAAM4nB,OAAEA,GAGxC,GAAY,GAARH,GAAapmB,IAAU1K,EAAO2U,EAAM8D,aAAa/N,EAAMhJ,OAC9D,MAAO,CAAAqvB,WAACA,EAAUC,cAAEA,EAAa3nB,OAAEA,EAAMrJ,KAAEA,GAG7C,GAAIqJ,GAAUsL,EAAMS,UAAU/L,EAAO3H,MAAO,Q,aAMpD+uB,oBACA,IAAF,EAAwCxuB,KAAKytB,SAApCjoB,EAAA,EAAAA,QAASuH,EAAA,EAAAA,UAAWC,EAAA,EAAAA,QACrBjD,EAAQ+jB,GAAUtoB,EAASuH,GAC/B,SAAKhD,EAAMT,YAAcS,EAAMrB,WAAWN,UAC1CpI,KAAKytB,SAAW,IAAI3gB,EAAMtH,EAASuH,EAAY,EACrBtF,KAAKC,IAAIsF,EAASjD,EAAMtD,KAAOsG,GAAavH,EAAQiB,KAAOuG,EAAUD,EAAY,EAAI,KACxG,I,aAGT0hB,oBACA,IAAF,EAAwCzuB,KAAKytB,SAApCjoB,EAAA,EAAAA,QAASuH,EAAA,EAAAA,UAAWC,EAAA,EAAAA,QACrBjD,EAAQ+jB,GAAUtoB,EAASuH,GAC/B,GAAIhD,EAAMT,YAAc,GAAKyD,EAAY,EAAG,CAC1ChG,IAAIkoB,EAAYzpB,EAAQiB,KAAOsG,GAAaA,EAAYhD,EAAMtD,KAC9DzG,KAAKytB,SAAW,IAAI3gB,EAAM6gB,GAAiBnoB,EAASuH,EAAY,EAAG,GAAIA,EAAY,EACzDkiB,EAAYliB,EAAY,EAAIC,QAEtDhN,KAAKytB,SAAW,IAAI3gB,EAAM6gB,GAAiBnoB,EAASuH,EAAW,GAAIA,EAAWC,I,aAQlFuhB,uBACE,I,oEAAOvuB,KAAKoN,MAAQ2hB,GAAe/uB,KAAKkvB,oBACxC,GAAInxB,EAAM,IAAKgJ,IAAIlM,EAAI,EAAGA,EAAIkD,EAAK0E,OAAQ5H,IAAKmF,KAAKmvB,iBAAiBpxB,EAAKlD,IAE3EkM,IAAInD,EAAQ5D,KAAKytB,SAAUxe,EAAW7H,EAASA,EAAO5B,QAAU5B,EAAM4B,QAClEuH,EAAYnJ,EAAMmJ,UAAY+hB,EAC9BM,EAAQ,EAAGlK,EAAM,GACzB,EAAwBllB,KAAK0tB,SAASqB,GAA7Brc,EAAA,EAAAA,MAAOjT,EAAA,EAAAA,KACZ,GAAIuvB,EAAQ,CACV,IAAKjoB,IAAIlM,EAAI,EAAGA,EAAIm0B,EAAO1lB,WAAYzO,IAAKqqB,EAAIhjB,KAAK8sB,EAAO1nB,MAAMzM,IAClE6X,EAAQA,EAAME,cAAcoc,GAQ9B,IAHAjoB,IAAIsoB,EAAgBpgB,EAASxI,KAAOqoB,GAAelrB,EAAM4B,QAAQiB,KAAO7C,EAAMoJ,SAGvEoiB,EAAQngB,EAAS3F,YAAY,CAClCvC,IAAIvF,EAAOyN,EAAS3H,MAAM8nB,GAAQnU,EAAUvI,EAAMS,UAAU3R,EAAK/B,MACjE,IAAKwb,EAAS,SACdmU,EACY,GAAkB,GAAbriB,GAAkBvL,EAAKgE,QAAQiB,QAC9CiM,EAAQuI,EACRiK,EAAIhjB,KAAK6rB,GAAevsB,EAAKuB,KAAKtD,EAAK0Z,aAAa3X,EAAKiL,QAAkB,GAAT2iB,EAAariB,EAAY,EACnEqiB,GAASngB,EAAS3F,WAAa+lB,GAAgB,KAG3EtoB,IAAIkP,EAAQmZ,GAASngB,EAAS3F,WACzB2M,IAAOoZ,GAAgB,GAE5BrvB,KAAKkM,OAAS2hB,GAAc7tB,KAAKkM,OAAQ6iB,EAAejoB,EAASN,KAAK0e,IACtEllB,KAAK0tB,SAASqB,GAAerc,MAAQA,EAIjCuD,GAASoZ,EAAe,GAAKjoB,GAAUA,EAAO3H,MAAQO,KAAK0tB,SAAS1tB,KAAKoN,OAAO3N,MAAQO,KAAK0tB,SAASjrB,OAAS,GACjHzC,KAAKkvB,oBAGP,IAAKnoB,IAAIlM,EAAI,EAAG0a,EAAMtG,EAAUpU,EAAIw0B,EAAcx0B,IAAK,CACrDkM,IAAImB,EAAOqN,EAAI/M,UACfxI,KAAK0tB,SAASxrB,KAAK,CAACzC,KAAMyI,EAAKzI,KAAMiT,MAAOxK,EAAKuK,eAAevK,EAAKoB,cACrEiM,EAAMrN,EAAK1C,QAMbxF,KAAKytB,SAAYxX,EACC,GAAd6Y,EAAkBhiB,EAAM/D,MACxB,IAAI+D,EAAM6gB,GAAiB/pB,EAAM4B,QAASspB,EAAa,EAAG,GAChDA,EAAa,EAAGO,EAAe,EAAIzrB,EAAMoJ,QAAU8hB,EAAa,GAHrD,IAAIhiB,EAAM6gB,GAAiB/pB,EAAM4B,QAASspB,EAAYM,GAAQxrB,EAAMmJ,UAAWnJ,EAAMoJ,U,aAMhH2hB,0BACE,IAAK3uB,KAAKmN,IAAI/F,OAAOiL,aAAerS,KAAKmN,IAAI5F,OAASvH,KAAKmN,IAAI9F,IAAK,OAAQ,EAC5EN,IAAqCsd,EAAjCnE,EAAMlgB,KAAK0tB,SAAS1tB,KAAKoN,OAC7B,IAAK8S,EAAIzgB,KAAK4S,cAAgB2b,GAAiBhuB,KAAKmN,IAAKnN,KAAKmN,IAAIC,MAAO8S,EAAIzgB,KAAMygB,EAAIxN,OAAO,IACzF1S,KAAKmN,IAAIC,OAASpN,KAAKoN,QAAUiX,EAAQrkB,KAAKsvB,eAAetvB,KAAKmN,OAASkX,EAAMjX,OAASpN,KAAKoN,MAAQ,OAAQ,EAGpH,IADF,IAAOA,EAASpN,KAAKmN,IAAdC,MAAmBiD,EAAQrQ,KAAKmN,IAAIkD,MAAMjD,GACxCA,EAAQ,GAAKiD,GAASrQ,KAAKmN,IAAI5F,MAAM6F,MAAUiD,EACtD,OAAOA,G,aAGTif,wBAAeniB,GACb4J,EAAM,IAAKhQ,IAAIlM,EAAI4M,KAAKE,IAAI3H,KAAKoN,MAAOD,EAAIC,OAAQvS,GAAK,EAAGA,IAAK,CACjE,IAAJ,EAA0BmF,KAAK0tB,SAAS7yB,GAA7B6X,EAAA,EAAAA,MAAOjT,EAAA,EAAAA,KACR8vB,EAAY10B,EAAIsS,EAAIC,OAASD,EAAI5F,IAAI1M,EAAI,IAAMsS,EAAI9F,KAAO8F,EAAIC,OAASvS,EAAI,IAC3E+xB,EAAMoB,GAAiB7gB,EAAKtS,EAAG4E,EAAMiT,EAAO6c,GAChD,GAAK3C,EAAL,CACA,IAAK7lB,IAAI5L,EAAIN,EAAI,EAAGM,GAAK,EAAGA,IAAK,CACjC,IAAN,EAA4B6E,KAAK0tB,SAASvyB,GAA7B,IAAAuX,MACDuI,EAAU+S,GAAiB7gB,EAAKhS,EADxB,EAAAsE,KACiCiT,GAAO,GACpD,IAAKuI,GAAWA,EAAQ3R,WAAY,SAASyN,EAE/C,MAAO,CAAC3J,MAAOvS,EAAC+xB,IAAEA,EAAK4C,KAAMD,EAAYpiB,EAAI+C,IAAItP,QAAQuM,EAAIkD,MAAMxV,EAAI,IAAMsS,M,aAIjFO,eAAMP,GACJpG,IAAI2G,EAAQ1N,KAAKsvB,eAAeniB,GAChC,IAAKO,EAAO,OAAO,KAEnB,KAAO1N,KAAKoN,MAAQM,EAAMN,OAAOpN,KAAKkvB,oBAClCxhB,EAAMkf,IAAItjB,aAAYtJ,KAAKkM,OAAS2hB,GAAc7tB,KAAKkM,OAAQwB,EAAMN,MAAOM,EAAMkf,MACtFzf,EAAMO,EAAM8hB,KACZ,IAAKzoB,IAAI5L,EAAIuS,EAAMN,MAAQ,EAAGjS,GAAKgS,EAAIC,MAAOjS,IAAK,CACjD4L,IAAImB,EAAOiF,EAAIjF,KAAK/M,GAAI+pB,EAAMhd,EAAKzI,KAAKkT,aAAaqD,WAAW9N,EAAK1C,SAAS,EAAM2H,EAAIlE,MAAM9N,IAC9F6E,KAAKmvB,iBAAiBjnB,EAAKzI,KAAMyI,EAAKuD,MAAOyZ,GAE/C,OAAO/X,G,aAGTgiB,0BAAiB1vB,EAAMgM,EAAOjG,GAC5BuB,IAAImZ,EAAMlgB,KAAK0tB,SAAS1tB,KAAKoN,OAC7B8S,EAAIxN,MAAQwN,EAAIxN,MAAMS,UAAU1T,GAChCO,KAAKkM,OAAS2hB,GAAc7tB,KAAKkM,OAAQlM,KAAKoN,MAAOtG,EAASN,KAAK/G,EAAKtD,OAAOsP,EAAOjG,KACtFxF,KAAK0tB,SAASxrB,KAAK,CAAAzC,KAACA,EAAMiT,MAAOjT,EAAKkT,gB,aAGxCuc,6BACEnoB,IACIme,EADOllB,KAAK0tB,SAASlqB,MACVkP,MAAMsD,WAAWlP,EAASiC,OAAO,GAC5Cmc,EAAI5b,aAAYtJ,KAAKkM,OAAS2hB,GAAc7tB,KAAKkM,OAAQlM,KAAK0tB,SAASjrB,OAAQyiB,K,yCA6DvF0D,GAAUnsB,UAAUgzB,aAAe,SAASjpB,EAAMU,EAAItD,GACpD,IAAKA,EAAM6C,KAAM,OAAOzG,KAAK0vB,YAAYlpB,EAAMU,GAE/CH,IAAImG,EAAQlN,KAAKkQ,IAAItP,QAAQ4F,GAAO2G,EAAMnN,KAAKkQ,IAAItP,QAAQsG,GAC3D,GAAIwlB,GAAcxf,EAAOC,EAAKvJ,GAC5B,OAAO5D,KAAKgpB,KAAK,IAAIoB,GAAY5jB,EAAMU,EAAItD,IAE7CmD,IAAI4oB,EAAetB,GAAcnhB,EAAOlN,KAAKkQ,IAAItP,QAAQsG,IAEZ,GAAzCyoB,EAAaA,EAAaltB,OAAS,IAASktB,EAAansB,MAG7DuD,IAAI6oB,IAAoB1iB,EAAME,MAAQ,GACtCuiB,EAAaE,QAAQD,GAKrB,IAAK7oB,IAAI5L,EAAI+R,EAAME,MAAO/F,EAAM6F,EAAM7F,IAAM,EAAGlM,EAAI,EAAGA,IAAKkM,IAAO,CAChEN,IAAI6I,EAAO1C,EAAMhF,KAAK/M,GAAGsE,KAAKmQ,KAC9B,GAAIA,EAAKkgB,UAAYlgB,EAAKC,UAAW,MACjC8f,EAAa9a,QAAQ1Z,IAAM,EAAGy0B,EAAkBz0B,EAC3C+R,EAAMkD,OAAOjV,IAAMkM,GAAKsoB,EAAa7pB,OAAO,EAAG,GAAI3K,GAO9D,IAHA4L,IAAIgpB,EAAuBJ,EAAa9a,QAAQ+a,GAE5CI,EAAY,GAAIC,EAAiBrsB,EAAMmJ,UAClCvH,EAAU5B,EAAM4B,QAAS3K,EAAI,GAAIA,IAAK,CAC7CkM,IAAImB,EAAO1C,EAAQkD,WAEnB,GADAsnB,EAAU9tB,KAAKgG,GACXrN,GAAK+I,EAAMmJ,UAAW,MAC1BvH,EAAU0C,EAAK1C,QAIbyqB,EAAiB,GAAKD,EAAUC,EAAiB,GAAGxwB,KAAKmQ,KAAKkgB,UAC9D5iB,EAAMhF,KAAK6nB,GAAsBtwB,MAAQuwB,EAAUC,EAAiB,GAAGxwB,KACzEwwB,GAAkB,EACXA,GAAkB,GAAKD,EAAUC,EAAiB,GAAG5d,aAAe2d,EAAUC,EAAiB,GAAGxwB,KAAKmQ,KAAKkgB,UAC5G5iB,EAAMhF,KAAK6nB,GAAsBtwB,MAAQuwB,EAAUC,EAAiB,GAAGxwB,OAC9EwwB,GAAkB,GAEpB,IAAKlpB,IAAI+C,EAAIlG,EAAMmJ,UAAWjD,GAAK,EAAGA,IAAK,CACzC/C,IAAImpB,GAAapmB,EAAImmB,EAAiB,IAAMrsB,EAAMmJ,UAAY,GAC1DqC,EAAS4gB,EAAUE,GACvB,GAAK9gB,EACL,IAAKrI,IAAIlM,EAAI,EAAGA,EAAI80B,EAAaltB,OAAQ5H,IAAK,CAG5CkM,IAAIopB,EAAcR,GAAc90B,EAAIk1B,GAAwBJ,EAAaltB,QAAS2tB,GAAS,EACvFD,EAAc,IAAKC,GAAS,EAAOD,GAAeA,GACtDppB,IAAIK,EAAS8F,EAAMhF,KAAKioB,EAAc,GAAIlnB,EAAQiE,EAAMjE,MAAMknB,EAAc,GAC5E,GAAI/oB,EAAO8L,eAAejK,EAAOA,EAAOmG,EAAO3P,KAAM2P,EAAO3C,OAC1D,OAAOzM,KAAKiN,QAAQC,EAAMkD,OAAO+f,GAAcC,EAASjjB,EAAIkD,MAAM8f,GAAejpB,EAC7D,IAAI4F,EAAMohB,GAActqB,EAAM4B,QAAS,EAAG5B,EAAMmJ,UAAWmjB,GACjDA,EAAWtsB,EAAMoJ,WAKrD,IADAjG,IAAIspB,EAAarwB,KAAK6oB,MAAMpmB,OACnB5H,EAAI80B,EAAaltB,OAAS,EAAG5H,GAAK,IACzCmF,KAAKiN,QAAQzG,EAAMU,EAAItD,KACnB5D,KAAK6oB,MAAMpmB,OAAS4tB,IAFoBx1B,IAAK,CAGjDkM,IAAIqG,EAAQuiB,EAAa90B,GACrBuS,EAAQ,IACZ5G,EAAO0G,EAAMkD,OAAOhD,GAAQlG,EAAKiG,EAAIkD,MAAMjD,IAE7C,OAAOpN,MAwBT4oB,GAAUnsB,UAAU6zB,iBAAmB,SAAS9pB,EAAMU,EAAIgB,GACxD,IAAKA,EAAKyI,UAAYnK,GAAQU,GAAMlH,KAAKkQ,IAAItP,QAAQ4F,GAAMY,OAAO5B,QAAQiB,KAAM,CAC9EM,IAAIwpB,EWpMD,SAAqBrgB,EAAK7I,EAAKkM,GACpCxM,IAAIikB,EAAO9a,EAAItP,QAAQyG,GACvB,GAAI2jB,EAAK5jB,OAAO8L,eAAe8X,EAAK/hB,QAAS+hB,EAAK/hB,QAASsK,GAAW,OAAOlM,EAE7E,GAAyB,GAArB2jB,EAAK7c,aACP,IAAKpH,IAAI5L,EAAI6vB,EAAK5d,MAAQ,EAAGjS,GAAK,EAAGA,IAAK,CACxC4L,IAAIkC,EAAQ+hB,EAAK/hB,MAAM9N,GACvB,GAAI6vB,EAAK9iB,KAAK/M,GAAG+X,eAAejK,EAAOA,EAAOsK,GAAW,OAAOyX,EAAK5a,OAAOjV,EAAI,GAChF,GAAI8N,EAAQ,EAAG,OAAO,KAE1B,GAAI+hB,EAAK7c,cAAgB6c,EAAK5jB,OAAO5B,QAAQiB,KAC3C,IAAKM,IAAI5L,EAAI6vB,EAAK5d,MAAQ,EAAGjS,GAAK,EAAGA,IAAK,CACxC4L,IAAIkC,EAAQ+hB,EAAK7a,WAAWhV,GAC5B,GAAI6vB,EAAK9iB,KAAK/M,GAAG+X,eAAejK,EAAOA,EAAOsK,GAAW,OAAOyX,EAAK3a,MAAMlV,EAAI,GAC/E,GAAI8N,EAAQ+hB,EAAK9iB,KAAK/M,GAAGmO,WAAY,OAAO,MXsLlCknB,CAAYxwB,KAAKkQ,IAAK1J,EAAM0B,EAAKzI,MAChC,MAAT8wB,IAAe/pB,EAAOU,EAAKqpB,GAEjC,OAAOvwB,KAAKyvB,aAAajpB,EAAMU,EAAI,IAAI4F,EAAMhG,EAASN,KAAK0B,GAAO,EAAG,KAMvE0gB,GAAUnsB,UAAUizB,YAAc,SAASlpB,EAAMU,GAG/C,IAFAH,IAAImG,EAAQlN,KAAKkQ,IAAItP,QAAQ4F,GAAO2G,EAAMnN,KAAKkQ,IAAItP,QAAQsG,GACvDupB,EAAUpC,GAAcnhB,EAAOC,GAC1BtS,EAAI,EAAGA,EAAI41B,EAAQhuB,OAAQ5H,IAAK,CACvCkM,IAAIqG,EAAQqjB,EAAQ51B,GAAI0N,EAAO1N,GAAK41B,EAAQhuB,OAAS,EACrD,GAAK8F,GAAiB,GAAT6E,GAAeF,EAAMhF,KAAKkF,GAAO3N,KAAKkT,aAAaK,SAC9D,OAAOhT,KAAA,OAAYkN,EAAM1F,MAAM4F,GAAQD,EAAI5F,IAAI6F,IACjD,GAAIA,EAAQ,IAAM7E,GAAQ2E,EAAMhF,KAAKkF,EAAQ,GAAGiC,WAAWnC,EAAMjE,MAAMmE,EAAQ,GAAID,EAAIgD,WAAW/C,EAAQ,KACxG,OAAOpN,KAAA,OAAYkN,EAAMkD,OAAOhD,GAAQD,EAAIkD,MAAMjD,IAEtD,IAAKrG,IAAI5L,EAAI,EAAGA,GAAK+R,EAAME,OAASjS,GAAKgS,EAAIC,MAAOjS,IAClD,GAAIqL,EAAO0G,EAAM1F,MAAMrM,IAAM+R,EAAME,MAAQjS,GAAK+L,EAAKgG,EAAM3F,IAAIpM,IAAMgS,EAAI5F,IAAIpM,GAAK+L,GAAMiG,EAAIC,MAAQjS,EAClG,OAAO6E,KAAA,OAAYkN,EAAMkD,OAAOjV,GAAI+L,GAExC,OAAOlH,KAAA,OAAYwG,EAAMU,Iapd3BwE,IAAMglB,GAAcn1B,OAAOY,OAAO,MAIrBw0B,GAKX,SAAYC,EAASC,EAAOjK,GAG1B5mB,KAAK4mB,OAASA,GAAU,CAAC,IAAIkK,GAAeF,EAAQjpB,IAAIkpB,GAAQD,EAAQlpB,IAAImpB,KAI5E7wB,KAAK4wB,QAAUA,EAIf5wB,KAAK6wB,MAAQA,G,uKAKfxnB,GAAI0nB,OAAAr1B,IAAA,WAAW,OAAOsE,KAAK4wB,QAAQvpB,KAInCgC,GAAIyU,KAAApiB,IAAA,WAAS,OAAOsE,KAAK6wB,MAAMxpB,KAI/BgC,GAAI7C,KAAA9K,IAAA,WAAS,OAAOsE,KAAKkN,MAAM7F,KAI/BgC,GAAInC,GAAAxL,IAAA,WAAO,OAAOsE,KAAKmN,IAAI9F,KAI3BgC,GAAI6D,MAAAxR,IAAA,WACF,OAAOsE,KAAK4mB,OAAO,GAAG1Z,OAKxB7D,GAAI8D,IAAAzR,IAAA,WACF,OAAOsE,KAAK4mB,OAAO,GAAGzZ,KAKxB9D,GAAIN,MAAArN,IAAA,WAEF,IADAqL,IAAI6f,EAAS5mB,KAAK4mB,OACT/rB,EAAI,EAAGA,EAAI+rB,EAAOnkB,OAAQ5H,IACjC,GAAI+rB,EAAO/rB,GAAGqS,MAAM7F,KAAOuf,EAAO/rB,GAAGsS,IAAI9F,IAAK,OAAO,EACvD,OAAO,G,aAYT7B,mBACE,OAAOxF,KAAKkN,MAAMhF,KAAK,GAAGtE,MAAM5D,KAAKwG,KAAMxG,KAAKkH,IAAI,I,aAMtD+F,iBAAQ+jB,EAAIxrB,Q,UAAUsH,EAAM/D,OAK1B,IADAhC,IAAIkqB,EAAWzrB,EAAQA,QAAQgD,UAAW0oB,EAAa,KAC9Cr2B,EAAI,EAAGA,EAAI2K,EAAQwH,QAASnS,IACnCq2B,EAAaD,EACbA,EAAWA,EAASzoB,UAItB,IADAzB,IAAI8kB,EAAUmF,EAAGnI,MAAMpmB,OAAQmkB,EAAS5mB,KAAK4mB,OACpC/rB,EAAI,EAAGA,EAAI+rB,EAAOnkB,OAAQ5H,IAAK,CACxC,IAAJ,EAAyB+rB,EAAO/rB,GAArBqS,EAAA,EAAAA,MAAOC,EAAA,EAAAA,IAAkBib,EAAU4I,EAAG5I,QAAQxkB,MAAMioB,GACzDmF,EAAGvB,aAAarH,EAAQ7hB,IAAI2G,EAAM7F,KAAM+gB,EAAQ7hB,IAAI4G,EAAI9F,KAAMxM,EAAIiS,EAAM/D,MAAQvD,GACvE,GAAL3K,GACFs2B,GAAwBH,EAAInF,GAAUoF,EAAWA,EAAStgB,SAAWugB,GAAcA,EAAW7e,cAAgB,EAAI,K,aAOxH+Z,qBAAY4E,EAAI9oB,GAEd,IADAnB,IAAI8kB,EAAUmF,EAAGnI,MAAMpmB,OAAQmkB,EAAS5mB,KAAK4mB,OACpC/rB,EAAI,EAAGA,EAAI+rB,EAAOnkB,OAAQ5H,IAAK,CACxC,IAAJ,EAAyB+rB,EAAO/rB,GAArBqS,EAAA,EAAAA,MAAOC,EAAA,EAAAA,IAAkBib,EAAU4I,EAAG5I,QAAQxkB,MAAMioB,GACrDrlB,EAAO4hB,EAAQ7hB,IAAI2G,EAAM7F,KAAMH,EAAKkhB,EAAQ7hB,IAAI4G,EAAI9F,KACpDxM,EACFm2B,EAAGtB,YAAYlpB,EAAMU,IAErB8pB,EAAGV,iBAAiB9pB,EAAMU,EAAIgB,GAC9BipB,GAAwBH,EAAInF,EAAS3jB,EAAKyI,UAAY,EAAI,MAiBhEggB,GAAOS,SAAA,SAASpG,EAAMqG,EAAKC,GACzBvqB,IAAIgD,EAAQihB,EAAK5jB,OAAO2J,cAAgB,IAAIwgB,GAAcvG,GACpDwG,GAAgBxG,EAAK9iB,KAAK,GAAI8iB,EAAK5jB,OAAQ4jB,EAAK3jB,IAAK2jB,EAAK/hB,QAASooB,EAAKC,GAC9E,GAAIvnB,EAAO,OAAOA,EAElB,IAAKhD,IAAIqG,EAAQ4d,EAAK5d,MAAQ,EAAGA,GAAS,EAAGA,IAAS,CACpDrG,IAAIrB,EAAQ2rB,EAAM,EACZG,GAAgBxG,EAAK9iB,KAAK,GAAI8iB,EAAK9iB,KAAKkF,GAAQ4d,EAAK5a,OAAOhD,EAAQ,GAAI4d,EAAK/hB,MAAMmE,GAAQikB,EAAKC,GAChGE,GAAgBxG,EAAK9iB,KAAK,GAAI8iB,EAAK9iB,KAAKkF,GAAQ4d,EAAK3a,MAAMjD,EAAQ,GAAI4d,EAAK/hB,MAAMmE,GAAS,EAAGikB,EAAKC,GACzG,GAAI5rB,EAAO,OAAOA,IAQtBirB,GAAOc,KAAA,SAAKzG,EAAM0G,GAChB,Y,UADuB,GAChB1xB,KAAKoxB,SAASpG,EAAM0G,IAAS1xB,KAAKoxB,SAASpG,GAAO0G,IAAS,IAAIC,GAAa3G,EAAK9iB,KAAK,KAQ/FyoB,GAAOiB,QAAA,SAAQ1hB,GACb,OAAOshB,GAAgBthB,EAAKA,EAAK,EAAG,EAAG,IAAM,IAAIyhB,GAAazhB,IAMhEygB,GAAOkB,MAAA,SAAM3hB,GACX,OAAOshB,GAAgBthB,EAAKA,EAAKA,EAAI1K,QAAQiB,KAAMyJ,EAAI5G,YAAa,IAAM,IAAIqoB,GAAazhB,IAM7FygB,GAAO3lB,SAAA,SAASkF,EAAK1D,GACnB,IAAKA,IAASA,EAAK/M,KAAM,MAAM,IAAI8J,WAAW,wCAC9CxC,IAAI+qB,EAAMpB,GAAYlkB,EAAK/M,MAC3B,IAAKqyB,EAAK,MAAM,IAAIvoB,WAAU,qBAAsBiD,EAAK/M,KAAI,YAC7D,OAAOqyB,EAAI9mB,SAASkF,EAAK1D,IAQ3BmkB,GAAO9G,OAAA,SAAOC,EAAIiI,GAChB,GAAIjI,KAAM4G,GAAa,MAAM,IAAInnB,WAAW,sCAAwCugB,GAGpF,OAFA4G,GAAY5G,GAAMiI,EAClBA,EAAet1B,UAAUotB,OAASC,EAC3BiI,G,aAWTC,uBACE,OAAOT,GAAcU,QAAQjyB,KAAK4wB,QAAS5wB,KAAK6wB,OAAOmB,e,yCAQ3DrB,GAAUl0B,UAAUy1B,SAAU,E,IAiBjBpB,GAEX,SAAY5jB,EAAOC,GAGjBnN,KAAKkN,MAAQA,EAGblN,KAAKmN,IAAMA,GAQFokB,GAAa,YAGxB,WAAYX,EAASC,Q,UAAQD,GAC3Bnd,OAAK,KAACmd,EAASC,G,gIAMjBpf,EAAI0gB,QAAAz2B,IAAA,WAAY,OAAOsE,KAAK4wB,QAAQvpB,KAAOrH,KAAK6wB,MAAMxpB,IAAMrH,KAAK6wB,MAAQ,MAEzEU,EAAFA,UAAEhrB,IAAA,SAAI2J,EAAKkY,GACPrhB,IAAI8pB,EAAQ3gB,EAAItP,QAAQwnB,EAAQ7hB,IAAIvG,KAAK8d,OACzC,IAAK+S,EAAMzpB,OAAO2J,cAAe,OAAO4f,EAAUc,KAAKZ,GACvD9pB,IAAI6pB,EAAU1gB,EAAItP,QAAQwnB,EAAQ7hB,IAAIvG,KAAK+wB,SAC3C,OAAO,IAAIQ,EAAcX,EAAQxpB,OAAO2J,cAAgB6f,EAAUC,EAAOA,IAG3EU,EAAFA,UAAEtkB,QAAA,SAAQ+jB,EAAIxrB,GAEV,Q,UAFoBsH,EAAM/D,OAC1B0K,YAAMxG,QAAAjS,KAAO,KAACg2B,EAAIxrB,GACdA,GAAWsH,EAAM/D,MAAO,CAC1BhC,IAAI0F,EAAQzM,KAAKkN,MAAMwD,YAAY1Q,KAAKmN,KACpCV,GAAOukB,EAAGoB,YAAY3lB,KAI9B8kB,EAAFA,UAAEnoB,GAAA,SAAGd,GACD,OAAOA,aAAiBipB,GAAiBjpB,EAAMyoB,QAAU/wB,KAAK+wB,QAAUzoB,EAAMwV,MAAQ9d,KAAK8d,MAG7FyT,EAAFA,UAAES,YAAA,WACE,OAAO,IAAIK,GAAaryB,KAAK+wB,OAAQ/wB,KAAK8d,OAG5CyT,EAAFA,UAAExmB,OAAA,WACE,MAAO,CAACtL,KAAM,OAAQsxB,OAAQ/wB,KAAK+wB,OAAQjT,KAAM9d,KAAK8d,OAGxDyT,EAAOvmB,SAAA,SAASkF,EAAK1D,GACnB,GAA0B,iBAAfA,EAAKukB,QAA0C,iBAAbvkB,EAAKsR,KAChD,MAAM,IAAIvU,WAAW,4CACvB,OAAO,IAAIgoB,EAAcrhB,EAAItP,QAAQ4L,EAAKukB,QAAS7gB,EAAItP,QAAQ4L,EAAKsR,QAKtEyT,EAAOp1B,OAAA,SAAO+T,EAAK6gB,EAAQjT,Q,UAAOiT,GAChChqB,IAAI6pB,EAAU1gB,EAAItP,QAAQmwB,GAC1B,OAAO,IAAI/wB,KAAK4wB,EAAS9S,GAAQiT,EAASH,EAAU1gB,EAAItP,QAAQkd,KAUlEyT,EAAOU,QAAA,SAAQrB,EAASC,EAAOa,GAC7B3qB,IAAIurB,EAAO1B,EAAQvpB,IAAMwpB,EAAMxpB,IAE/B,GADKqqB,IAAQY,IAAMZ,EAAOY,GAAQ,EAAI,GAAK,IACtCzB,EAAMzpB,OAAO2J,cAAe,CAC/BhK,IAAIrB,EAAQirB,EAAUS,SAASP,EAAOa,GAAM,IAASf,EAAUS,SAASP,GAAQa,GAAM,GACtF,IAAIhsB,EACC,OAAOirB,EAAUc,KAAKZ,EAAOa,GADvBb,EAAQnrB,EAAMmrB,MAW3B,OARKD,EAAQxpB,OAAO2J,gBACN,GAARuhB,IAGF1B,GAAWD,EAAUS,SAASR,GAAUc,GAAM,IAASf,EAAUS,SAASR,EAASc,GAAM,IAAOd,SACnFvpB,IAAMwpB,EAAMxpB,KAASirB,EAAO,KAHzC1B,EAAUC,GAMP,IAAIU,EAAcX,EAASC,I,yCA3EZ,CAASF,IA+EnCA,GAAU9G,OAAO,OAAQ0H,IAEzB,IAAMc,GACJ,SAAYtB,EAAQjT,GAClB9d,KAAK+wB,OAASA,EACd/wB,KAAK8d,KAAOA,G,aAEdvX,aAAI6hB,GACF,OAAO,IAAIiK,GAAajK,EAAQ7hB,IAAIvG,KAAK+wB,QAAS3I,EAAQ7hB,IAAIvG,KAAK8d,Q,aAErEld,iBAAQsP,GACN,OAAOqhB,GAAcU,QAAQ/hB,EAAItP,QAAQZ,KAAK+wB,QAAS7gB,EAAItP,QAAQZ,KAAK8d,Q,IAS/DyU,GAAa,YAIxB,WAAYvH,GACVjkB,IAAImB,EAAO8iB,EAAKnc,UACZhB,EAAOmd,EAAK9iB,KAAK,GAAGtH,QAAQoqB,EAAK3jB,IAAMa,EAAKlB,UAChDyM,OAAK,KAACuX,EAAMnd,GAEZ7N,KAAKkI,KAAOA,E,8FAGdqqB,EAAFA,UAAEhsB,IAAA,SAAI2J,EAAKkY,GACP,IAAJ,EAAyBA,EAAQpB,UAAUhnB,KAAK+wB,QAAvCtK,EAAA,EAAAA,QAASpf,EAAA,EAAAA,IACV2jB,EAAO9a,EAAItP,QAAQyG,GACvB,OAAIof,EAAgBkK,EAAUc,KAAKzG,GAC5B,IAAIuH,EAAcvH,IAG3BuH,EAAFA,UAAE/sB,QAAA,WACE,OAAO,IAAIsH,EAAMhG,EAASN,KAAKxG,KAAKkI,MAAO,EAAG,IAGhDqqB,EAAFA,UAAEnpB,GAAA,SAAGd,GACD,OAAOA,aAAiBiqB,GAAiBjqB,EAAMyoB,QAAU/wB,KAAK+wB,QAGhEwB,EAAFA,UAAExnB,OAAA,WACE,MAAO,CAACtL,KAAM,OAAQsxB,OAAQ/wB,KAAK+wB,SAGrCwB,EAAFA,UAAEP,YAAA,WAAgB,OAAO,IAAIQ,GAAaxyB,KAAK+wB,SAE7CwB,EAAOvnB,SAAA,SAASkF,EAAK1D,GACnB,GAA0B,iBAAfA,EAAKukB,OACd,MAAM,IAAIxnB,WAAW,4CACvB,OAAO,IAAIgpB,EAAcriB,EAAItP,QAAQ4L,EAAKukB,UAK5CwB,EAAOp2B,OAAA,SAAO+T,EAAK1J,GACjB,OAAO,IAAIxG,KAAKkQ,EAAItP,QAAQ4F,KAM9B+rB,EAAOE,aAAA,SAAavqB,GAClB,OAAQA,EAAKC,SAAwC,IAA9BD,EAAKzI,KAAKmQ,KAAK8iB,Y,EAjDhB,CAAS/B,IAqDnC4B,GAAc91B,UAAUy1B,SAAU,EAElCvB,GAAU9G,OAAO,OAAQ0I,IAEzB,IAAMC,GACJ,SAAYzB,GACV/wB,KAAK+wB,OAASA,G,aAEhBxqB,aAAI6hB,GACJ,IAAF,EAAyBA,EAAQpB,UAAUhnB,KAAK+wB,QAAvCtK,EAAA,EAAAA,QAASpf,EAAA,EAAAA,IACd,OAAOof,EAAU,IAAI4L,GAAahrB,EAAKA,GAAO,IAAImrB,GAAanrB,I,aAEjEzG,iBAAQsP,GACNnJ,IAAIikB,EAAO9a,EAAItP,QAAQZ,KAAK+wB,QAAS7oB,EAAO8iB,EAAKnc,UACjD,OAAI3G,GAAQqqB,GAAcE,aAAavqB,GAAc,IAAIqqB,GAAcvH,GAChE2F,GAAUc,KAAKzG,I,IAQb2G,GAAY,YAGvB,WAAYzhB,GACVuD,OAAK,KAACvD,EAAItP,QAAQ,GAAIsP,EAAItP,QAAQsP,EAAI1K,QAAQiB,O,8FAGhDkrB,EAAFA,UAAE1kB,QAAA,SAAQ+jB,EAAIxrB,GACV,Q,UADoBsH,EAAM/D,OACtBvD,GAAWsH,EAAM/D,MAAO,CAC1BioB,EAAE,OAAQ,EAAGA,EAAG9gB,IAAI1K,QAAQiB,MAC5BM,IAAI4rB,EAAMhC,EAAUiB,QAAQZ,EAAG9gB,KAC1ByiB,EAAIvpB,GAAG4nB,EAAG4B,YAAY5B,EAAG6B,aAAaF,QAE3Clf,YAAMxG,QAAAjS,KAAO,KAACg2B,EAAIxrB,IAItBmsB,EAAFA,UAAE5mB,OAAA,WAAW,MAAO,CAACtL,KAAM,QAEzBkyB,EAAO3mB,SAAA,SAASkF,GAAO,OAAO,IAAIyhB,EAAazhB,IAE/CyhB,EAAFA,UAAEprB,IAAA,SAAI2J,GAAO,OAAO,IAAIyhB,EAAazhB,IAEnCyhB,EAAFA,UAAEvoB,GAAA,SAAGd,GAAS,OAAOA,aAAiBqpB,GAEpCA,EAAFA,UAAEK,YAAA,WAAgB,OAAOc,I,EAzBA,CAASnC,IA4BlCA,GAAU9G,OAAO,MAAO8H,IAExBjmB,IAAMonB,GAAc,CAClBvsB,eAAQ,OAAOvG,MACfY,iBAAQsP,GAAO,OAAO,IAAIyhB,GAAazhB,KAQzC,SAASshB,GAAgBthB,EAAKhI,EAAMb,EAAK4B,EAAOooB,EAAKrpB,GACnD,GAAIE,EAAK6I,cAAe,OAAOwgB,GAAcp1B,OAAO+T,EAAK7I,GACzD,IAAKN,IAAIlM,EAAIoO,GAASooB,EAAM,EAAI,EAAI,GAAIA,EAAM,EAAIx2B,EAAIqN,EAAKoB,WAAazO,GAAK,EAAGA,GAAKw2B,EAAK,CACxFtqB,IAAIO,EAAQY,EAAKZ,MAAMzM,GACvB,GAAKyM,EAAMgL,QAGJ,IAAKtK,GAAQuqB,GAAcE,aAAanrB,GAC7C,OAAOirB,GAAcp2B,OAAO+T,EAAK7I,GAAOgqB,EAAM,EAAI/pB,EAAMN,SAAW,QAJlD,CACjBD,IAAIgD,EAAQynB,GAAgBthB,EAAK5I,EAAOD,EAAMgqB,EAAKA,EAAM,EAAI/pB,EAAMgC,WAAa,EAAG+nB,EAAKrpB,GACxF,GAAI+B,EAAO,OAAOA,EAIpB1C,GAAOC,EAAMN,SAAWqqB,GAI5B,SAASF,GAAwBH,EAAI+B,EAAUrB,GAC7C3qB,IAAIwB,EAAOyoB,EAAGnI,MAAMpmB,OAAS,EAC7B,KAAI8F,EAAOwqB,GAAX,CACAhsB,IAEiCQ,EAF7ByhB,EAAOgI,EAAGnI,MAAMtgB,GACpB,GAAMygB,aAAgBoB,IAAepB,aAAgBsB,GAC3C0G,EAAG5I,QAAQP,KAAKtf,GACtBhI,SAAO,SAAEyyB,EAAOC,EAAKC,EAAUC,GAAuB,MAAP5rB,IAAaA,EAAM4rB,MACtEnC,EAAG6B,aAAalC,GAAUc,KAAKT,EAAG9gB,IAAItP,QAAQ2G,GAAMmqB,KCpdtDhmB,IAmBa0nB,GAAW,YACtB,WAAY10B,GACV+U,OAAK,KAAC/U,EAAMwR,KAIZlQ,KAAKqzB,KAAOC,KAAKC,MACjBvzB,KAAKwzB,aAAe90B,EAAMk0B,UAE1B5yB,KAAKyzB,gBAAkB,EAGvBzzB,KAAK0zB,YAAch1B,EAAMg1B,YAGzB1zB,KAAK2zB,QAAU,EAEf3zB,KAAK4zB,KAAOr4B,OAAOY,OAAO,M,iQAQ5BkN,EAAIupB,UAAAl3B,IAAA,WAKF,OAJIsE,KAAKyzB,gBAAkBzzB,KAAK6oB,MAAMpmB,SACpCzC,KAAKwzB,aAAexzB,KAAKwzB,aAAajtB,IAAIvG,KAAKkQ,IAAKlQ,KAAKooB,QAAQxkB,MAAM5D,KAAKyzB,kBAC5EzzB,KAAKyzB,gBAAkBzzB,KAAK6oB,MAAMpmB,QAE7BzC,KAAKwzB,cAMdJ,EAAFA,UAAEP,aAAA,SAAaD,GACX,GAAIA,EAAU1lB,MAAMgD,KAAOlQ,KAAKkQ,IAC9B,MAAM,IAAI3G,WAAW,uEAKvB,OAJAvJ,KAAKwzB,aAAeZ,EACpB5yB,KAAKyzB,gBAAkBzzB,KAAK6oB,MAAMpmB,OAClCzC,KAAK2zB,SAAyC,GA5D9B,EA4DA3zB,KAAK2zB,SACrB3zB,KAAK0zB,YAAc,KACZ1zB,MAKTqJ,EAAIwqB,aAAAn4B,IAAA,WACF,OApEgB,EAoERsE,KAAK2zB,SAAyB,GAKxCP,EAAFA,UAAEU,eAAA,SAAernB,GAGb,OAFAzM,KAAK0zB,YAAcjnB,EACnBzM,KAAK2zB,SA3E8B,EA4E5B3zB,MAOTozB,EAAFA,UAAEhB,YAAA,SAAY3lB,GAGV,OAFKZ,EAAKa,QAAQ1M,KAAK0zB,aAAe1zB,KAAK4yB,UAAU1lB,MAAMT,QAASA,IAClEzM,KAAK8zB,eAAernB,GACfzM,MAKTozB,EAAFA,UAAEW,cAAA,SAAchxB,GACZ,OAAO/C,KAAKoyB,YAAYrvB,EAAKiJ,SAAShM,KAAK0zB,aAAe1zB,KAAK4yB,UAAU/B,MAAMpkB,WAKjF2mB,EAAFA,UAAEY,iBAAA,SAAiBjxB,GACf,OAAO/C,KAAKoyB,YAAYrvB,EAAKsJ,cAAcrM,KAAK0zB,aAAe1zB,KAAK4yB,UAAU/B,MAAMpkB,WAKtFpD,EAAI4qB,eAAAv4B,IAAA,WACF,OAxGmC,EAwG3BsE,KAAK2zB,SAA2B,GAG1CP,EAAFA,UAAEjK,QAAA,SAAQH,EAAM9Y,GACZuD,YAAM0V,QAAAnuB,KAAO,KAACguB,EAAM9Y,GACpBlQ,KAAK2zB,SAAyB,EAAf3zB,KAAK2zB,QACpB3zB,KAAK0zB,YAAc,MAKrBN,EAAFA,UAAEc,QAAA,SAAQb,GAEN,OADArzB,KAAKqzB,KAAOA,EACLrzB,MAKTozB,EAAFA,UAAEe,iBAAA,SAAiBvwB,GAEf,OADA5D,KAAK4yB,UAAU3lB,QAAQjN,KAAM4D,GACtB5D,MAOTozB,EAAFA,UAAEgB,qBAAA,SAAqBlsB,EAAMmsB,GACzBttB,IAAI6rB,EAAY5yB,KAAK4yB,UAIrB,OAHqB,IAAjByB,IACFnsB,EAAOA,EAAKnF,KAAK/C,KAAK0zB,cAAgBd,EAAU7pB,MAAQ6pB,EAAU1lB,MAAMT,QAAWmmB,EAAU1lB,MAAMwD,YAAYkiB,EAAUzlB,MAAQtB,EAAKe,QACxIgmB,EAAUxG,YAAYpsB,KAAMkI,GACrBlI,MAKTozB,EAAFA,UAAEkB,gBAAA,WAEE,OADAt0B,KAAK4yB,UAAU3lB,QAAQjN,MAChBA,MAMTozB,EAAFA,UAAEmB,WAAA,SAAWvsB,EAAMxB,EAAMU,Q,UAAKV,GAC1BO,IAAIkE,EAASjL,KAAKkQ,IAAIzQ,KAAKwL,OAC3B,GAAY,MAARzE,EACF,OAAKwB,EACEhI,KAAKo0B,qBAAqBnpB,EAAOjD,KAAKA,IAAO,GADlChI,KAAKs0B,kBAGvB,IAAKtsB,EAAM,OAAOhI,KAAK0vB,YAAYlpB,EAAMU,GACzCH,IAAI0F,EAAQzM,KAAK0zB,YACjB,IAAKjnB,EAAO,CACV1F,IAAImG,EAAQlN,KAAKkQ,IAAItP,QAAQ4F,GAC7BiG,EAAQvF,GAAMV,EAAO0G,EAAMT,QAAUS,EAAMwD,YAAY1Q,KAAKkQ,IAAItP,QAAQsG,IAI1E,OAFAlH,KAAKswB,iBAAiB9pB,EAAMU,EAAI+D,EAAOjD,KAAKA,EAAMyE,IAC7CzM,KAAK4yB,UAAU7pB,OAAO/I,KAAK6yB,aAAalC,GAAUc,KAAKzxB,KAAK4yB,UAAUzlB,MACpEnN,MAOXozB,EAAFA,UAAEoB,QAAA,SAAQp4B,EAAKN,GAEX,OADAkE,KAAK4zB,KAAmB,iBAAPx3B,EAAkBA,EAAMA,EAAIA,KAAON,EAC7CkE,MAKTozB,EAAFA,UAAEqB,QAAA,SAAQr4B,GACN,OAAO4D,KAAK4zB,KAAmB,iBAAPx3B,EAAkBA,EAAMA,EAAIA,MAMtDiN,EAAIqrB,UAAAh5B,IAAA,WACF,IAAKqL,IAAIwF,KAAKvM,KAAK4zB,KAAM,OAAO,EAChC,OAAO,GAMTR,EAAFA,UAAEuB,eAAA,WAEE,OADA30B,KAAK2zB,SAjMkD,EAkMhD3zB,MAGTqJ,EAAIurB,iBAAAl5B,IAAA,WACF,OAtMuD,EAsM/CsE,KAAK2zB,SAA4B,G,yCAnLrB,CAAS/K,IClBjC,SAASvsB,GAAKgK,EAAGnI,GACf,OAAQA,GAASmI,EAAQA,EAAEhK,KAAK6B,GAAXmI,EAGvB,IAAMwuB,GACJ,SAAYz5B,EAAM05B,EAAM52B,GACtB8B,KAAK5E,KAAOA,EACZ4E,KAAK+0B,KAAO14B,GAAKy4B,EAAKC,KAAM72B,GAC5B8B,KAAKsF,MAAQjJ,GAAKy4B,EAAKxvB,MAAOpH,IAI5B82B,GAAa,CACjB,IAAIH,GAAU,MAAO,CACnBE,cAAKE,GAAU,OAAOA,EAAO/kB,KAAO+kB,EAAOhqB,OAAO+O,YAAYzD,iBAC9DjR,eAAM0rB,GAAM,OAAOA,EAAG9gB,OAGxB,IAAI2kB,GAAU,YAAa,CACzBE,cAAKE,EAAQxb,GAAY,OAAOwb,EAAOrC,WAAajC,GAAUiB,QAAQnY,EAASvJ,MAC/E5K,eAAM0rB,GAAM,OAAOA,EAAG4B,aAGxB,IAAIiC,GAAU,cAAe,CAC3BE,cAAKE,GAAU,OAAOA,EAAOvB,aAAe,MAC5CpuB,eAAM0rB,EAAIkE,EAAQC,EAAMz2B,GAAS,OAAOA,EAAMk0B,UAAUT,QAAUnB,EAAG0C,YAAc,QAGrF,IAAImB,GAAU,oBAAqB,CACjCE,gBAAS,OAAO,GAChBzvB,eAAM0rB,EAAIttB,GAAQ,OAAOstB,EAAG4D,iBAAmBlxB,EAAO,EAAIA,MAMxD0xB,GACJ,SAAYnqB,EAAQoqB,G,WAClBr1B,KAAKiL,OAASA,EACdjL,KAAKs1B,OAASN,GAAWhvB,SACzBhG,KAAKq1B,QAAU,GACfr1B,KAAKu1B,aAAeh6B,OAAOY,OAAO,MAC9Bk5B,GAASA,EAAQ90B,SAAO,SAACi1B,GAC3B,GAAIx1B,EAAKu1B,aAAaC,EAAOp5B,KAC3B,MAAM,IAAImN,WAAW,iDAAmDisB,EAAOp5B,IAAM,KACvF4D,EAAKq1B,QAAQnzB,KAAKszB,GAClBx1B,EAAKu1B,aAAaC,EAAOp5B,KAAOo5B,EAC5BA,EAAO5lB,KAAKlR,OACdsB,EAAKs1B,OAAOpzB,KAAK,IAAI2yB,GAAUW,EAAOp5B,IAAKo5B,EAAO5lB,KAAKlR,MAAO82B,QAYzDC,GACX,SAAYR,GACVj1B,KAAKi1B,OAASA,G,6EAehB5rB,GAAI4B,OAAAvP,IAAA,WACF,OAAOsE,KAAKi1B,OAAOhqB,QAKrB5B,GAAIgsB,QAAA35B,IAAA,WACF,OAAOsE,KAAKi1B,OAAOI,S,aAKrB/vB,eAAM0rB,GACJ,OAAOhxB,KAAK01B,iBAAiB1E,GAAItyB,O,aAInCi3B,2BAAkB3E,EAAItP,Q,WAAU,GAC9B,IAAK3a,IAAIlM,EAAI,EAAGA,EAAImF,KAAKi1B,OAAOI,QAAQ5yB,OAAQ5H,IAAK,GAAIA,GAAK6mB,EAAQ,CACpE3a,IAAIyuB,EAASx1B,KAAKi1B,OAAOI,QAAQx6B,GACjC,GAAI26B,EAAO5lB,KAAK+lB,oBAAsBH,EAAO5lB,KAAK+lB,kBAAkB36B,KAAKw6B,EAAQxE,EAAIhxB,MACnF,OAAO,EAEX,OAAO,G,aAST01B,0BAAiBE,GACf,IAAK51B,KAAK21B,kBAAkBC,GAAS,MAAO,CAACl3B,MAAOsB,KAAM61B,aAAc,IAMjE,IAJP9uB,IAAI+uB,EAAM,CAACF,GAASG,EAAW/1B,KAAKg2B,WAAWJ,GAAS1f,EAAO,OAI/C,CAEd,IADAnP,IAAIkvB,GAAU,EACLp7B,EAAI,EAAGA,EAAImF,KAAKi1B,OAAOI,QAAQ5yB,OAAQ5H,IAAK,CACnDkM,IAAIyuB,EAASx1B,KAAKi1B,OAAOI,QAAQx6B,GACjC,GAAI26B,EAAO5lB,KAAKsmB,kBAAmB,CACjCnvB,IAAIzK,EAAI4Z,EAAOA,EAAKrb,GAAGyB,EAAI,EAAG65B,EAAWjgB,EAAOA,EAAKrb,GAAG6D,MAAQsB,KAC5DgxB,EAAK10B,EAAIw5B,EAAIrzB,QACb+yB,EAAO5lB,KAAKsmB,kBAAkBl7B,KAAKw6B,EAAQl5B,EAAIw5B,EAAIlyB,MAAMtH,GAAKw5B,EAAKK,EAAUJ,GACjF,GAAI/E,GAAM+E,EAASJ,kBAAkB3E,EAAIn2B,GAAI,CAE3C,GADAm2B,EAAGwD,QAAQ,sBAAuBoB,IAC7B1f,EAAM,CACTA,EAAO,GACP,IAAKnP,IAAI+C,EAAI,EAAGA,EAAI9J,KAAKi1B,OAAOI,QAAQ5yB,OAAQqH,IAC9CoM,EAAKhU,KAAK4H,EAAIjP,EAAI,CAAC6D,MAAOq3B,EAAUz5B,EAAGw5B,EAAIrzB,QAAU,CAAC/D,MAAOsB,KAAM1D,EAAG,IAE1Ew5B,EAAI5zB,KAAK8uB,GACT+E,EAAWA,EAASC,WAAWhF,GAC/BiF,GAAU,EAER/f,IAAMA,EAAKrb,GAAK,CAAC6D,MAAOq3B,EAAUz5B,EAAGw5B,EAAIrzB,UAGjD,IAAKwzB,EAAS,MAAO,CAACv3B,MAAOq3B,EAAUF,aAAcC,K,aAKzDE,oBAAWhF,GACT,IAAKA,EAAG5gB,OAAOhH,GAAGpJ,KAAKkQ,KAAM,MAAM,IAAI3G,WAAW,qCAElD,IADAxC,IAAIqvB,EAAc,IAAIX,GAAYz1B,KAAKi1B,QAASK,EAASt1B,KAAKi1B,OAAOK,OAC5Dz6B,EAAI,EAAGA,EAAIy6B,EAAO7yB,OAAQ5H,IAAK,CACtCkM,IAAIsvB,EAAQf,EAAOz6B,GACnBu7B,EAAYC,EAAMj7B,MAAQi7B,EAAM/wB,MAAM0rB,EAAIhxB,KAAKq2B,EAAMj7B,MAAO4E,KAAMo2B,GAEpE,IAAKrvB,IAAIlM,EAAI,EAAGA,EAAIy7B,GAAe7zB,OAAQ5H,IAAKy7B,GAAez7B,GAAGmF,KAAMgxB,EAAIoF,GAC5E,OAAOA,GAKT/sB,GAAI2nB,GAAAt1B,IAAA,WAAO,OAAO,IAAI03B,GAAYpzB,OAqBlCy1B,GAAOt5B,OAAA,SAAO84B,GAGZ,IAFAluB,IAAIwvB,EAAU,IAAInB,GAAcH,EAAO/kB,IAAM+kB,EAAO/kB,IAAIzQ,KAAKwL,OAASgqB,EAAOhqB,OAAQgqB,EAAOI,SACxF5b,EAAW,IAAIgc,GAAYc,GACtB17B,EAAI,EAAGA,EAAI07B,EAAQjB,OAAO7yB,OAAQ5H,IACzC4e,EAAS8c,EAAQjB,OAAOz6B,GAAGO,MAAQm7B,EAAQjB,OAAOz6B,GAAGk6B,KAAKE,EAAQxb,GACpE,OAAOA,G,aAeT+c,qBAAYvB,GAGV,IAFAluB,IAAIwvB,EAAU,IAAInB,GAAcp1B,KAAKiL,OAAQgqB,EAAOI,SAChDC,EAASiB,EAAQjB,OAAQ7b,EAAW,IAAIgc,GAAYc,GAC/C17B,EAAI,EAAGA,EAAIy6B,EAAO7yB,OAAQ5H,IAAK,CACtCkM,IAAI3L,EAAOk6B,EAAOz6B,GAAGO,KACrBqe,EAASre,GAAQ4E,KAAKtD,eAAetB,GAAQ4E,KAAK5E,GAAQk6B,EAAOz6B,GAAGk6B,KAAKE,EAAQxb,GAEnF,OAAOA,G,aAST1O,gBAAO0rB,GACL1vB,IAAIhG,EAAS,CAACmP,IAAKlQ,KAAKkQ,IAAInF,SAAU6nB,UAAW5yB,KAAK4yB,UAAU7nB,UAEhE,GADI/K,KAAK0zB,cAAa3yB,EAAO2yB,YAAc1zB,KAAK0zB,YAAYntB,KAAG,SAACtL,GAAA,OAAKA,EAAE8P,aACnE0rB,GAAuC,iBAAhBA,EAA0B,IAAK1vB,IAAIH,KAAQ6vB,EAAc,CAClF,GAAY,OAAR7vB,GAAyB,aAARA,EACnB,MAAM,IAAI2C,WAAW,sDACvBxC,IAAIyuB,EAASiB,EAAa7vB,GAAOlI,EAAQ82B,EAAO5lB,KAAKlR,MACjDA,GAASA,EAAMqM,SAAQhK,EAAO6F,GAAQlI,EAAMqM,OAAO/P,KAAKw6B,EAAQx1B,KAAKw1B,EAAOp5B,OAElF,OAAO2E,GAiBT00B,GAAOzqB,SAAA,SAASiqB,EAAQzoB,EAAMiqB,GAC5B,IAAKjqB,EAAM,MAAM,IAAIjD,WAAW,0CAChC,IAAK0rB,EAAOhqB,OAAQ,MAAM,IAAI1B,WAAW,0CACzCxC,IAAIwvB,EAAU,IAAInB,GAAcH,EAAOhqB,OAAQgqB,EAAOI,SAClD5b,EAAW,IAAIgc,GAAYc,GAqB/B,OApBAA,EAAQjB,OAAO/0B,SAAO,SAAC81B,GACrB,GAAkB,OAAdA,EAAMj7B,KACRqe,EAASvJ,IAAMyB,EAAK3G,SAASiqB,EAAOhqB,OAAQuB,EAAK0D,UAC5C,GAAkB,aAAdmmB,EAAMj7B,KACfqe,EAASmZ,UAAYjC,GAAU3lB,SAASyO,EAASvJ,IAAK1D,EAAKomB,gBACtD,GAAkB,eAAdyD,EAAMj7B,KACXoR,EAAKknB,cAAaja,EAASia,YAAclnB,EAAKknB,YAAYntB,IAAI0uB,EAAOhqB,OAAOqI,mBAC3E,CACL,GAAImjB,EAAc,IAAK1vB,IAAIH,KAAQ6vB,EAAc,CAC/C1vB,IAAIyuB,EAASiB,EAAa7vB,GAAOlI,EAAQ82B,EAAO5lB,KAAKlR,MACrD,GAAI82B,EAAOp5B,KAAOi6B,EAAMj7B,MAAQsD,GAASA,EAAMsM,UAC3CzP,OAAOkB,UAAUC,eAAe1B,KAAKwR,EAAM5F,GAG7C,YADA6S,EAAS4c,EAAMj7B,MAAQsD,EAAMsM,SAAShQ,KAAKw6B,EAAQP,EAAQzoB,EAAK5F,GAAO6S,IAI3EA,EAAS4c,EAAMj7B,MAAQi7B,EAAMtB,KAAKE,EAAQxb,OAGvCA,GASTgc,GAAOiB,iBAAA,SAAiBrwB,GACtBiwB,GAAep0B,KAAKmE,IAEtBovB,GAAOkB,oBAAA,SAAoBtwB,GACzBU,IAAIrB,EAAQ4wB,GAAezhB,QAAQxO,GAC/BX,GAAS,GAAG4wB,GAAexwB,OAAOJ,EAAO,I,yCAIjDgG,IAAM4qB,GAAiB,G,IChOVM,GAGX,SAAYhnB,GAGV5P,KAAK62B,MAAQ,GACTjnB,EAAKinB,OApBb,SAASC,EAAUn5B,EAAKO,EAAMuQ,GAC5B,IAAK1H,IAAIH,KAAQjJ,EAAK,CACpBoJ,IAAIkJ,EAAMtS,EAAIiJ,GACVqJ,aAAenL,SAAUmL,EAAMA,EAAI5T,KAAK6B,GAC3B,mBAAR0I,IAA2BqJ,EAAM6mB,EAAU7mB,EAAK/R,EAAM,KAC/DuQ,EAAO7H,GAAQqJ,EAEjB,OAAOxB,EAaWqoB,CAAUlnB,EAAKinB,MAAO72B,KAAMA,KAAK62B,OAGjD72B,KAAK4P,KAAOA,EACZ5P,KAAK5D,IAAMwT,EAAKxT,IAAMwT,EAAKxT,IAAIA,IAAM26B,GAAU,W,aAKjDC,kBAASt4B,GAAS,OAAOA,EAAMsB,KAAK5D,MA6BtCsP,IAAMpI,GAAO/H,OAAOY,OAAO,MAE3B,SAAS46B,GAAU37B,GACjB,OAAIA,KAAQkI,GAAalI,EAAO,OAAQkI,GAAKlI,IAC7CkI,GAAKlI,GAAQ,EACNA,EAAO,K,IAOH67B,GAGX,SAAY77B,Q,UAAO,OAAS4E,KAAK5D,IAAM26B,GAAU37B,ICrH5C,SAASk5B,GAAgB51B,EAAOw4B,GACrC,OAAIx4B,EAAMk0B,UAAU7pB,QAChBmuB,GAAUA,EAASx4B,EAAMsyB,GAAGsD,kBAAkBK,mBAC3C,GAyDT,SAASwC,GAAYjvB,EAAMkvB,EAAMC,GAC/B,KAAOnvB,EAAMA,EAAgB,SAARkvB,EAAkBlvB,EAAKQ,WAAaR,EAAKM,UAAY,CACxE,GAAIN,EAAKmK,YAAa,OAAO,EAC7B,GAAIglB,GAA2B,GAAnBnvB,EAAKoB,WAAiB,OAAO,EAE3C,OAAO,EAyBT,SAASguB,GAActM,GACrB,IAAKA,EAAK5jB,OAAO3H,KAAKmQ,KAAKC,UAAW,IAAK9I,IAAIlM,EAAImwB,EAAK5d,MAAQ,EAAGvS,GAAK,EAAGA,IAAK,CAC9E,GAAImwB,EAAK/hB,MAAMpO,GAAK,EAAG,OAAOmwB,EAAK9a,IAAItP,QAAQoqB,EAAK5a,OAAOvV,EAAI,IAC/D,GAAImwB,EAAK9iB,KAAKrN,GAAG4E,KAAKmQ,KAAKC,UAAW,MAExC,OAAO,KAuET,SAAS0nB,GAAavM,GACpB,IAAKA,EAAK5jB,OAAO3H,KAAKmQ,KAAKC,UAAW,IAAK9I,IAAIlM,EAAImwB,EAAK5d,MAAQ,EAAGvS,GAAK,EAAGA,IAAK,CAC9EkM,IAAIK,EAAS4jB,EAAK9iB,KAAKrN,GACvB,GAAImwB,EAAK/hB,MAAMpO,GAAK,EAAIuM,EAAOkC,WAAY,OAAO0hB,EAAK9a,IAAItP,QAAQoqB,EAAK3a,MAAMxV,EAAI,IAClF,GAAIuM,EAAO3H,KAAKmQ,KAAKC,UAAW,MAElC,OAAO,KA+DT,SAAS2nB,GAAe9kB,GACtB,IAAK3L,IAAIlM,EAAI,EAAGA,EAAI6X,EAAMoE,UAAWjc,IAAK,CACxC,IAAK4E,EAAQiT,EAAM4C,KAAKza,GAAnB4E,KACL,GAAIA,EAAK4S,cAAgB5S,EAAKkW,mBAAoB,OAAOlW,EAE3D,OAAO,KA2DF,SAASg4B,GAAW/4B,EAAOw4B,GAChC,IAAF,EAAqBx4B,EAAMk0B,UAApB1lB,EAAA,EAAAA,MAAOC,EAAA,EAAAA,IACZ,GAAIzO,EAAMk0B,qBAAqBL,IAAiB7zB,EAAMk0B,UAAU1qB,KAAKG,QACnE,SAAK6E,EAAMiB,eAAiB2c,GAASpsB,EAAMwR,IAAKhD,EAAM7F,QAClD6vB,GAAUA,EAASx4B,EAAMsyB,GAAG9Z,MAAMhK,EAAM7F,KAAKstB,mBAC1C,GAGT,IAAKznB,EAAM9F,OAAOiB,QAAS,OAAO,EAElC,GAAI6uB,EAAU,CACZnwB,IAAI8qB,EAAQ1kB,EAAIgB,cAAgBhB,EAAI/F,OAAO5B,QAAQiB,KAC/CuqB,EAAKtyB,EAAMsyB,IACXtyB,EAAMk0B,qBAAqBrB,IAAiB7yB,EAAMk0B,qBAAqBjB,KAAcX,EAAGsD,kBAC5FvtB,IAAImd,EAAuB,GAAfhX,EAAME,MAAa,KAAOoqB,GAAetqB,EAAMhF,MAAM,GAAGuK,eAAevF,EAAMiD,YAAY,KACjGiG,EAAQyb,GAAS3N,EAAQ,CAAC,CAACzkB,KAAMykB,IAAU,KAC3CwT,EAAM5M,GAASkG,EAAG9gB,IAAK8gB,EAAG5I,QAAQ7hB,IAAI2G,EAAM7F,KAAM,EAAG+O,GAKzD,GAJKA,GAAUshB,IAAO5M,GAASkG,EAAG9gB,IAAK8gB,EAAG5I,QAAQ7hB,IAAI2G,EAAM7F,KAAM,EAAG6c,GAAS,CAAC,CAACzkB,KAAMykB,OACpF9N,EAAQ,CAAC,CAAC3W,KAAMykB,IAChBwT,GAAM,GAEJA,IACF1G,EAAG9Z,MAAM8Z,EAAG5I,QAAQ7hB,IAAI2G,EAAM7F,KAAM,EAAG+O,IAClCyb,IAAU3kB,EAAMiB,cAAgBjB,EAAM9F,OAAO3H,MAAQykB,GAAO,CAC/Dnd,IAAI0B,EAAQuoB,EAAG5I,QAAQ7hB,IAAI2G,EAAMkD,UAAWunB,EAAS3G,EAAG9gB,IAAItP,QAAQ6H,GAChEyE,EAAMhF,MAAM,GAAGgL,eAAeykB,EAAO1uB,QAAS0uB,EAAO1uB,QAAU,EAAGib,IACpE8M,EAAG9E,cAAc8E,EAAG5I,QAAQ7hB,IAAI2G,EAAMkD,UAAW8T,GAGvDgT,EAASlG,EAAG2D,kBAEd,OAAO,EAkDT,SAASiD,GAAcl5B,EAAOm5B,EAAMX,GAClCnwB,IAAsD+wB,EAAMplB,EAAxDtC,EAASynB,EAAK/oB,WAAYuB,EAAQwnB,EAAKhpB,UAC3C,GAAIuB,EAAO3Q,KAAKmQ,KAAKC,WAAaQ,EAAM5Q,KAAKmQ,KAAKC,UAAW,OAAO,EACpE,GApBF,SAAwBnR,EAAOssB,EAAMkM,GACnCnwB,IAAIqJ,EAAS4a,EAAKlc,WAAYuB,EAAQ2a,EAAKnc,UAAW5F,EAAQ+hB,EAAK/hB,QACnE,SAAKmH,GAAWC,GAAUD,EAAO3Q,KAAK6O,kBAAkB+B,EAAM5Q,UACzD2Q,EAAO5K,QAAQiB,MAAQukB,EAAK5jB,OAAOiI,WAAWpG,EAAQ,EAAGA,IACxDiuB,GAAUA,EAASx4B,EAAMsyB,GAAN,OAAgBhG,EAAK3jB,IAAM+I,EAAOpJ,SAAUgkB,EAAK3jB,KAAKstB,mBACtE,MAEJ3J,EAAK5jB,OAAOiI,WAAWpG,EAAOA,EAAQ,KAAQoH,EAAMgC,cAAe+Y,GAAQ1sB,EAAMwR,IAAK8a,EAAK3jB,QAE5F6vB,GACFA,EAASx4B,EAAMsyB,GACLjF,kBAAkBf,EAAK3jB,IAAK+I,EAAO3Q,KAAM2Q,EAAOqC,eAAerC,EAAO9G,aACtEwB,KAAKkgB,EAAK3jB,KACVstB,mBACL,IAMHoD,CAAer5B,EAAOm5B,EAAMX,GAAW,OAAO,EAElDnwB,IAAIixB,EAAcH,EAAKzwB,OAAOiI,WAAWwoB,EAAK5uB,QAAS4uB,EAAK5uB,QAAU,GACtE,GAAI+uB,IACCF,GAAQplB,EAAQtC,EAAOqC,eAAerC,EAAO9G,aAAakN,aAAanG,EAAM5Q,QAC9EiT,EAAMS,UAAU2kB,EAAK,IAAMznB,EAAM5Q,MAAMuT,SAAU,CACnD,GAAIkkB,EAAU,CAEZ,IADAnwB,IAAIQ,EAAMswB,EAAKxwB,IAAMgJ,EAAMrJ,SAAUjJ,EAAO+I,EAASiC,MAC5ClO,EAAIi9B,EAAKr1B,OAAS,EAAG5H,GAAK,EAAGA,IACpCkD,EAAO+I,EAASN,KAAKsxB,EAAKj9B,GAAGsB,OAAO,KAAM4B,IAC5CA,EAAO+I,EAASN,KAAK4J,EAAOjH,KAAKpL,IACjCgJ,IAAIiqB,EAAKtyB,EAAMsyB,GAAGhI,KAAK,IAAIsB,GAAkBuN,EAAKxwB,IAAM,EAAGE,EAAKswB,EAAKxwB,IAAKE,EAAK,IAAIuF,EAAM/O,EAAM,EAAG,GAAI+5B,EAAKr1B,QAAQ,IAC/Gw1B,EAAS1wB,EAAM,EAAIuwB,EAAKr1B,OACxB2oB,GAAQ4F,EAAG9gB,IAAK+nB,IAASjH,EAAGlmB,KAAKmtB,GACrCf,EAASlG,EAAG2D,kBAEd,OAAO,EAGT5tB,IAAImxB,EAAWvH,GAAUS,SAASyG,EAAM,GACpChN,EAAQqN,GAAYA,EAAShrB,MAAM2D,WAAWqnB,EAAS/qB,KAAMsB,EAASoc,GAASD,GAAWC,GAC9F,GAAc,MAAVpc,GAAkBA,GAAUopB,EAAKzqB,MAEnC,OADI8pB,GAAUA,EAASx4B,EAAMsyB,GAAGzF,KAAKV,EAAOpc,GAAQkmB,mBAC7C,EAGT,GAAIqD,GAAeb,GAAY9mB,EAAO,SAAS,IAAS8mB,GAAY/mB,EAAQ,OAAQ,CAElF,IADArJ,IAAIoxB,EAAK/nB,EAAQrS,EAAO,GAEtBA,EAAKmE,KAAKi2B,IACNA,EAAG9lB,aACP8lB,EAAKA,EAAG3vB,UAGV,IADAzB,IAAIqxB,EAAY/nB,EAAOgoB,EAAa,GAC5BD,EAAU/lB,YAAa+lB,EAAYA,EAAU1vB,WAAY2vB,IACjE,GAAIF,EAAG9oB,WAAW8oB,EAAG7uB,WAAY6uB,EAAG7uB,WAAY8uB,EAAU5yB,SAAU,CAClE,GAAI0xB,EAAU,CAEZ,IADAnwB,IAAIQ,EAAMT,EAASiC,MACVlO,EAAIkD,EAAK0E,OAAS,EAAG5H,GAAK,EAAGA,IAAK0M,EAAMT,EAASN,KAAKzI,EAAKlD,GAAGsO,KAAK5B,IAI5E2vB,EAHSx4B,EAAMsyB,GAAGhI,KAAK,IAAIsB,GAAkBuN,EAAKxwB,IAAMtJ,EAAK0E,OAAQo1B,EAAKxwB,IAAMgJ,EAAMrJ,SACzC6wB,EAAKxwB,IAAMgxB,EAAYR,EAAKxwB,IAAMgJ,EAAMrJ,SAAWqxB,EACnD,IAAIvrB,EAAMvF,EAAKxJ,EAAK0E,OAAQ,GAAI,GAAG,IACpEkyB,kBAEd,OAAO,GAIX,OAAO,EAGT,SAAS2D,GAAoBlB,GAC3B,OAAO,SAAS14B,EAAOw4B,GAGrB,IAFAnwB,IAAI4rB,EAAMj0B,EAAMk0B,UAAW5H,EAAOoM,EAAO,EAAIzE,EAAIzlB,MAAQylB,EAAIxlB,IACzDC,EAAQ4d,EAAK5d,MACV4d,EAAK9iB,KAAKkF,GAAOuD,UAAU,CAChC,IAAKvD,EAAO,OAAO,EACnBA,IAEF,QAAK4d,EAAK9iB,KAAKkF,GAAOiF,cAClB6kB,GACFA,EAASx4B,EAAMsyB,GAAG6B,aAAatB,GAAcp1B,OAC3CuC,EAAMwR,IAAKknB,EAAO,EAAIpM,EAAKxjB,MAAM4F,GAAS4d,EAAKzjB,IAAI6F,OAChD,I,aDpUT1R,aAAIgD,GAAS,OAAOA,EAAMu2B,OAAOM,aAAav1B,KAAK5D,M,aAInD46B,kBAASt4B,GAAS,OAAOA,EAAMsB,KAAK5D,MCsU1B,IAACm8B,GAAuBD,IAAqB,GAI5CE,GAAqBF,GAAoB,GAwJ/C,SAASG,K,uDACd,OAAO,SAAS/5B,EAAOw4B,EAAUwB,GAC/B,IAAK3xB,IAAIlM,EAAI,EAAGA,EAAI89B,EAASl2B,OAAQ5H,IACnC,GAAI89B,EAAS99B,GAAG6D,EAAOw4B,EAAUwB,GAAO,OAAO,EACjD,OAAO,GAIX3xB,IAAI6xB,GAAYH,GAAcnE,IA1lBvB,SAAsB51B,EAAOw4B,EAAUwB,GAC5C,IAAKvG,EAAWzzB,EAAMk0B,UAAjBT,QACL,IAAKA,IAAYuG,GAAQA,EAAKG,eAAe,WAAYn6B,GACjCyzB,EAAQhkB,aAAe,GAC7C,OAAO,EAETpH,IAAI8wB,EAAOP,GAAcnF,GAGzB,IAAK0F,EAAM,CACT9wB,IAAI8jB,EAAQsH,EAAQthB,aAAcpC,EAASoc,GAASD,GAAWC,GAC/D,OAAc,MAAVpc,IACAyoB,GAAUA,EAASx4B,EAAMsyB,GAAGzF,KAAKV,EAAOpc,GAAQkmB,mBAC7C,GAGT5tB,IAAIqJ,EAASynB,EAAK/oB,WAElB,IAAKsB,EAAO3Q,KAAKmQ,KAAKC,WAAa+nB,GAAcl5B,EAAOm5B,EAAMX,GAC5D,OAAO,EAIT,GAAmC,GAA/B/E,EAAQ/qB,OAAO5B,QAAQiB,OACtB0wB,GAAY/mB,EAAQ,QAAUmiB,GAAcE,aAAariB,IAAU,CACtErJ,IAAI+xB,EAAUrM,GAAY/tB,EAAMwR,IAAKiiB,EAAQ/hB,SAAU+hB,EAAQ9hB,QAASvD,EAAM/D,OAC9E,GAAI+vB,EAAQl1B,MAAM6C,KAAOqyB,EAAQ5xB,GAAK4xB,EAAQtyB,KAAM,CAClD,GAAI0wB,EAAU,CACZnwB,IAAIiqB,EAAKtyB,EAAMsyB,GAAGhI,KAAK8P,GACvB9H,EAAG6B,aAAasE,GAAY/mB,EAAQ,OAASugB,GAAUS,SAASJ,EAAG9gB,IAAItP,QAAQowB,EAAG5I,QAAQ7hB,IAAIsxB,EAAKxwB,KAAM,KAAM,GAC7FkrB,GAAcp2B,OAAO60B,EAAG9gB,IAAK2nB,EAAKxwB,IAAM+I,EAAOpJ,WACjEkwB,EAASlG,EAAG2D,kBAEd,OAAO,GAKX,SAAIvkB,EAAOkC,QAAUulB,EAAKzqB,OAAS+kB,EAAQ/kB,MAAQ,KAC7C8pB,GAAUA,EAASx4B,EAAMsyB,GAAN,OAAgB6G,EAAKxwB,IAAM+I,EAAOpJ,SAAU6wB,EAAKxwB,KAAKstB,mBACtE,MAqBJ,SAA4Bj2B,EAAOw4B,EAAUwB,GAClD,IAAF,EAAuBh6B,EAAMk0B,UAAtB/B,EAAA,EAAAA,MAAiCgH,EAAOhH,EAC7C,IADY,EAAA9nB,MACA,OAAO,EAEnB,GAAI8nB,EAAMzpB,OAAOiL,YAAa,CAC5B,GAAIqmB,GAAQA,EAAKG,eAAe,WAAYn6B,GAASmyB,EAAM1iB,aAAe,EAAG,OAAO,EACpF0pB,EAAOP,GAAczG,GAEvB9pB,IAAImB,EAAO2vB,GAAQA,EAAK/oB,WACxB,SAAK5G,IAASqqB,GAAcE,aAAavqB,MACrCgvB,GACFA,EAASx4B,EAAMsyB,GAAG6B,aAAaN,GAAcp2B,OAAOuC,EAAMwR,IAAK2nB,EAAKxwB,IAAMa,EAAKlB,WAAW2tB,mBACrF,MAkhBLoE,GAAMN,GAAcnE,IAjgBjB,SAAqB51B,EAAOw4B,EAAUwB,GAC3C,IAAKvG,EAAWzzB,EAAMk0B,UAAjBT,QACL,IAAKA,IAAYuG,GAAQA,EAAKG,eAAe,UAAWn6B,GAChCyzB,EAAQhkB,aAAegkB,EAAQ/qB,OAAO5B,QAAQiB,MACpE,OAAO,EAETM,IAAI8wB,EAAON,GAAapF,GAGxB,IAAK0F,EAAM,OAAO,EAElB9wB,IAAIsJ,EAAQwnB,EAAKhpB,UAEjB,GAAI+oB,GAAcl5B,EAAOm5B,EAAMX,GAAW,OAAO,EAIjD,GAAmC,GAA/B/E,EAAQ/qB,OAAO5B,QAAQiB,OACtB0wB,GAAY9mB,EAAO,UAAYkiB,GAAcE,aAAapiB,IAAS,CACtEtJ,IAAI+xB,EAAUrM,GAAY/tB,EAAMwR,IAAKiiB,EAAQ/hB,SAAU+hB,EAAQ9hB,QAASvD,EAAM/D,OAC9E,GAAI+vB,EAAQl1B,MAAM6C,KAAOqyB,EAAQ5xB,GAAK4xB,EAAQtyB,KAAM,CAClD,GAAI0wB,EAAU,CACZnwB,IAAIiqB,EAAKtyB,EAAMsyB,GAAGhI,KAAK8P,GACvB9H,EAAG6B,aAAasE,GAAY9mB,EAAO,SAAWsgB,GAAUS,SAASJ,EAAG9gB,IAAItP,QAAQowB,EAAG5I,QAAQ7hB,IAAIsxB,EAAKxwB,MAAO,GACzFkrB,GAAcp2B,OAAO60B,EAAG9gB,IAAK8gB,EAAG5I,QAAQ7hB,IAAIsxB,EAAKxwB,OACnE6vB,EAASlG,EAAG2D,kBAEd,OAAO,GAKX,SAAItkB,EAAMiC,QAAUulB,EAAKzqB,OAAS+kB,EAAQ/kB,MAAQ,KAC5C8pB,GAAUA,EAASx4B,EAAMsyB,GAAN,OAAgB6G,EAAKxwB,IAAKwwB,EAAKxwB,IAAMgJ,EAAMrJ,UAAU2tB,mBACrE,MAaJ,SAA2Bj2B,EAAOw4B,EAAUwB,GACjD,IAAF,EAAuBh6B,EAAMk0B,UAAtB/B,EAAA,EAAAA,MAAiCgH,EAAOhH,EAC7C,IADY,EAAA9nB,MACA,OAAO,EACnB,GAAI8nB,EAAMzpB,OAAOiL,YAAa,CAC5B,GAAIqmB,GAAQA,EAAKG,eAAe,UAAWn6B,GAASmyB,EAAM1iB,aAAe0iB,EAAMzpB,OAAO5B,QAAQiB,KAC5F,OAAO,EACToxB,EAAON,GAAa1G,GAEtB9pB,IAAImB,EAAO2vB,GAAQA,EAAKhpB,UACxB,SAAK3G,IAASqqB,GAAcE,aAAavqB,MACrCgvB,GACFA,EAASx4B,EAAMsyB,GAAG6B,aAAaN,GAAcp2B,OAAOuC,EAAMwR,IAAK2nB,EAAKxwB,MAAMstB,mBACrE,MAmdEqE,GAAe,CACxB,MAASP,IAnZJ,SAAuB/5B,EAAOw4B,GACnC,IAAF,EAAyBx4B,EAAMk0B,UAAxB/B,EAAA,EAAAA,MAAOD,EAAA,EAAAA,QACZ,SAAKC,EAAMzpB,OAAO3H,KAAKmQ,KAAKkJ,OAAS+X,EAAM5f,WAAW2f,MAClDsG,GAAUA,EAASx4B,EAAMsyB,GAAGuD,WAAW,MAAMI,mBAC1C,MA+BF,SAA6Bj2B,EAAOw4B,GACzCnwB,IAAI4rB,EAAMj0B,EAAMk0B,UAAY1lB,EAAA,EAAAA,MAAOC,EAAA,EAAAA,IACnC,GAAIwlB,aAAehB,IAAgBzkB,EAAM9F,OAAO2J,eAAiB5D,EAAI/F,OAAO2J,cAAe,OAAO,EAClGhK,IAAItH,EAAO+3B,GAAerqB,EAAI/F,OAAOqL,eAAetF,EAAIgD,eACxD,IAAK1Q,IAASA,EAAK4S,YAAa,OAAO,EACvC,GAAI6kB,EAAU,CACZnwB,IAAIqwB,IAASlqB,EAAMiB,cAAgBhB,EAAIlE,QAAUkE,EAAI/F,OAAOkC,WAAa4D,EAAQC,GAAK9F,IAClF2pB,EAAKtyB,EAAMsyB,GAAG5hB,OAAOgoB,EAAM33B,EAAK8W,iBACpCya,EAAG6B,aAAatB,GAAcp1B,OAAO60B,EAAG9gB,IAAKknB,EAAO,IACpDF,EAASlG,EAAG2D,kBAEd,OAAO,KAMF,SAAwBj2B,EAAOw4B,GACpC,IAAK/E,EAAWzzB,EAAMk0B,UAAjBT,QACL,IAAKA,GAAWA,EAAQ/qB,OAAO5B,QAAQiB,KAAM,OAAO,EACpD,GAAI0rB,EAAQ/kB,MAAQ,GAAK+kB,EAAQ9hB,SAAW8hB,EAAQ5qB,KAAK,GAAI,CAC3DR,IAAIqJ,EAAS+hB,EAAQ/hB,SACrB,GAAI0a,GAASpsB,EAAMwR,IAAKE,GAEtB,OADI8mB,GAAUA,EAASx4B,EAAMsyB,GAAG9Z,MAAM9G,GAAQukB,mBACvC,EAGX5tB,IAAI8jB,EAAQsH,EAAQthB,aAAcpC,EAASoc,GAASD,GAAWC,GAC/D,OAAc,MAAVpc,IACAyoB,GAAUA,EAASx4B,EAAMsyB,GAAGzF,KAAKV,EAAOpc,GAAQkmB,mBAC7C,KAkVoE8C,IAC3E,YAjYK,SAAkB/4B,EAAOw4B,GAC9B,IAAF,EAAyBx4B,EAAMk0B,UAAxB/B,EAAA,EAAAA,MAAOD,EAAA,EAAAA,QACZ,IAAKC,EAAMzpB,OAAO3H,KAAKmQ,KAAKkJ,OAAS+X,EAAM5f,WAAW2f,GAAU,OAAO,EACvE7pB,IAAIkyB,EAAQpI,EAAM3oB,MAAM,GAAImI,EAAQwgB,EAAM1gB,YAAY,GAAI1Q,EAAO+3B,GAAeyB,EAAMxmB,eAAepC,IACrG,IAAK4oB,EAAM/lB,eAAe7C,EAAOA,EAAO5Q,GAAO,OAAO,EACtD,GAAIy3B,EAAU,CACZnwB,IAAIM,EAAMwpB,EAAMxgB,QAAS2gB,EAAKtyB,EAAMsyB,GAAG5E,YAAY/kB,EAAKA,EAAK5H,EAAK8W,iBAClEya,EAAG6B,aAAalC,GAAUc,KAAKT,EAAG9gB,IAAItP,QAAQyG,GAAM,IACpD6vB,EAASlG,EAAG2D,kBAEd,OAAO,GAwXP,UAAaiE,GACb,gBAAiBA,GACjB,kBAAmBA,GACnB,OAAUG,GACV,aAAcA,GACd,QAxRK,SAAmBr6B,EAAOw4B,GAE/B,OADIA,GAAUA,EAASx4B,EAAMsyB,GAAG6B,aAAa,IAAIlB,GAAajzB,EAAMwR,QAC7D,IA8REgpB,GAAgB,CACzB,SAAUF,GAAY,UACtB,gBAAiBA,GAAa,iBAC9B,SAAUA,GAAY,OACtB,qBAAsBA,GAAa,cACnC,aAAcA,GAAa,cAC3B,QAASA,GAAa,cACtB,SAAUT,GACV,SAAUC,IAEZ,IAAKzxB,IAAI3K,MAAO48B,GAAcE,GAAc98B,IAAO48B,GAAa58B,IAEhE48B,GAAaG,KAAOZ,GACpBS,GAAaI,IAAMZ,GAGnB9sB,IAOW2tB,IAPqB,oBAAbC,UAA2B,qBAAqBhiB,KAAKgiB,UAAUC,UACzD,oBAANC,IAAqC,UAAjBA,GAAGD,YAMZL,GAAgBF,G,IC7pBjCS,GAgBX,SAAY/mB,EAAOgnB,GAMrB,IAAuB1lB,EALnBhU,KAAK0S,MAAQA,EACb1S,KAAK05B,QAA4B,iBAAXA,GAIH1lB,EAJuC0lB,EAKrD,SAASh7B,EAAOgU,EAAOlL,EAAOD,GACnCR,IAAIqI,EAAS4E,EACb,GAAItB,EAAM,GAAI,CACZ3L,IAAI4E,EAAS+G,EAAM,GAAG4R,YAAY5R,EAAM,IACxCtD,GAAUsD,EAAM,GAAG9O,MAAM+H,EAAS+G,EAAM,GAAGjQ,QAE3CsE,IAAI4yB,GADJnyB,GAASmE,GACYpE,EACjBoyB,EAAS,IACXvqB,EAASsD,EAAM,GAAG9O,MAAM+H,EAASguB,EAAQhuB,GAAUyD,EACnD5H,EAAQD,GAGZ,OAAO7I,EAAMsyB,GAAGuD,WAAWnlB,EAAQ5H,EAAOD,KAjB2BmyB,GCrBnD,IAAID,GAAU,MAAO,KAEnB,IAAIA,GAAU,UAAW,KAElB,IAAIA,GAAU,uCAAwC,KAErD,IAAIA,GAAU,KAAM,KAErB,IAAIA,GAAU,uCAAwC,KAErD,IAAIA,GAAU,KAAM,K,mLCbrC,SAASG,GAAgBt+B,EAAGqB,GAMzC,OALAi9B,GAAkBr+B,OAAOyH,gBAAkB,SAAyB1H,EAAGqB,GAErE,OADArB,EAAE2H,UAAYtG,EACPrB,IAGcA,EAAGqB,GCLb,SAASk9B,GAAeC,EAAUC,GAC/CD,EAASr9B,UAAYlB,OAAOY,OAAO49B,EAAWt9B,WAC9Cq9B,EAASr9B,UAAUqG,YAAcg3B,EACjC92B,GAAe82B,EAAUC,G,0CCANC,G,iGACnBC,OAAA,SAAOC,GAAO,MACZ,YAAMD,OAAN,UAAaC,GAEbl6B,KAAKlE,MAAQq+B,IAAIC,SAAS9E,OAAO9vB,WAAa,GAE9CxF,KAAKq6B,cAAgBr6B,KAAKlE,MAAM4W,MAAM,yDACtC1S,KAAKs6B,aAAc,SAAAt6B,KAAKq6B,oBAAL,IAAoB53B,SAAU,EAKjDzC,KAAKs1B,OAAS,CACZtX,MAAOuc,KAAO,IACdC,KAAMD,KAAO,M,EAIjBE,UAAA,WACE,MAAO,I,EAGTzc,MAAA,WACE,OAAOmc,IAAIO,WAAWC,MAAM,oD,EAG9Bn1B,QAAA,WAAU,WAIR,MAAO,CACLvK,EAAE,cACAA,EAAE,kBACFA,EAAE,cACAA,EAAE,QAASk/B,IAAIO,WAAWC,MAAM,kDAChC1/B,EAAE,oBAAqB,CACrBwE,KAAM,OACN3D,MAAOkE,KAAKs1B,OAAOtX,QACnB4c,YAAa,4BACbC,UAAU,EACVC,QAAS,SAAC3Q,GACR,EAAKmL,OAAOtX,MAAMmM,EAAE1b,OAAO3S,OAC3B,EAAKi/B,qBAKX9/B,EAAE,cACAA,EAAE,QAASk/B,IAAIO,WAAWC,MAAM,iDAChC1/B,EAAE,oBAAqB,CACrBwE,KAAM,MACNm7B,YAAa,yBACb9+B,MAAOkE,KAAKs1B,OAAOkF,OACnBM,QAAS,SAAC3Q,GACR,EAAKmL,OAAOkF,KAAKrQ,EAAE1b,OAAO3S,OAC1B,EAAKi/B,qBAKTC,KAAOC,UACL,CACER,UAAW,yBACXS,QAAS,kBAAM,EAAKC,iBAEtB,gB,EAOVJ,eAAA,WAGE,IAFA,IAAMK,EAAiBp7B,KAAKq7B,EAAE,SAErBC,EAAI,EAAGA,EAAIF,EAAe34B,OAAQ64B,IACrCF,EAAeE,GAAGC,SAASC,OAC7BJ,EAAeE,GAAGG,gBAAgB,U,EAKxCC,qBAAA,WAKE,IAJA,IAAMN,EAAiBp7B,KAAKq7B,EAAE,SAC1BxgC,EAAI,EAGCygC,EAAI,EAAGA,EAAIF,EAAe34B,OAAQ64B,IACpCF,EAAeE,GAAGC,SAASC,QAC9BJ,EAAeE,GAAG7gB,MAAMkhB,YAAY,eAAgB,MAAO,aAC3D9gC,KAIJ,OAAS,GAALA,G,EAKNsgC,aAAA,WACE,GAAKn7B,KAAK07B,uBAAV,CAEA,IAAIE,EAAO,IAAItI,KAEf,GAAIz2B,OAAOg/B,WAAW,wBAAyB,CAC7C1B,IAAIC,SAAS0B,OAAOC,eAAe,iBAAkB/7B,KAAKs6B,YAAc,IAAMt6B,KAAKs6B,YAAc,UAEjG,IAAM0B,EAAW7B,IAAIC,SAAS0B,OAAOG,oBAEb,GAApBj8B,KAAKs6B,aACPH,IAAIC,SAAS0B,OAAOI,aAAa/B,IAAIC,SAAS0B,OAAOrwB,MAAM0wB,UAAUC,WAAWxhB,IAAIyhB,UAAU55B,OAAS,GACvG03B,IAAIC,SAAS0B,OAAOQ,WACpBnC,IAAIC,SAAS0B,OAAOC,eAAe,cACnC5B,IAAIC,SAAS0B,OAAOQ,aAEpBnC,IAAIC,SAAS0B,OAAOI,aAAa/B,IAAIC,SAAS0B,OAAOrwB,MAAM0wB,UAAUC,WAAWxhB,IAAIyhB,UAAU55B,OAAS,GACvG03B,IAAIC,SAAS0B,OAAOQ,YAGtBnC,IAAIC,SAAS0B,OAAOC,eAClB/7B,KAAKs6B,YACL,sBAAwBt6B,KAAKs6B,YAAc,kBAC3Ct6B,KAAKs1B,OAAOtX,QAFZhe,eAKA47B,EAAKW,UACL,KAAOX,EAAKY,WAAa,GACzB,IAAMZ,EAAKa,cACX,KACAz8B,KAAKs1B,OAAOkF,QACoB,IAA9Bx6B,KAAKs1B,OAAOkF,OAAO/3B,OAAgB,eAAiB,kBAGxD03B,IAAIC,SAAS0B,OAAOY,kBAAkBV,EAAS,GAAIA,EAAS,IAC5D7B,IAAIC,SAAS0B,OAAOQ,WACpBnC,IAAIC,SAAS0B,OAAb,aAEK,CACLa,QAAQC,IAAIzC,IAAIC,SAAS0B,OAAOe,GAAG/gC,OACnC6gC,QAAQC,IAAIzC,IAAIC,SAAS9E,OAAO9vB,WAChC20B,IAAIC,SAAS0B,OAAOC,eAAe,iBAAkB/7B,KAAKs6B,YAAc,IAAMt6B,KAAKs6B,YAAc,UAEjG,IAAM0B,EAAW7B,IAAIC,SAAS0B,OAAOG,oBAEb,GAApBj8B,KAAKs6B,aACPH,IAAIC,SAAS0B,OAAOI,aAAa/B,IAAIC,SAAS0B,OAAOe,GAAG/gC,MAAM2G,OAAS,GAEvE03B,IAAIC,SAAS0B,OAAOC,eAAe,sBAGnC5B,IAAIC,SAAS0B,OAAOI,aAAa/B,IAAIC,SAAS0B,OAAOe,GAAG/gC,MAAM2G,OAAS,GACvE03B,IAAIC,SAAS0B,OAAOC,eAAe,OAIrC5B,IAAIC,SAAS0B,OAAOC,eAClB,KACA/7B,KAAKs6B,YACL,wBAA0Bt6B,KAAKs6B,YAAc,kBAC7Ct6B,KAAKs1B,OAAOtX,QAHZ,eAMA4d,EAAKW,UACL,KAAOX,EAAKY,WAAa,GACzB,IAAMZ,EAAKa,cACX,KACAz8B,KAAKs1B,OAAOkF,QACoB,IAA9Bx6B,KAAKs1B,OAAOkF,OAAO/3B,OAAgB,eAAiB,kBAGxD03B,IAAIC,SAAS0B,OAAOY,kBAAkBV,EAAS,GAAIA,EAAS,IAO9D7B,IAAI2C,MAAMpvB,U,GAjL+BqvB,MCAxBC,G,iGACnB/C,OAAA,SAAOC,GAAO,MACZ,YAAMD,OAAN,UAAaC,GAEbl6B,KAAKlE,MAAQq+B,IAAIC,SAAS9E,OAAO9vB,WAAa,GAE9CxF,KAAKq6B,cAAgBr6B,KAAKlE,MAAM4W,MAAM,yDACtC1S,KAAKs6B,aAAc,SAAAt6B,KAAKq6B,oBAAL,IAAoB53B,SAAU,EAEjDzC,KAAKs1B,OAAS,CACZtX,MAAOuc,KAAO,IACdC,KAAMD,KAAO,IACb0C,OAAQ1C,KAAO,IACf2C,SAAU3C,KAAO,IACjB4C,SAAU5C,KAAO,M,EAIrBE,UAAA,WACE,MAAO,I,EAGTzc,MAAA,WACE,OAAOmc,IAAIO,WAAWC,MAAM,iD,EAG9Bn1B,QAAA,WAAU,WACR,MAAO,CACLvK,EAAE,cACAA,EAAE,kBACDA,EAAE,mBAAoBk/B,IAAIO,WAAWC,MAAM,uDAC1C1/B,EAAE,cACAA,EAAE,QAASk/B,IAAIO,WAAWC,MAAM,kDAChC1/B,EAAE,oBAAqB,CACrBwE,KAAM,OACN3D,MAAOkE,KAAKs1B,OAAOtX,QACnB4c,YAAa,4BACbC,UAAU,EACVC,QAAS,SAAC3Q,GACR,EAAKmL,OAAOtX,MAAMmM,EAAE1b,OAAO3S,OAC3B,EAAKi/B,qBAKX9/B,EAAE,cACAA,EAAE,QAASk/B,IAAIO,WAAWC,MAAM,iDAChC1/B,EAAE,oBAAqB,CACrBwE,KAAM,MACN3D,MAAOkE,KAAKs1B,OAAOkF,OACnBI,YAAa,yBACbC,UAAU,EACVC,QAAS,SAAC3Q,GAAM,QACd,EAAKmL,OAAOkF,KAAKrQ,EAAE1b,OAAO3S,OAC1B,EAAKw5B,OAAO6H,UAAS,SAAAhT,EAAE1b,OAAO3S,QAAT,WAAgBob,MAAM,MAAM,SAA5B,IAAgCA,MAAM,KAAK,KAAM,IACtE,EAAK6jB,qBAKX9/B,EAAE,cACAA,EAAE,QAASk/B,IAAIO,WAAWC,MAAM,mDAChC1/B,EAAE,oBAAqB,CACrBwE,KAAM,OACNm7B,YAAa,kBACbwC,KAAMp9B,KAAKs1B,OAAO2H,UAItBhiC,EAAE,cACAA,EAAE,QAASk/B,IAAIO,WAAWC,MAAM,qDAChC1/B,EAAE,oBAAqB,CACrBwE,KAAM,OACNm7B,YAAa,iBACbyC,QAAS,iUACTvhC,MAAOkE,KAAKs1B,OAAO4H,WACnBpC,QAAS,SAAC3Q,GACR,EAAKmL,OAAO4H,SAAS/S,EAAE1b,OAAO3S,OAC9B,EAAKi/B,qBAKX9/B,EAAE,cACAA,EAAE,QAASk/B,IAAIO,WAAWC,MAAM,uDAChC1/B,EAAE,oBAAqB,CACrBwE,KAAM,OACN3D,MAAOkE,KAAKs1B,OAAO6H,WACnBvC,YAAa,kBACbC,UAAU,EACVC,QAAS,SAAC3Q,GACR,EAAKmL,OAAO6H,SAAShT,EAAE1b,OAAO3S,OAC9B,EAAKi/B,qBAKXC,KAAOC,UACL,CACER,UAAW,yBACXS,QAAS,kBAAM,EAAKC,iBAEtB,gB,EAOVJ,eAAA,WAGE,IAFA,IAAMK,EAAiBp7B,KAAKq7B,EAAE,SAErBC,EAAI,EAAGA,EAAIF,EAAe34B,OAAQ64B,IACrCF,EAAeE,GAAGC,SAASC,OAC7BJ,EAAeE,GAAGG,gBAAgB,U,EAKxCC,qBAAA,WAIE,IAHA,IAAMN,EAAiBp7B,KAAKq7B,EAAE,SAC1BxgC,EAAI,EAECygC,EAAI,EAAGA,EAAIF,EAAe34B,OAAQ64B,IACpCF,EAAeE,GAAGC,SAASC,QAC9BJ,EAAeE,GAAG7gB,MAAMkhB,YAAY,eAAgB,MAAO,aAC3D9gC,KAIJ,OAAS,GAALA,G,EAKNsgC,aAAA,WACE,GAAKn7B,KAAK07B,uBAAV,CAEA,IAAIE,EAAO,IAAItI,KAEf,GAAIz2B,OAAOg/B,WAAW,wBAAyB,CAC7C1B,IAAIC,SAAS0B,OAAOC,eAAe,iBAAkB/7B,KAAKs6B,YAAc,IAAMt6B,KAAKs6B,YAAc,UAEjG,IAAM0B,EAAW7B,IAAIC,SAAS0B,OAAOG,oBAEb,GAApBj8B,KAAKs6B,aACPH,IAAIC,SAAS0B,OAAOI,aAAa/B,IAAIC,SAAS0B,OAAOrwB,MAAM0wB,UAAUC,WAAWxhB,IAAIyhB,UAAU55B,OAAS,GACvG03B,IAAIC,SAAS0B,OAAOQ,WACpBnC,IAAIC,SAAS0B,OAAOC,eAAe,cACnC5B,IAAIC,SAAS0B,OAAOQ,aAEpBnC,IAAIC,SAAS0B,OAAOI,aAAa/B,IAAIC,SAAS0B,OAAOrwB,MAAM0wB,UAAUC,WAAWxhB,IAAIyhB,UAAU55B,OAAS,GACvG03B,IAAIC,SAAS0B,OAAOQ,YAGtBnC,IAAIC,SAAS0B,OAAOC,eAClB/7B,KAAKs6B,YACL,sBAAwBt6B,KAAKs6B,YAAc,eAC3Ct6B,KAAKs1B,OAAO2H,UACsB,IAAhCj9B,KAAKs1B,OAAO2H,SAASx6B,OAAgB,GAAK,MAC5CzC,KAAKs1B,OAAOtX,QACZ,KACAhe,KAAKs1B,OAAO6H,YACwB,IAAlCn9B,KAAKs1B,OAAO4H,WAAWz6B,OAAgB,KAAO,MAChDzC,KAAKs1B,OAAO4H,YACwB,IAAlCl9B,KAAKs1B,OAAO4H,WAAWz6B,OAAgB,GAAK,MAC9C,aACAm5B,EAAKW,UACL,KAAOX,EAAKY,WAAa,GACzB,IAAMZ,EAAKa,cACX,KACAz8B,KAAKs1B,OAAOkF,OACZ,iBAGFL,IAAIC,SAAS0B,OAAOY,kBAAkBV,EAAS,GAAIA,EAAS,IAC5D7B,IAAIC,SAAS0B,OAAOQ,WACpBnC,IAAIC,SAAS0B,OAAb,aAEK,CACLa,QAAQC,IAAIzC,IAAIC,SAAS0B,OAAOe,GAAG/gC,OACnC6gC,QAAQC,IAAIzC,IAAIC,SAAS9E,OAAO9vB,WAChC20B,IAAIC,SAAS0B,OAAOC,eAAe,iBAAkB/7B,KAAKs6B,YAAc,IAAMt6B,KAAKs6B,YAAc,UAEjG,IAAM0B,EAAW7B,IAAIC,SAAS0B,OAAOG,oBAEb,GAApBj8B,KAAKs6B,aACPH,IAAIC,SAAS0B,OAAOI,aAAa/B,IAAIC,SAAS0B,OAAOe,GAAG/gC,MAAM2G,OAAS,GAEvE03B,IAAIC,SAAS0B,OAAOC,eAAe,sBAGnC5B,IAAIC,SAAS0B,OAAOI,aAAa/B,IAAIC,SAAS0B,OAAOe,GAAG/gC,MAAM2G,OAAS,GACvE03B,IAAIC,SAAS0B,OAAOC,eAAe,OAIrC5B,IAAIC,SAAS0B,OAAOC,eAClB,KACA/7B,KAAKs6B,YACL,wBAA0Bt6B,KAAKs6B,YAAc,eAC7Ct6B,KAAKs1B,OAAO2H,UACsB,IAAhCj9B,KAAKs1B,OAAO2H,SAASx6B,OAAgB,GAAK,MAC5CzC,KAAKs1B,OAAOtX,QACZ,KACAhe,KAAKs1B,OAAO6H,YACwB,IAAlCn9B,KAAKs1B,OAAO4H,WAAWz6B,OAAgB,KAAO,MAChDzC,KAAKs1B,OAAO4H,YACwB,IAAlCl9B,KAAKs1B,OAAO4H,WAAWz6B,OAAgB,GAAK,MAC9C,aACAm5B,EAAKW,UACL,KAAOX,EAAKY,WAAa,GACzB,IAAMZ,EAAKa,cACX,KACAz8B,KAAKs1B,OAAOkF,OACZ,iBAGFL,IAAIC,SAAS0B,OAAOY,kBAAkBV,EAAS,GAAIA,EAAS,IAG9D7B,IAAI2C,MAAMpvB,U,GA7N4BqvB,MCArBO,G,iGACnBrD,OAAA,SAAOC,GAAO,MACZ,YAAMD,OAAN,UAAaC,GAEbl6B,KAAKlE,MAAQq+B,IAAIC,SAAS9E,OAAO9vB,WAAa,GAE9CxF,KAAKq6B,cAAgBr6B,KAAKlE,MAAM4W,MAAM,yDACtC1S,KAAKs6B,aAAc,SAAAt6B,KAAKq6B,oBAAL,IAAoB53B,SAAU,EAEjDzC,KAAKs1B,OAAS,CACZtX,MAAOuc,KAAO,IACdC,KAAMD,KAAO,IACb0C,OAAQ1C,KAAO,IACfgD,KAAMhD,KAAO,IACbiD,QAASjD,KAAO,M,EAIpBE,UAAA,WACE,MAAO,I,EAGTzc,MAAA,WACE,OAAOmc,IAAIO,WAAWC,MAAM,iD,EAG9Bn1B,QAAA,WAAU,WACR,MAAO,CACLvK,EAAE,cACAA,EAAE,kBACFA,EAAE,mBAAoBk/B,IAAIO,WAAWC,MAAM,uDAC3C1/B,EAAE,cACAA,EAAE,QAASk/B,IAAIO,WAAWC,MAAM,iDAChC1/B,EAAE,oBAAqB,CACrBwE,KAAM,MACN3D,MAAOkE,KAAKs1B,OAAOkF,OACnBI,YAAa,yBACbE,QAAS,SAAC3Q,GACR,EAAKmL,OAAOkF,KAAKrQ,EAAE1b,OAAO3S,OAC1B,EAAKi/B,qBAKX9/B,EAAE,cACAA,EAAE,QAASk/B,IAAIO,WAAWC,MAAM,mDAChC1/B,EAAE,oBAAqB,CACrBwE,KAAM,OACNm7B,YAAa,kBACb9+B,MAAOkE,KAAKs1B,OAAO2H,SACnBpC,UAAU,EACVC,QAAS,SAAC3Q,GACR,EAAKmL,OAAO2H,OAAO9S,EAAE1b,OAAO3S,OAC5B,EAAKi/B,qBAKX9/B,EAAE,cACAA,EAAE,QAASk/B,IAAIO,WAAWC,MAAM,kDAChC1/B,EAAE,oBAAqB,CACrBwE,KAAM,OACN3D,MAAOkE,KAAKs1B,OAAOtX,QACnB4c,YAAa,4BACbC,UAAU,EACVC,QAAS,SAAC3Q,GACR,EAAKmL,OAAOtX,MAAMmM,EAAE1b,OAAO3S,OAC3B,EAAKi/B,qBAKX9/B,EAAE,cACAA,EAAE,QAASk/B,IAAIO,WAAWC,MAAM,iDAChC1/B,EAAE,oBAAqB,CACrBwE,KAAM,OACNm7B,YAAa,WACbyC,QAAS,kCACTvhC,MAAOkE,KAAKs1B,OAAOiI,OACnBzC,QAAS,SAAC3Q,GACR,EAAKmL,OAAOiI,KAAKpT,EAAE1b,OAAO3S,OAC1B,EAAKi/B,qBAKX9/B,EAAE,cACAA,EAAE,QAASk/B,IAAIO,WAAWC,MAAM,iDAChC1/B,EAAE,oBAAqB,CACrBwE,KAAM,OACN3D,MAAOkE,KAAKs1B,OAAOkI,UACnB5C,YAAa,aACbE,QAAS,SAAC3Q,GACR,EAAKmL,OAAOkI,QAAQrT,EAAE1b,OAAO3S,OAC7B,EAAKi/B,qBAKTC,KAAOC,UACL,CACER,UAAW,yBACXS,QAAS,kBAAM,EAAKC,iBAEtB,gB,EAOVJ,eAAA,WAGE,IAFA,IAAMK,EAAiBp7B,KAAKq7B,EAAE,SAErBC,EAAI,EAAGA,EAAIF,EAAe34B,OAAQ64B,IACrCF,EAAeE,GAAGC,SAASC,OAC7BJ,EAAeE,GAAGG,gBAAgB,U,EAKxCC,qBAAA,WAIE,IAHA,IAAMN,EAAiBp7B,KAAKq7B,EAAE,SAC1BxgC,EAAI,EAECygC,EAAI,EAAGA,EAAIF,EAAe34B,OAAQ64B,IACpCF,EAAeE,GAAGC,SAASC,QAC9BJ,EAAeE,GAAG7gB,MAAMkhB,YAAY,eAAgB,MAAO,aAC3D9gC,KAIJ,OAAS,GAALA,G,EAKNsgC,aAAA,WACE,GAAKn7B,KAAK07B,uBAAV,CAEA,IAAIE,EAAO,IAAItI,KAEf,GAAIz2B,OAAOg/B,WAAW,wBAAyB,CAC7C1B,IAAIC,SAAS0B,OAAOC,eAAe,iBAAkB/7B,KAAKs6B,YAAc,IAAMt6B,KAAKs6B,YAAc,UAEjG,IAAM0B,EAAW7B,IAAIC,SAAS0B,OAAOG,oBAEb,GAApBj8B,KAAKs6B,aACPH,IAAIC,SAAS0B,OAAOI,aAAa/B,IAAIC,SAAS0B,OAAOrwB,MAAM0wB,UAAUC,WAAWxhB,IAAIyhB,UAAU55B,OAAS,GACvG03B,IAAIC,SAAS0B,OAAOQ,WACpBnC,IAAIC,SAAS0B,OAAOC,eAAe,cACnC5B,IAAIC,SAAS0B,OAAOQ,aAEpBnC,IAAIC,SAAS0B,OAAOI,aAAa/B,IAAIC,SAAS0B,OAAOrwB,MAAM0wB,UAAUC,WAAWxhB,IAAIyhB,UAAU55B,OAAS,GACvG03B,IAAIC,SAAS0B,OAAOQ,YAGtBnC,IAAIC,SAAS0B,OAAOC,eAClB/7B,KAAKs6B,YACL,sBAAwBt6B,KAAKs6B,YAAc,eAC3Ct6B,KAAKs1B,OAAO2H,SACZ,KACAj9B,KAAKs1B,OAAOtX,QACZ,KACAhe,KAAKs1B,OAAOkI,WACuB,IAAjCx9B,KAAKs1B,OAAOkI,UAAU/6B,QAAoD,IAA9BzC,KAAKs1B,OAAOiI,OAAO96B,OAAzB,GAA8C,MACtFzC,KAAKs1B,OAAOiI,QACoB,IAA9Bv9B,KAAKs1B,OAAOiI,OAAO96B,OAAgB,IAAM,MAC3C,aACAm5B,EAAKW,UACL,KAAOX,EAAKY,WAAa,GACzB,IAAMZ,EAAKa,cACX,KACAz8B,KAAKs1B,OAAOkF,QACoB,IAA9Bx6B,KAAKs1B,OAAOkF,OAAO/3B,OAAgB,eAAiB,kBAGxD03B,IAAIC,SAAS0B,OAAOY,kBAAkBV,EAAS,GAAIA,EAAS,IAC5D7B,IAAIC,SAAS0B,OAAOQ,WACpBnC,IAAIC,SAAS0B,OAAb,aAEK,CACLa,QAAQC,IAAIzC,IAAIC,SAAS0B,OAAOe,GAAG/gC,OACnC6gC,QAAQC,IAAIzC,IAAIC,SAAS9E,OAAO9vB,WAChC20B,IAAIC,SAAS0B,OAAOC,eAAe,iBAAkB/7B,KAAKs6B,YAAc,IAAMt6B,KAAKs6B,YAAc,UAEjG,IAAM0B,EAAW7B,IAAIC,SAAS0B,OAAOG,oBAEb,GAApBj8B,KAAKs6B,aACPH,IAAIC,SAAS0B,OAAOI,aAAa/B,IAAIC,SAAS0B,OAAOe,GAAG/gC,MAAM2G,OAAS,GAEvE03B,IAAIC,SAAS0B,OAAOC,eAAe,sBAGnC5B,IAAIC,SAAS0B,OAAOI,aAAa/B,IAAIC,SAAS0B,OAAOe,GAAG/gC,MAAM2G,OAAS,GACvE03B,IAAIC,SAAS0B,OAAOC,eAAe,OAIrC5B,IAAIC,SAAS0B,OAAOC,eAClB,KACA/7B,KAAKs6B,YACL,wBAA0Bt6B,KAAKs6B,YAAc,eAC7Ct6B,KAAKs1B,OAAO2H,SACZ,KACAj9B,KAAKs1B,OAAOtX,QACZ,KACAhe,KAAKs1B,OAAOkI,WACuB,IAAjCx9B,KAAKs1B,OAAOkI,UAAU/6B,QAAoD,IAA9BzC,KAAKs1B,OAAOiI,OAAO96B,OAAzB,GAA8C,MACtFzC,KAAKs1B,OAAOiI,QACoB,IAA9Bv9B,KAAKs1B,OAAOiI,OAAO96B,OAAgB,IAAM,MAC3C,aACAm5B,EAAKW,UACL,KAAOX,EAAKY,WAAa,GACzB,IAAMZ,EAAKa,cACX,KACAz8B,KAAKs1B,OAAOkF,QACoB,IAA9Bx6B,KAAKs1B,OAAOkF,OAAO/3B,OAAgB,eAAiB,kBAGxD03B,IAAIC,SAAS0B,OAAOY,kBAAkBV,EAAS,GAAIA,EAAS,IAI9D7B,IAAI2C,MAAMpvB,U,GAhO4BqvB,MCArBU,G,iGACnBxD,OAAA,SAAOC,GAAO,MACZ,YAAMD,OAAN,UAAaC,GAEbl6B,KAAKlE,MAAQq+B,IAAIC,SAAS9E,OAAO9vB,WAAa,GAE9CxF,KAAKq6B,cAAgBr6B,KAAKlE,MAAM4W,MAAM,yDACtC1S,KAAKs6B,aAAc,SAAAt6B,KAAKq6B,oBAAL,IAAoB53B,SAAU,EAEjDzC,KAAKs1B,OAAS,CACZtX,MAAOuc,KAAO,IACdC,KAAMD,KAAO,IACb0C,OAAQ1C,KAAO,IACf2C,SAAU3C,KAAO,IACjB4C,SAAU5C,KAAO,M,EAIrBE,UAAA,WACE,MAAO,I,EAGTzc,MAAA,WACE,OAAOmc,IAAIO,WAAWC,MAAM,iD,EAG9Bn1B,QAAA,WAAU,WACR,MAAO,CACLvK,EAAE,cACAA,EAAE,kBACFA,EAAE,mBAAoBk/B,IAAIO,WAAWC,MAAM,uDAC3C1/B,EAAE,cACAA,EAAE,QAASk/B,IAAIO,WAAWC,MAAM,kDAChC1/B,EAAE,oBAAqB,CACrBwE,KAAM,OACN3D,MAAOkE,KAAKs1B,OAAOtX,QACnB4c,YAAa,4BACbC,UAAU,EACVC,QAAS,SAAC3Q,GACR,EAAKmL,OAAOtX,MAAMmM,EAAE1b,OAAO3S,OAC3B,EAAKi/B,qBAKX9/B,EAAE,cACAA,EAAE,QAASk/B,IAAIO,WAAWC,MAAM,mDAChC1/B,EAAE,oBAAqB,CACrBwE,KAAM,OACNm7B,YAAa,kBACbwC,KAAMp9B,KAAKs1B,OAAO2H,UAItBhiC,EAAE,cACAA,EAAE,QAASk/B,IAAIO,WAAWC,MAAM,iDAChC1/B,EAAE,oBAAqB,CACrBwE,KAAM,MACN3D,MAAOkE,KAAKs1B,OAAOkF,OACnBI,YAAa,yBACbC,UAAU,EACVC,QAAS,SAAC3Q,GAAM,QACd,EAAKmL,OAAOkF,KAAKrQ,EAAE1b,OAAO3S,OAC1B,EAAKw5B,OAAO6H,UAAS,SAAAhT,EAAE1b,OAAO3S,QAAT,WAAgBob,MAAM,MAAM,SAA5B,IAAgCA,MAAM,KAAK,KAAM,IACtE,EAAK6jB,qBAKX9/B,EAAE,cACAA,EAAE,QAASk/B,IAAIO,WAAWC,MAAM,uDAChC1/B,EAAE,oBAAqB,CACrBwE,KAAM,OACN3D,MAAOkE,KAAKs1B,OAAO6H,WACnBvC,YAAa,kBACbC,UAAU,EACVC,QAAS,SAAC3Q,GACR,EAAKmL,OAAO6H,SAAShT,EAAE1b,OAAO3S,OAC9B,EAAKi/B,qBAKX9/B,EAAE,cACAA,EAAE,QAASk/B,IAAIO,WAAWC,MAAM,qDAChC1/B,EAAE,oBAAqB,CACrBwE,KAAM,OACNm7B,YAAa,iBACbyC,QAAS,iUACTvhC,MAAOkE,KAAKs1B,OAAO4H,WACnBpC,QAAS,SAAC3Q,GACR,EAAKmL,OAAO4H,SAAS/S,EAAE1b,OAAO3S,OAC9B,EAAKi/B,qBAKTC,KAAOC,UACL,CACER,UAAW,yBACXS,QAAS,kBAAM,EAAKC,iBAEtB,gB,EAOVJ,eAAA,WAGE,IAFA,IAAMK,EAAiBp7B,KAAKq7B,EAAE,SAErBC,EAAI,EAAGA,EAAIF,EAAe34B,OAAQ64B,IACrCF,EAAeE,GAAGC,SAASC,OAC7BJ,EAAeE,GAAGG,gBAAgB,U,EAKxCC,qBAAA,WAIE,IAHA,IAAMN,EAAiBp7B,KAAKq7B,EAAE,SAC1BxgC,EAAI,EAECygC,EAAI,EAAGA,EAAIF,EAAe34B,OAAQ64B,IACpCF,EAAeE,GAAGC,SAASC,QAC9BJ,EAAeE,GAAG7gB,MAAMkhB,YAAY,eAAgB,MAAO,aAC3D9gC,KAIJ,OAAS,GAALA,G,EAKNsgC,aAAA,WACE,GAAKn7B,KAAK07B,uBAAV,CAEA,IAAIE,EAAO,IAAItI,KAEf,GAAIz2B,OAAOg/B,WAAW,wBAAyB,CAC7C1B,IAAIC,SAAS0B,OAAOC,eAAe,iBAAkB/7B,KAAKs6B,YAAc,IAAMt6B,KAAKs6B,YAAc,UAEjG,IAAM0B,EAAW7B,IAAIC,SAAS0B,OAAOG,oBAEb,GAApBj8B,KAAKs6B,aACPH,IAAIC,SAAS0B,OAAOI,aAAa/B,IAAIC,SAAS0B,OAAOrwB,MAAM0wB,UAAUC,WAAWxhB,IAAIyhB,UAAU55B,OAAS,GACvG03B,IAAIC,SAAS0B,OAAOQ,WACpBnC,IAAIC,SAAS0B,OAAOC,eAAe,cACnC5B,IAAIC,SAAS0B,OAAOQ,aAEpBnC,IAAIC,SAAS0B,OAAOI,aAAa/B,IAAIC,SAAS0B,OAAOrwB,MAAM0wB,UAAUC,WAAWxhB,IAAIyhB,UAAU55B,OAAS,GACvG03B,IAAIC,SAAS0B,OAAOQ,YAGtBnC,IAAIC,SAAS0B,OAAOC,eAClB/7B,KAAKs6B,YACL,sBAAwBt6B,KAAKs6B,YAAc,eAC3Ct6B,KAAKs1B,OAAO2H,UACsB,IAAhCj9B,KAAKs1B,OAAO2H,SAASx6B,OAAgB,GAAK,MAC5CzC,KAAKs1B,OAAOtX,QACZ,KACAhe,KAAKs1B,OAAO6H,YACwB,IAAlCn9B,KAAKs1B,OAAO4H,WAAWz6B,OAAgB,KAAO,MAChDzC,KAAKs1B,OAAO4H,YACwB,IAAlCl9B,KAAKs1B,OAAO4H,WAAWz6B,OAAgB,GAAK,MAC9C,aACAm5B,EAAKW,UACL,KAAOX,EAAKY,WAAa,GACzB,IAAMZ,EAAKa,cACX,KACAz8B,KAAKs1B,OAAOkF,OACZ,iBAGFL,IAAIC,SAAS0B,OAAOY,kBAAkBV,EAAS,GAAIA,EAAS,IAC5D7B,IAAIC,SAAS0B,OAAOQ,WACpBnC,IAAIC,SAAS0B,OAAb,aAEK,CACLa,QAAQC,IAAIzC,IAAIC,SAAS0B,OAAOe,GAAG/gC,OACnC6gC,QAAQC,IAAIzC,IAAIC,SAAS9E,OAAO9vB,WAChC20B,IAAIC,SAAS0B,OAAOC,eAAe,iBAAkB/7B,KAAKs6B,YAAc,IAAMt6B,KAAKs6B,YAAc,UAEjG,IAAM0B,EAAW7B,IAAIC,SAAS0B,OAAOG,oBAEb,GAApBj8B,KAAKs6B,aACPH,IAAIC,SAAS0B,OAAOI,aAAa/B,IAAIC,SAAS0B,OAAOe,GAAG/gC,MAAM2G,OAAS,GAEvE03B,IAAIC,SAAS0B,OAAOC,eAAe,sBAGnC5B,IAAIC,SAAS0B,OAAOI,aAAa/B,IAAIC,SAAS0B,OAAOe,GAAG/gC,MAAM2G,OAAS,GACvE03B,IAAIC,SAAS0B,OAAOC,eAAe,OAIrC5B,IAAIC,SAAS0B,OAAOC,eAClB,KACA/7B,KAAKs6B,YACL,wBAA0Bt6B,KAAKs6B,YAAc,eAC7Ct6B,KAAKs1B,OAAO2H,UACsB,IAAhCj9B,KAAKs1B,OAAO2H,SAASx6B,OAAgB,GAAK,MAC5CzC,KAAKs1B,OAAOtX,QACZ,KACAhe,KAAKs1B,OAAO6H,YACwB,IAAlCn9B,KAAKs1B,OAAO4H,WAAWz6B,OAAgB,KAAO,MAChDzC,KAAKs1B,OAAO4H,YACwB,IAAlCl9B,KAAKs1B,OAAO4H,WAAWz6B,OAAgB,GAAK,MAC9C,aACAm5B,EAAKW,UACL,KAAOX,EAAKY,WAAa,GACzB,IAAMZ,EAAKa,cACX,KACAz8B,KAAKs1B,OAAOkF,OACZ,iBAGFL,IAAIC,SAAS0B,OAAOY,kBAAkBV,EAAS,GAAIA,EAAS,IAG9D7B,IAAI2C,MAAMpvB,U,GA7N4BqvB,MCArBW,G,iGACnBzD,OAAA,SAAOC,GAAO,MACZ,YAAMD,OAAN,UAAaC,GAEbl6B,KAAKlE,MAAQq+B,IAAIC,SAAS9E,OAAO9vB,WAAa,GAE9CxF,KAAKq6B,cAAgBr6B,KAAKlE,MAAM4W,MAAM,yDACtC1S,KAAKs6B,aAAc,SAAAt6B,KAAKq6B,oBAAL,IAAoB53B,SAAU,EAEjDzC,KAAKs1B,OAAS,CACZtX,MAAOuc,KAAO,IACd0C,OAAQ1C,KAAO,M,EAInBE,UAAA,WACE,MAAO,I,EAGTzc,MAAA,WACE,OAAOmc,IAAIO,WAAWC,MAAM,oD,EAG9Bn1B,QAAA,WAAU,WACR,MAAO,CACLvK,EAAE,cACAA,EAAE,kBACFA,EAAE,cACAA,EAAE,QAASk/B,IAAIO,WAAWC,MAAM,kDAChC1/B,EAAE,oBAAqB,CACrBwE,KAAM,OACN3D,MAAOkE,KAAKs1B,OAAOtX,QACnB4c,YAAa,4BACbC,UAAU,EACVC,QAAS,SAAC3Q,GACR,EAAKmL,OAAOtX,MAAMmM,EAAE1b,OAAO3S,OAC3B,EAAKi/B,qBAKX9/B,EAAE,cACAA,EAAE,QAASk/B,IAAIO,WAAWC,MAAM,mDAChC1/B,EAAE,oBAAqB,CACrBwE,KAAM,OACNm7B,YAAa,kBACbwC,KAAMp9B,KAAKs1B,OAAO2H,UAIpBjC,KAAOC,UACL,CACER,UAAW,yBACXS,QAAS,kBAAM,EAAKC,iBAEtB,gB,EAOVJ,eAAA,WAGE,IAFA,IAAMK,EAAiBp7B,KAAKq7B,EAAE,SAErBC,EAAI,EAAGA,EAAIF,EAAe34B,OAAQ64B,IACrCF,EAAeE,GAAGC,SAASC,OAC7BJ,EAAeE,GAAGG,gBAAgB,U,EAKxCC,qBAAA,WAIE,IAHA,IAAMN,EAAiBp7B,KAAKq7B,EAAE,SAC1BxgC,EAAI,EAECygC,EAAI,EAAGA,EAAIF,EAAe34B,OAAQ64B,IACpCF,EAAeE,GAAGC,SAASC,QAC9BJ,EAAeE,GAAG7gB,MAAMkhB,YAAY,eAAgB,MAAO,aAC3D9gC,KAIJ,OAAS,GAALA,G,EAKNsgC,aAAA,WACE,GAAKn7B,KAAK07B,uBAAV,CAEA,IAAIE,EAAO,IAAItI,KAEf,GAAIz2B,OAAOg/B,WAAW,wBAAyB,CAC7C1B,IAAIC,SAAS0B,OAAOC,eAAe,iBAAkB/7B,KAAKs6B,YAAc,IAAMt6B,KAAKs6B,YAAc,UAEjG,IAAM0B,EAAW7B,IAAIC,SAAS0B,OAAOG,oBAEb,GAApBj8B,KAAKs6B,aACPH,IAAIC,SAAS0B,OAAOI,aAAa/B,IAAIC,SAAS0B,OAAOrwB,MAAM0wB,UAAUC,WAAWxhB,IAAIyhB,UAAU55B,OAAS,GACvG03B,IAAIC,SAAS0B,OAAOQ,WACpBnC,IAAIC,SAAS0B,OAAOC,eAAe,cACnC5B,IAAIC,SAAS0B,OAAOQ,aAEpBnC,IAAIC,SAAS0B,OAAOI,aAAa/B,IAAIC,SAAS0B,OAAOrwB,MAAM0wB,UAAUC,WAAWxhB,IAAIyhB,UAAU55B,OAAS,GACvG03B,IAAIC,SAAS0B,OAAOQ,YAGtBnC,IAAIC,SAAS0B,OAAOC,eAClB/7B,KAAKs6B,YACL,sBAAwBt6B,KAAKs6B,YAAc,kBAC3Ct6B,KAAKs1B,OAAO2H,UACsB,IAAhCj9B,KAAKs1B,OAAO2H,SAASx6B,OAAgB,GAAK,MAC5CzC,KAAKs1B,OAAOtX,QAJZhe,eAOA47B,EAAKW,UACL,KAAOX,EAAKY,WAAa,GACzB,IAAMZ,EAAKa,cATXz8B,kBAcFm6B,IAAIC,SAAS0B,OAAOY,kBAAkBV,EAAS,GAAIA,EAAS,IAC5D7B,IAAIC,SAAS0B,OAAOQ,WACpBnC,IAAIC,SAAS0B,OAAb,aAEK,CACLa,QAAQC,IAAIzC,IAAIC,SAAS0B,OAAOe,GAAG/gC,OACnC6gC,QAAQC,IAAIzC,IAAIC,SAAS9E,OAAO9vB,WAChC20B,IAAIC,SAAS0B,OAAOC,eAAe,iBAAkB/7B,KAAKs6B,YAAc,IAAMt6B,KAAKs6B,YAAc,UAEjG,IAAM0B,EAAW7B,IAAIC,SAAS0B,OAAOG,oBAEb,GAApBj8B,KAAKs6B,aACPH,IAAIC,SAAS0B,OAAOI,aAAa/B,IAAIC,SAAS0B,OAAOe,GAAG/gC,MAAM2G,OAAS,GAEvE03B,IAAIC,SAAS0B,OAAOC,eAAe,sBAGnC5B,IAAIC,SAAS0B,OAAOI,aAAa/B,IAAIC,SAAS0B,OAAOe,GAAG/gC,MAAM2G,OAAS,GACvE03B,IAAIC,SAAS0B,OAAOC,eAAe,OAIrC5B,IAAIC,SAAS0B,OAAOC,eAClB,KACA/7B,KAAKs6B,YACL,wBAA0Bt6B,KAAKs6B,YAAc,kBAC7Ct6B,KAAKs1B,OAAO2H,UACsB,IAAhCj9B,KAAKs1B,OAAO2H,SAASx6B,OAAgB,GAAK,MAC5CzC,KAAKs1B,OAAOtX,QALZ,eAQA4d,EAAKW,UACL,KAAOX,EAAKY,WAAa,GACzB,IAAMZ,EAAKa,cAVX,kBAeFtC,IAAIC,SAAS0B,OAAOY,kBAAkBV,EAAS,GAAIA,EAAS,IAG9D7B,IAAI2C,MAAMpvB,U,GApK+BqvB,MCIxBY,G,iGACnB1D,OAAA,SAAOC,GACL,YAAMD,OAAN,UAAaC,I,EAGfO,UAAA,WACE,MAAO,kB,EAGTzc,MAAA,WACE,OAAOmc,IAAIO,WAAWC,MAAM,iD,EAG9Bn1B,QAAA,WACE,MAAO,CACLvK,EAAE,cACAA,EAAE,qCACAA,EAAE,cACAA,EAAE,aAAc,CACdigC,QAAS,kBAAMf,IAAI2C,MAAMc,KAAKZ,MAE7B,OAAGa,MAAM,4CACV5iC,EAAE,OAAQk/B,IAAIO,WAAWC,MAAM,mDAGnC1/B,EAAE,cACAA,EAAE,aAAc,CACdigC,QAAS,kBAAMf,IAAI2C,MAAMc,KAAKN,MAE7B,OAAGO,MAAM,iCACV5iC,EAAE,OAAQk/B,IAAIO,WAAWC,MAAM,mDAGnC1/B,EAAE,cACAA,EAAE,aAAc,CACdigC,QAAS,kBAAMf,IAAI2C,MAAMc,KAAKH,MAE7B,OAAGI,MAAM,sCACV5iC,EAAE,OAAQk/B,IAAIO,WAAWC,MAAM,mDAGnC1/B,EAAE,cACAA,EAAE,aAAc,CACdigC,QAAS,kBAAMf,IAAI2C,MAAMc,KAAKF,MAE7B,OAAGG,MAAM,sCACV5iC,EAAE,OAAQk/B,IAAIO,WAAWC,MAAM,sDAGnC1/B,EAAE,cACAA,EAAE,aAAc,CACdigC,QAAS,kBAAMf,IAAI2C,MAAMc,KAAK5D,MAE7B,OAAG6D,MAAM,qCACV5iC,EAAE,OAAQk/B,IAAIO,WAAWC,MAAM,0D,GAtDAoC,M,u0BCM7C5C,KAAI2D,aAAa5Y,IAAI,6BAA6B,WAEhD,GAAIroB,OAAOg/B,WAAW,wBAAyB,CAC7C,IACEkC,EACElhC,OAAOg/B,WAAW,wBAAwBmC,YAD5CD,wBAGFA,EAAwBthC,UAAU6/B,SAAW,WAE3CjD,GAAU,MAAUr5B,KAAK04B,KAAKh6B,MAAOsB,KAAK04B,KAAKxB,WAEjD6G,EAAwBthC,UAAxB,OAA2C,WAEzC48B,GAAU,UAAcr5B,KAAK04B,KAAKh6B,MAAOsB,KAAK04B,KAAKxB,WAKvD+G,iBAAOC,KAAWzhC,UAAW,gBAAgB,SAAU0hC,GAiBrD,OAfAA,EAAMjZ,IACJ,aACAkZ,KAAQnD,UACN,CACEjzB,KAAMmyB,KAAIO,WAAWC,MAAM,gDAE7BK,KAAOC,UACL,CACER,UAAW,mCACX4D,KAAM,cACNnD,QAAS,kBAAMf,KAAI2C,MAAMc,KAAKD,SAK/BQ,KAITG,KAAa7hC,UAAU8hC,YAAc,WAAY,WACzCJ,EAAQ,IAAIK,KAyBlB,OAvBAL,EAAMjZ,IACJ,mBACA8V,KAAOC,UACH,CAEIR,UAAW,2BACXS,QAAS,kBAAMf,KAAI2C,MAAMc,KAAKD,MAElCxD,KAAIO,WAAWC,MAAM,iDAG3BwD,EAAMjZ,IACJ,wBACA8V,KAAOC,UACL,CACER,UAAW,2BACXgE,QAASz+B,KAAK0+B,cACdxD,QAAS,kBAAM,EAAKyD,gBAEtBxE,KAAIO,WAAWC,MAAM,sDAIlBwD,GAGTF,iBAAOK,KAAa7hC,UAAW,UAAU,WACvCuD,KAAK0+B,eAAgB,KAGvBJ,KAAa7hC,UAAUkiC,YAAvB,YAAqC,0CAAAj1B,EAAA,yDACnC1J,KAAK0+B,eAAgB,EAGR,KAFP5iC,EAAQkE,KAAKo6B,SAAS9E,OAAO9vB,WAFA,uBAKjCxF,KAAK0+B,eAAgB,EALY,0BAS7BrE,EAAgBv+B,EAAM4W,MAAM,yDAEzB7X,EAAI,EAXsB,YAWnBA,EAAIw/B,EAAc53B,QAXC,oBAcrB,QAFR+N,EAAM6pB,EAAcx/B,GAAG6X,MAAM,wDAZA,wBAe/B2nB,EAAcx/B,GAAK2V,EAAI,GAfQ,UAiBVouB,MAAM,mDAAoD,CAC7EjgC,OAAQ,OACRkgC,KAAMnrB,KAAKC,UAAU,CACnBmrB,IAAKzE,EAAcx/B,KAErBkkC,QAAS,CACP,eAAgB,sBAvBW,eAiB3BC,EAjB2B,iBA2BVA,EAASxyB,OA3BC,QA2BzBzL,EA3ByB,OA4B/Bs5B,EAAcx/B,GAAKkG,EAAOk+B,QA5BK,wBA8B/B5E,EAAcx/B,IAAK,EA9BY,QAWOA,IAXP,uBAkC/Bw/B,EAAc6E,OAAM,SAACC,GACvB,QAAOA,MAEPhF,KAAIiF,OAAOxB,KACTyB,KACA,CACE5/B,KAAM,WAER06B,KAAIO,WAAWC,MAAM,yDAEvB36B,KAAK0+B,eAAgB,IAEfY,EAAqBjF,EACxB9zB,KAAI,SAAC44B,EAAKl2B,GACT,GAAW,GAAPk2B,EAAc,OAAOl2B,KAE1Bs2B,QAAO,SAAAt2B,GAAK,OAAIA,GAAS,KACzB1C,KAAI,SAAA0C,GAAK,OAAIA,EAAQ,KACpBu2B,EAAUF,EAAmBx0B,KAAK,MACtCqvB,KAAIiF,OAAOxB,KACTyB,KACA,CACE5/B,KAAM,WAEsB,GAA7B6/B,EAAmB78B,OAClB03B,KAAIO,WAAWC,MAAM,2DAA4D,CAAC6E,YAClFrF,KAAIO,WAAWC,MAAM,4DAA6D,CAAC6E,aAEvFx/B,KAAK0+B,eAAgB,GA9DY,iDAkErCT,iBAAOK,KAAa7hC,UAAW,QAAQ,SAAUi8B,GAC/CA,EAAK+G,SAAS,GAAGA,SAAS,GAAGA,SAASv9B,KAAK,QAAIu4B,UAAU,eAAeiF,KAAU1/B,KAAKu+B,cAAcoB,gBAKvG1B,iBAAO2B,KAAYnjC,UAAW,CAAC,WAAY,aAAa,WAKtD,IAJA,IAIA,EAJMojC,EAAU1F,KAAI2F,MAAMC,UAAU,WAD8B,iBAKvDvF,EALuD,QAMhE,GAAIA,EAAKwF,UAAUvc,SAAS,eACxB,iBAGJ,IAAMwc,EAAOzF,EAAKyF,KAElB,IAAKA,EAAKC,WAAWL,GACnB,iBAGF,IACMM,EADOF,EAAKhzB,QAAQ4yB,EAAS,IACb3oB,MAAM,KAG5B,GAFeipB,EAASA,EAAS19B,OAAO,GAAGiQ,MAAM,eAG/C,iBAGF,IAAM0tB,EAAaD,EAASA,EAAS19B,OAAO,GAAGyU,MAAM,KAC/CojB,EAAc8F,EAAWA,EAAW39B,OAAS,GAEnD+3B,EAAK6F,iBAAiB,SAAS,SAAUlW,GACrCA,EAAEmW,iBAEF,IAAIC,EAAY5b,SAAS6b,eAAelG,GAC/B,MAATiG,KAAW5L,eAAe,CAAC8L,SAAU,eA1B3C,KAHiBzgC,KAAK0gC,QAAQ9d,cAAc,cAClB+d,iBAAiB,QAE3C,aAA6B,UA8B7B","file":"forum.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 16);\n","module.exports = flarum.core.compat['common/utils/Stream'];","module.exports = flarum.core.compat['components/Button'];","module.exports = flarum.core.compat['app'];","module.exports = flarum.core.compat['components/Modal'];","module.exports = flarum.core.compat['common/extend'];","module.exports = flarum.core.compat['components/ComposerBody'];","module.exports = require(\"regenerator-runtime\");\n","module.exports = flarum.core.compat['common/components/Alert'];","module.exports = flarum.core.compat['common/components/TextEditor'];","module.exports = flarum.core.compat['forum/components/CommentPost'];","module.exports = flarum.core.compat['common/components/Tooltip'];","module.exports = flarum.core.compat['common/utils/ItemList'];","module.exports = flarum.core.compat['common/helpers/listItems'];","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}","// ::- Persistent data structure representing an ordered mapping from\n// strings to values, with some convenient update methods.\nfunction OrderedMap(content) {\n  this.content = content;\n}\n\nOrderedMap.prototype = {\n  constructor: OrderedMap,\n\n  find: function(key) {\n    for (var i = 0; i < this.content.length; i += 2)\n      if (this.content[i] === key) return i\n    return -1\n  },\n\n  // :: (string) → ?any\n  // Retrieve the value stored under `key`, or return undefined when\n  // no such key exists.\n  get: function(key) {\n    var found = this.find(key);\n    return found == -1 ? undefined : this.content[found + 1]\n  },\n\n  // :: (string, any, ?string) → OrderedMap\n  // Create a new map by replacing the value of `key` with a new\n  // value, or adding a binding to the end of the map. If `newKey` is\n  // given, the key of the binding will be replaced with that key.\n  update: function(key, value, newKey) {\n    var self = newKey && newKey != key ? this.remove(newKey) : this;\n    var found = self.find(key), content = self.content.slice();\n    if (found == -1) {\n      content.push(newKey || key, value);\n    } else {\n      content[found + 1] = value;\n      if (newKey) content[found] = newKey;\n    }\n    return new OrderedMap(content)\n  },\n\n  // :: (string) → OrderedMap\n  // Return a map with the given key removed, if it existed.\n  remove: function(key) {\n    var found = this.find(key);\n    if (found == -1) return this\n    var content = this.content.slice();\n    content.splice(found, 2);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the start of the map.\n  addToStart: function(key, value) {\n    return new OrderedMap([key, value].concat(this.remove(key).content))\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the end of the map.\n  addToEnd: function(key, value) {\n    var content = this.remove(key).content.slice();\n    content.push(key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, string, any) → OrderedMap\n  // Add a key after the given key. If `place` is not found, the new\n  // key is added to the end.\n  addBefore: function(place, key, value) {\n    var without = this.remove(key), content = without.content.slice();\n    var found = without.find(place);\n    content.splice(found == -1 ? content.length : found, 0, key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: ((key: string, value: any))\n  // Call the given function for each key/value pair in the map, in\n  // order.\n  forEach: function(f) {\n    for (var i = 0; i < this.content.length; i += 2)\n      f(this.content[i], this.content[i + 1]);\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by prepending the keys in this map that don't\n  // appear in `map` before the keys in `map`.\n  prepend: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(map.content.concat(this.subtract(map).content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by appending the keys in this map that don't\n  // appear in `map` after the keys in `map`.\n  append: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(this.subtract(map).content.concat(map.content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a map containing all the keys in this map that don't\n  // appear in `map`.\n  subtract: function(map) {\n    var result = this;\n    map = OrderedMap.from(map);\n    for (var i = 0; i < map.content.length; i += 2)\n      result = result.remove(map.content[i]);\n    return result\n  },\n\n  // :: number\n  // The amount of keys in this map.\n  get size() {\n    return this.content.length >> 1\n  }\n};\n\n// :: (?union<Object, OrderedMap>) → OrderedMap\n// Return a map with the given content. If null, create an empty\n// map. If given an ordered map, return that map itself. If given an\n// object, create a map from the object's properties.\nOrderedMap.from = function(value) {\n  if (value instanceof OrderedMap) return value\n  var content = [];\n  if (value) for (var prop in value) content.push(prop, value[prop]);\n  return new OrderedMap(content)\n};\n\nvar orderedmap = OrderedMap;\n\nexport default orderedmap;\n","import {findDiffStart, findDiffEnd} from \"./diff\"\n\n// ::- A fragment represents a node's collection of child nodes.\n//\n// Like nodes, fragments are persistent data structures, and you\n// should not mutate them or their content. Rather, you create new\n// instances whenever needed. The API tries to make this easy.\nexport class Fragment {\n  constructor(content, size) {\n    this.content = content\n    // :: number\n    // The size of the fragment, which is the total of the size of its\n    // content nodes.\n    this.size = size || 0\n    if (size == null) for (let i = 0; i < content.length; i++)\n      this.size += content[i].nodeSize\n  }\n\n  // :: (number, number, (node: Node, start: number, parent: Node, index: number) → ?bool, ?number)\n  // Invoke a callback for all descendant nodes between the given two\n  // positions (relative to start of this fragment). Doesn't descend\n  // into a node when the callback returns `false`.\n  nodesBetween(from, to, f, nodeStart = 0, parent) {\n    for (let i = 0, pos = 0; pos < to; i++) {\n      let child = this.content[i], end = pos + child.nodeSize\n      if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {\n        let start = pos + 1\n        child.nodesBetween(Math.max(0, from - start),\n                           Math.min(child.content.size, to - start),\n                           f, nodeStart + start)\n      }\n      pos = end\n    }\n  }\n\n  // :: ((node: Node, pos: number, parent: Node) → ?bool)\n  // Call the given callback for every descendant node. The callback\n  // may return `false` to prevent traversal of a given node's children.\n  descendants(f) {\n    this.nodesBetween(0, this.size, f)\n  }\n\n  // :: (number, number, ?string, ?union<string, (leafNode: Node) → string>) → string\n  // Extract the text between `from` and `to`. See the same method on\n  // [`Node`](#model.Node.textBetween).\n  textBetween(from, to, blockSeparator, leafText) {\n    let text = \"\", separated = true\n    this.nodesBetween(from, to, (node, pos) => {\n      if (node.isText) {\n        text += node.text.slice(Math.max(from, pos) - pos, to - pos)\n        separated = !blockSeparator\n      } else if (node.isLeaf && leafText) {\n        text += typeof leafText === 'function' ? leafText(node): leafText\n        separated = !blockSeparator\n      } else if (!separated && node.isBlock) {\n        text += blockSeparator\n        separated = true\n      }\n    }, 0)\n    return text\n  }\n\n  // :: (Fragment) → Fragment\n  // Create a new fragment containing the combined content of this\n  // fragment and the other.\n  append(other) {\n    if (!other.size) return this\n    if (!this.size) return other\n    let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0\n    if (last.isText && last.sameMarkup(first)) {\n      content[content.length - 1] = last.withText(last.text + first.text)\n      i = 1\n    }\n    for (; i < other.content.length; i++) content.push(other.content[i])\n    return new Fragment(content, this.size + other.size)\n  }\n\n  // :: (number, ?number) → Fragment\n  // Cut out the sub-fragment between the two given positions.\n  cut(from, to) {\n    if (to == null) to = this.size\n    if (from == 0 && to == this.size) return this\n    let result = [], size = 0\n    if (to > from) for (let i = 0, pos = 0; pos < to; i++) {\n      let child = this.content[i], end = pos + child.nodeSize\n      if (end > from) {\n        if (pos < from || end > to) {\n          if (child.isText)\n            child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos))\n          else\n            child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1))\n        }\n        result.push(child)\n        size += child.nodeSize\n      }\n      pos = end\n    }\n    return new Fragment(result, size)\n  }\n\n  cutByIndex(from, to) {\n    if (from == to) return Fragment.empty\n    if (from == 0 && to == this.content.length) return this\n    return new Fragment(this.content.slice(from, to))\n  }\n\n  // :: (number, Node) → Fragment\n  // Create a new fragment in which the node at the given index is\n  // replaced by the given node.\n  replaceChild(index, node) {\n    let current = this.content[index]\n    if (current == node) return this\n    let copy = this.content.slice()\n    let size = this.size + node.nodeSize - current.nodeSize\n    copy[index] = node\n    return new Fragment(copy, size)\n  }\n\n  // : (Node) → Fragment\n  // Create a new fragment by prepending the given node to this\n  // fragment.\n  addToStart(node) {\n    return new Fragment([node].concat(this.content), this.size + node.nodeSize)\n  }\n\n  // : (Node) → Fragment\n  // Create a new fragment by appending the given node to this\n  // fragment.\n  addToEnd(node) {\n    return new Fragment(this.content.concat(node), this.size + node.nodeSize)\n  }\n\n  // :: (Fragment) → bool\n  // Compare this fragment to another one.\n  eq(other) {\n    if (this.content.length != other.content.length) return false\n    for (let i = 0; i < this.content.length; i++)\n      if (!this.content[i].eq(other.content[i])) return false\n    return true\n  }\n\n  // :: ?Node\n  // The first child of the fragment, or `null` if it is empty.\n  get firstChild() { return this.content.length ? this.content[0] : null }\n\n  // :: ?Node\n  // The last child of the fragment, or `null` if it is empty.\n  get lastChild() { return this.content.length ? this.content[this.content.length - 1] : null }\n\n  // :: number\n  // The number of child nodes in this fragment.\n  get childCount() { return this.content.length }\n\n  // :: (number) → Node\n  // Get the child node at the given index. Raise an error when the\n  // index is out of range.\n  child(index) {\n    let found = this.content[index]\n    if (!found) throw new RangeError(\"Index \" + index + \" out of range for \" + this)\n    return found\n  }\n\n  // :: (number) → ?Node\n  // Get the child node at the given index, if it exists.\n  maybeChild(index) {\n    return this.content[index]\n  }\n\n  // :: ((node: Node, offset: number, index: number))\n  // Call `f` for every child node, passing the node, its offset\n  // into this parent node, and its index.\n  forEach(f) {\n    for (let i = 0, p = 0; i < this.content.length; i++) {\n      let child = this.content[i]\n      f(child, p, i)\n      p += child.nodeSize\n    }\n  }\n\n  // :: (Fragment) → ?number\n  // Find the first position at which this fragment and another\n  // fragment differ, or `null` if they are the same.\n  findDiffStart(other, pos = 0) {\n    return findDiffStart(this, other, pos)\n  }\n\n  // :: (Fragment) → ?{a: number, b: number}\n  // Find the first position, searching from the end, at which this\n  // fragment and the given fragment differ, or `null` if they are the\n  // same. Since this position will not be the same in both nodes, an\n  // object with two separate positions is returned.\n  findDiffEnd(other, pos = this.size, otherPos = other.size) {\n    return findDiffEnd(this, other, pos, otherPos)\n  }\n\n  // : (number, ?number) → {index: number, offset: number}\n  // Find the index and inner offset corresponding to a given relative\n  // position in this fragment. The result object will be reused\n  // (overwritten) the next time the function is called. (Not public.)\n  findIndex(pos, round = -1) {\n    if (pos == 0) return retIndex(0, pos)\n    if (pos == this.size) return retIndex(this.content.length, pos)\n    if (pos > this.size || pos < 0) throw new RangeError(`Position ${pos} outside of fragment (${this})`)\n    for (let i = 0, curPos = 0;; i++) {\n      let cur = this.child(i), end = curPos + cur.nodeSize\n      if (end >= pos) {\n        if (end == pos || round > 0) return retIndex(i + 1, end)\n        return retIndex(i, curPos)\n      }\n      curPos = end\n    }\n  }\n\n  // :: () → string\n  // Return a debugging string that describes this fragment.\n  toString() { return \"<\" + this.toStringInner() + \">\" }\n\n  toStringInner() { return this.content.join(\", \") }\n\n  // :: () → ?Object\n  // Create a JSON-serializeable representation of this fragment.\n  toJSON() {\n    return this.content.length ? this.content.map(n => n.toJSON()) : null\n  }\n\n  // :: (Schema, ?Object) → Fragment\n  // Deserialize a fragment from its JSON representation.\n  static fromJSON(schema, value) {\n    if (!value) return Fragment.empty\n    if (!Array.isArray(value)) throw new RangeError(\"Invalid input for Fragment.fromJSON\")\n    return new Fragment(value.map(schema.nodeFromJSON))\n  }\n\n  // :: ([Node]) → Fragment\n  // Build a fragment from an array of nodes. Ensures that adjacent\n  // text nodes with the same marks are joined together.\n  static fromArray(array) {\n    if (!array.length) return Fragment.empty\n    let joined, size = 0\n    for (let i = 0; i < array.length; i++) {\n      let node = array[i]\n      size += node.nodeSize\n      if (i && node.isText && array[i - 1].sameMarkup(node)) {\n        if (!joined) joined = array.slice(0, i)\n        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text)\n      } else if (joined) {\n        joined.push(node)\n      }\n    }\n    return new Fragment(joined || array, size)\n  }\n\n  // :: (?union<Fragment, Node, [Node]>) → Fragment\n  // Create a fragment from something that can be interpreted as a set\n  // of nodes. For `null`, it returns the empty fragment. For a\n  // fragment, the fragment itself. For a node or array of nodes, a\n  // fragment containing those nodes.\n  static from(nodes) {\n    if (!nodes) return Fragment.empty\n    if (nodes instanceof Fragment) return nodes\n    if (Array.isArray(nodes)) return this.fromArray(nodes)\n    if (nodes.attrs) return new Fragment([nodes], nodes.nodeSize)\n    throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" +\n                         (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"))\n  }\n}\n\nconst found = {index: 0, offset: 0}\nfunction retIndex(index, offset) {\n  found.index = index\n  found.offset = offset\n  return found\n}\n\n// :: Fragment\n// An empty fragment. Intended to be reused whenever a node doesn't\n// contain anything (rather than allocating a new empty fragment for\n// each leaf node).\nFragment.empty = new Fragment([], 0)\n","export function findDiffStart(a, b, pos) {\n  for (let i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount)\n      return a.childCount == b.childCount ? null : pos\n\n    let childA = a.child(i), childB = b.child(i)\n    if (childA == childB) { pos += childA.nodeSize; continue }\n\n    if (!childA.sameMarkup(childB)) return pos\n\n    if (childA.isText && childA.text != childB.text) {\n      for (let j = 0; childA.text[j] == childB.text[j]; j++)\n        pos++\n      return pos\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffStart(childA.content, childB.content, pos + 1)\n      if (inner != null) return inner\n    }\n    pos += childA.nodeSize\n  }\n}\n\nexport function findDiffEnd(a, b, posA, posB) {\n  for (let iA = a.childCount, iB = b.childCount;;) {\n    if (iA == 0 || iB == 0)\n      return iA == iB ? null : {a: posA, b: posB}\n\n    let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize\n    if (childA == childB) {\n      posA -= size; posB -= size\n      continue\n    }\n\n    if (!childA.sameMarkup(childB)) return {a: posA, b: posB}\n\n    if (childA.isText && childA.text != childB.text) {\n      let same = 0, minSize = Math.min(childA.text.length, childB.text.length)\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++; posA--; posB--\n      }\n      return {a: posA, b: posB}\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1)\n      if (inner) return inner\n    }\n    posA -= size; posB -= size\n  }\n}\n","export function compareDeep(a, b) {\n  if (a === b) return true\n  if (!(a && typeof a == \"object\") ||\n      !(b && typeof b == \"object\")) return false\n  let array = Array.isArray(a)\n  if (Array.isArray(b) != array) return false\n  if (array) {\n    if (a.length != b.length) return false\n    for (let i = 0; i < a.length; i++) if (!compareDeep(a[i], b[i])) return false\n  } else {\n    for (let p in a) if (!(p in b) || !compareDeep(a[p], b[p])) return false\n    for (let p in b) if (!(p in a)) return false\n  }\n  return true\n}\n","import {MarkType, Slice, Fragment} from \"prosemirror-model\"\n\nimport {Transform} from \"./transform\"\nimport {AddMarkStep, RemoveMarkStep} from \"./mark_step\"\nimport {ReplaceStep} from \"./replace_step\"\n\n// :: (number, number, Mark) → this\n// Add the given mark to the inline content between `from` and `to`.\nTransform.prototype.addMark = function(from, to, mark) {\n  let removed = [], added = [], removing = null, adding = null\n  this.doc.nodesBetween(from, to, (node, pos, parent) => {\n    if (!node.isInline) return\n    let marks = node.marks\n    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n      let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to)\n      let newSet = mark.addToSet(marks)\n\n      for (let i = 0; i < marks.length; i++) {\n        if (!marks[i].isInSet(newSet)) {\n          if (removing && removing.to == start && removing.mark.eq(marks[i]))\n            removing.to = end\n          else\n            removed.push(removing = new RemoveMarkStep(start, end, marks[i]))\n        }\n      }\n\n      if (adding && adding.to == start)\n        adding.to = end\n      else\n        added.push(adding = new AddMarkStep(start, end, mark))\n    }\n  })\n\n  removed.forEach(s => this.step(s))\n  added.forEach(s => this.step(s))\n  return this\n}\n\n// :: (number, number, ?union<Mark, MarkType>) → this\n// Remove marks from inline nodes between `from` and `to`. When `mark`\n// is a single mark, remove precisely that mark. When it is a mark type,\n// remove all marks of that type. When it is null, remove all marks of\n// any type.\nTransform.prototype.removeMark = function(from, to, mark = null) {\n  let matched = [], step = 0\n  this.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isInline) return\n    step++\n    let toRemove = null\n    if (mark instanceof MarkType) {\n      let set = node.marks, found\n      while (found = mark.isInSet(set)) {\n        ;(toRemove || (toRemove = [])).push(found)\n        set = found.removeFromSet(set)\n      }\n    } else if (mark) {\n      if (mark.isInSet(node.marks)) toRemove = [mark]\n    } else {\n      toRemove = node.marks\n    }\n    if (toRemove && toRemove.length) {\n      let end = Math.min(pos + node.nodeSize, to)\n      for (let i = 0; i < toRemove.length; i++) {\n        let style = toRemove[i], found\n        for (let j = 0; j < matched.length; j++) {\n          let m = matched[j]\n          if (m.step == step - 1 && style.eq(matched[j].style)) found = m\n        }\n        if (found) {\n          found.to = end\n          found.step = step\n        } else {\n          matched.push({style, from: Math.max(pos, from), to: end, step})\n        }\n      }\n    }\n  })\n  matched.forEach(m => this.step(new RemoveMarkStep(m.from, m.to, m.style)))\n  return this\n}\n\n// :: (number, NodeType, ?ContentMatch) → this\n// Removes all marks and nodes from the content of the node at `pos`\n// that don't match the given new parent node type. Accepts an\n// optional starting [content match](#model.ContentMatch) as third\n// argument.\nTransform.prototype.clearIncompatible = function(pos, parentType, match = parentType.contentMatch) {\n  let node = this.doc.nodeAt(pos)\n  let delSteps = [], cur = pos + 1\n  for (let i = 0; i < node.childCount; i++) {\n    let child = node.child(i), end = cur + child.nodeSize\n    let allowed = match.matchType(child.type, child.attrs)\n    if (!allowed) {\n      delSteps.push(new ReplaceStep(cur, end, Slice.empty))\n    } else {\n      match = allowed\n      for (let j = 0; j < child.marks.length; j++) if (!parentType.allowsMarkType(child.marks[j].type))\n        this.step(new RemoveMarkStep(cur, end, child.marks[j]))\n    }\n    cur = end\n  }\n  if (!match.validEnd) {\n    let fill = match.fillBefore(Fragment.empty, true)\n    this.replace(cur, cur, new Slice(fill, 0, 0))\n  }\n  for (let i = delSteps.length - 1; i >= 0; i--) this.step(delSteps[i])\n  return this\n}\n","import {Fragment, Slice} from \"prosemirror-model\"\n\nimport {ReplaceStep, ReplaceAroundStep} from \"./replace_step\"\nimport {Transform} from \"./transform\"\nimport {insertPoint} from \"./structure\"\n\n// :: (Node, number, ?number, ?Slice) → ?Step\n// ‘Fit’ a slice into a given position in the document, producing a\n// [step](#transform.Step) that inserts it. Will return null if\n// there's no meaningful way to insert the slice here, or inserting it\n// would be a no-op (an empty slice over an empty range).\nexport function replaceStep(doc, from, to = from, slice = Slice.empty) {\n  if (from == to && !slice.size) return null\n\n  let $from = doc.resolve(from), $to = doc.resolve(to)\n  // Optimization -- avoid work if it's obvious that it's not needed.\n  if (fitsTrivially($from, $to, slice)) return new ReplaceStep(from, to, slice)\n  return new Fitter($from, $to, slice).fit()\n}\n\n// :: (number, ?number, ?Slice) → this\n// Replace the part of the document between `from` and `to` with the\n// given `slice`.\nTransform.prototype.replace = function(from, to = from, slice = Slice.empty) {\n  let step = replaceStep(this.doc, from, to, slice)\n  if (step) this.step(step)\n  return this\n}\n\n// :: (number, number, union<Fragment, Node, [Node]>) → this\n// Replace the given range with the given content, which may be a\n// fragment, node, or array of nodes.\nTransform.prototype.replaceWith = function(from, to, content) {\n  return this.replace(from, to, new Slice(Fragment.from(content), 0, 0))\n}\n\n// :: (number, number) → this\n// Delete the content between the given positions.\nTransform.prototype.delete = function(from, to) {\n  return this.replace(from, to, Slice.empty)\n}\n\n// :: (number, union<Fragment, Node, [Node]>) → this\n// Insert the given content at the given position.\nTransform.prototype.insert = function(pos, content) {\n  return this.replaceWith(pos, pos, content)\n}\n\nfunction fitsTrivially($from, $to, slice) {\n  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&\n    $from.parent.canReplace($from.index(), $to.index(), slice.content)\n}\n\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn't\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\nclass Fitter {\n  constructor($from, $to, slice) {\n    this.$to = $to\n    this.$from = $from\n    this.unplaced = slice\n\n    this.frontier = []\n    for (let i = 0; i <= $from.depth; i++) {\n      let node = $from.node(i)\n      this.frontier.push({\n        type: node.type,\n        match: node.contentMatchAt($from.indexAfter(i))\n      })\n    }\n\n    this.placed = Fragment.empty\n    for (let i = $from.depth; i > 0; i--)\n      this.placed = Fragment.from($from.node(i).copy(this.placed))\n  }\n\n  get depth() { return this.frontier.length - 1 }\n\n  fit() {\n    // As long as there's unplaced content, try to place some of it.\n    // If that fails, either increase the open score of the unplaced\n    // slice, or drop nodes from it, and then try again.\n    while (this.unplaced.size) {\n      let fit = this.findFittable()\n      if (fit) this.placeNodes(fit)\n      else this.openMore() || this.dropNode()\n    }\n    // When there's inline content directly after the frontier _and_\n    // directly after `this.$to`, we must generate a `ReplaceAround`\n    // step that pulls that content into the node after the frontier.\n    // That means the fitting must be done to the end of the textblock\n    // node after `this.$to`, not `this.$to` itself.\n    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth\n    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline))\n    if (!$to) return null\n\n    // If closing to `$to` succeeded, create a step\n    let content = this.placed, openStart = $from.depth, openEnd = $to.depth\n    while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes\n      content = content.firstChild.content\n      openStart--; openEnd--\n    }\n    let slice = new Slice(content, openStart, openEnd)\n    if (moveInline > -1)\n      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize)\n    if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps\n      return new ReplaceStep($from.pos, $to.pos, slice)\n  }\n\n  // Find a position on the start spine of `this.unplaced` that has\n  // content that can be moved somewhere on the frontier. Returns two\n  // depths, one for the slice and one for the frontier.\n  findFittable() {\n    // Only try wrapping nodes (pass 2) after finding a place without\n    // wrapping failed.\n    for (let pass = 1; pass <= 2; pass++) {\n      for (let sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n        let fragment, parent\n        if (sliceDepth) {\n          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild\n          fragment = parent.content\n        } else {\n          fragment = this.unplaced.content\n        }\n        let first = fragment.firstChild\n        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n          let {type, match} = this.frontier[frontierDepth], wrap, inject\n          // In pass 1, if the next node matches, or there is no next\n          // node but the parents look compatible, we've found a\n          // place.\n          if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false))\n                            : type.compatibleContent(parent.type)))\n            return {sliceDepth, frontierDepth, parent, inject}\n          // In pass 2, look for a set of wrapping nodes that make\n          // `first` fit here.\n          else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))\n            return {sliceDepth, frontierDepth, parent, wrap}\n          // Don't continue looking further up if the parent node\n          // would fit here.\n          if (parent && match.matchType(parent.type)) break\n        }\n      }\n    }\n  }\n\n  openMore() {\n    let {content, openStart, openEnd} = this.unplaced\n    let inner = contentAt(content, openStart)\n    if (!inner.childCount || inner.firstChild.isLeaf) return false\n    this.unplaced = new Slice(content, openStart + 1,\n                              Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0))\n    return true\n  }\n\n  dropNode() {\n    let {content, openStart, openEnd} = this.unplaced\n    let inner = contentAt(content, openStart)\n    if (inner.childCount <= 1 && openStart > 0) {\n      let openAtEnd = content.size - openStart <= openStart + inner.size\n      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1,\n                                openAtEnd ? openStart - 1 : openEnd)\n    } else {\n      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd)\n    }\n  }\n\n  // : ({sliceDepth: number, frontierDepth: number, parent: ?Node, wrap: ?[NodeType], inject: ?Fragment})\n  // Move content from the unplaced slice at `sliceDepth` to the\n  // frontier node at `frontierDepth`. Close that frontier node when\n  // applicable.\n  placeNodes({sliceDepth, frontierDepth, parent, inject, wrap}) {\n    while (this.depth > frontierDepth) this.closeFrontierNode()\n    if (wrap) for (let i = 0; i < wrap.length; i++) this.openFrontierNode(wrap[i])\n\n    let slice = this.unplaced, fragment = parent ? parent.content : slice.content\n    let openStart = slice.openStart - sliceDepth\n    let taken = 0, add = []\n    let {match, type} = this.frontier[frontierDepth]\n    if (inject) {\n      for (let i = 0; i < inject.childCount; i++) add.push(inject.child(i))\n      match = match.matchFragment(inject)\n    }\n    // Computes the amount of (end) open nodes at the end of the\n    // fragment. When 0, the parent is open, but no more. When\n    // negative, nothing is open.\n    let openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd)\n    // Scan over the fragment, fitting as many child nodes as\n    // possible.\n    while (taken < fragment.childCount) {\n      let next = fragment.child(taken), matches = match.matchType(next.type)\n      if (!matches) break\n      taken++\n      if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes\n        match = matches\n        add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0,\n                                taken == fragment.childCount ? openEndCount : -1))\n      }\n    }\n    let toEnd = taken == fragment.childCount\n    if (!toEnd) openEndCount = -1\n\n    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add))\n    this.frontier[frontierDepth].match = match\n\n    // If the parent types match, and the entire node was moved, and\n    // it's not open, close this frontier node right away.\n    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)\n      this.closeFrontierNode()\n\n    // Add new frontier nodes for any open nodes at the end.\n    for (let i = 0, cur = fragment; i < openEndCount; i++) {\n      let node = cur.lastChild\n      this.frontier.push({type: node.type, match: node.contentMatchAt(node.childCount)})\n      cur = node.content\n    }\n\n    // Update `this.unplaced`. Drop the entire node from which we\n    // placed it we got to its end, otherwise just drop the placed\n    // nodes.\n    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)\n      : sliceDepth == 0 ? Slice.empty\n      : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1),\n                  sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1)\n  }\n\n  mustMoveInline() {\n    if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) return -1\n    let top = this.frontier[this.depth], level\n    if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||\n        (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)) return -1\n\n    let {depth} = this.$to, after = this.$to.after(depth)\n    while (depth > 1 && after == this.$to.end(--depth)) ++after\n    return after\n  }\n\n  findCloseLevel($to) {\n    scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n      let {match, type} = this.frontier[i]\n      let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1))\n      let fit = contentAfterFits($to, i, type, match, dropInner)\n      if (!fit) continue\n      for (let d = i - 1; d >= 0; d--) {\n        let {match, type} = this.frontier[d]\n        let matches = contentAfterFits($to, d, type, match, true)\n        if (!matches || matches.childCount) continue scan\n      }\n      return {depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to}\n    }\n  }\n\n  close($to) {\n    let close = this.findCloseLevel($to)\n    if (!close) return null\n\n    while (this.depth > close.depth) this.closeFrontierNode()\n    if (close.fit.childCount) this.placed = addToFragment(this.placed, close.depth, close.fit)\n    $to = close.move\n    for (let d = close.depth + 1; d <= $to.depth; d++) {\n      let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d))\n      this.openFrontierNode(node.type, node.attrs, add)\n    }\n    return $to\n  }\n\n  openFrontierNode(type, attrs, content) {\n    let top = this.frontier[this.depth]\n    top.match = top.match.matchType(type)\n    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)))\n    this.frontier.push({type, match: type.contentMatch})\n  }\n\n  closeFrontierNode() {\n    let open = this.frontier.pop()\n    let add = open.match.fillBefore(Fragment.empty, true)\n    if (add.childCount) this.placed = addToFragment(this.placed, this.frontier.length, add)\n  }\n}\n\nfunction dropFromFragment(fragment, depth, count) {\n  if (depth == 0) return fragment.cutByIndex(count)\n  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)))\n}\n\nfunction addToFragment(fragment, depth, content) {\n  if (depth == 0) return fragment.append(content)\n  return fragment.replaceChild(fragment.childCount - 1,\n                               fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)))\n}\n\nfunction contentAt(fragment, depth) {\n  for (let i = 0; i < depth; i++) fragment = fragment.firstChild.content\n  return fragment\n}\n\nfunction closeNodeStart(node, openStart, openEnd) {\n  if (openStart <= 0) return node\n  let frag = node.content\n  if (openStart > 1)\n    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0))\n  if (openStart > 0) {\n    frag = node.type.contentMatch.fillBefore(frag).append(frag)\n    if (openEnd <= 0) frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true))\n  }\n  return node.copy(frag)\n}\n\nfunction contentAfterFits($to, depth, type, match, open) {\n  let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth)\n  if (index == node.childCount && !type.compatibleContent(node.type)) return null\n  let fit = match.fillBefore(node.content, true, index)\n  return fit && !invalidMarks(type, node.content, index) ? fit : null\n}\n\nfunction invalidMarks(type, fragment, start) {\n  for (let i = start; i < fragment.childCount; i++)\n    if (!type.allowsMarks(fragment.child(i).marks)) return true\n  return false\n}\n\n// :: (number, number, Slice) → this\n// Replace a range of the document with a given slice, using `from`,\n// `to`, and the slice's [`openStart`](#model.Slice.openStart) property\n// as hints, rather than fixed start and end points. This method may\n// grow the replaced area or close open nodes in the slice in order to\n// get a fit that is more in line with WYSIWYG expectations, by\n// dropping fully covered parent nodes of the replaced region when\n// they are marked [non-defining](#model.NodeSpec.defining), or\n// including an open parent node from the slice that _is_ marked as\n// [defining](#model.NodeSpec.defining).\n//\n// This is the method, for example, to handle paste. The similar\n// [`replace`](#transform.Transform.replace) method is a more\n// primitive tool which will _not_ move the start and end of its given\n// range, and is useful in situations where you need more precise\n// control over what happens.\nTransform.prototype.replaceRange = function(from, to, slice) {\n  if (!slice.size) return this.deleteRange(from, to)\n\n  let $from = this.doc.resolve(from), $to = this.doc.resolve(to)\n  if (fitsTrivially($from, $to, slice))\n    return this.step(new ReplaceStep(from, to, slice))\n\n  let targetDepths = coveredDepths($from, this.doc.resolve(to))\n  // Can't replace the whole document, so remove 0 if it's present\n  if (targetDepths[targetDepths.length - 1] == 0) targetDepths.pop()\n  // Negative numbers represent not expansion over the whole node at\n  // that depth, but replacing from $from.before(-D) to $to.pos.\n  let preferredTarget = -($from.depth + 1)\n  targetDepths.unshift(preferredTarget)\n  // This loop picks a preferred target depth, if one of the covering\n  // depths is not outside of a defining node, and adds negative\n  // depths for any depth that has $from at its start and does not\n  // cross a defining node.\n  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n    let spec = $from.node(d).type.spec\n    if (spec.defining || spec.isolating) break\n    if (targetDepths.indexOf(d) > -1) preferredTarget = d\n    else if ($from.before(d) == pos) targetDepths.splice(1, 0, -d)\n  }\n  // Try to fit each possible depth of the slice into each possible\n  // target depth, starting with the preferred depths.\n  let preferredTargetIndex = targetDepths.indexOf(preferredTarget)\n\n  let leftNodes = [], preferredDepth = slice.openStart\n  for (let content = slice.content, i = 0;; i++) {\n    let node = content.firstChild\n    leftNodes.push(node)\n    if (i == slice.openStart) break\n    content = node.content\n  }\n  // Back up if the node directly above openStart, or the node above\n  // that separated only by a non-defining textblock node, is defining.\n  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining &&\n      $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type)\n    preferredDepth -= 1\n  else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining &&\n           $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type)\n    preferredDepth -= 2\n\n  for (let j = slice.openStart; j >= 0; j--) {\n    let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1)\n    let insert = leftNodes[openDepth]\n    if (!insert) continue\n    for (let i = 0; i < targetDepths.length; i++) {\n      // Loop over possible expansion levels, starting with the\n      // preferred one\n      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true\n      if (targetDepth < 0) { expand = false; targetDepth = -targetDepth }\n      let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1)\n      if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n        return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to,\n                            new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth),\n                                      openDepth, slice.openEnd))\n    }\n  }\n\n  let startSteps = this.steps.length\n  for (let i = targetDepths.length - 1; i >= 0; i--) {\n    this.replace(from, to, slice)\n    if (this.steps.length > startSteps) break\n    let depth = targetDepths[i]\n    if (depth < 0) continue\n    from = $from.before(depth); to = $to.after(depth)\n  }\n  return this\n}\n\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n  if (depth < oldOpen) {\n    let first = fragment.firstChild\n    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)))\n  }\n  if (depth > newOpen) {\n    let match = parent.contentMatchAt(0)\n    let start = match.fillBefore(fragment).append(fragment)\n    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true))\n  }\n  return fragment\n}\n\n// :: (number, number, Node) → this\n// Replace the given range with a node, but use `from` and `to` as\n// hints, rather than precise positions. When from and to are the same\n// and are at the start or end of a parent node in which the given\n// node doesn't fit, this method may _move_ them out towards a parent\n// that does allow the given node to be placed. When the given range\n// completely covers a parent node, this method may completely replace\n// that parent node.\nTransform.prototype.replaceRangeWith = function(from, to, node) {\n  if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {\n    let point = insertPoint(this.doc, from, node.type)\n    if (point != null) from = to = point\n  }\n  return this.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0))\n}\n\n// :: (number, number) → this\n// Delete the given range, expanding it to cover fully covered\n// parent nodes until a valid replace is found.\nTransform.prototype.deleteRange = function(from, to) {\n  let $from = this.doc.resolve(from), $to = this.doc.resolve(to)\n  let covered = coveredDepths($from, $to)\n  for (let i = 0; i < covered.length; i++) {\n    let depth = covered[i], last = i == covered.length - 1\n    if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)\n      return this.delete($from.start(depth), $to.end(depth))\n    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n      return this.delete($from.before(depth), $to.after(depth))\n  }\n  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {\n    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)\n      return this.delete($from.before(d), to)\n  }\n  return this.delete(from, to)\n}\n\n// : (ResolvedPos, ResolvedPos) → [number]\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\nfunction coveredDepths($from, $to) {\n  let result = [], minDepth = Math.min($from.depth, $to.depth)\n  for (let d = minDepth; d >= 0; d--) {\n    let start = $from.start(d)\n    if (start < $from.pos - ($from.depth - d) ||\n        $to.end(d) > $to.pos + ($to.depth - d) ||\n        $from.node(d).type.spec.isolating ||\n        $to.node(d).type.spec.isolating) break\n    if (start == $to.start(d) ||\n        (d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent &&\n         d && $to.start(d - 1) == start - 1))\n      result.push(d)\n  }\n  return result\n}\n","import {Mark} from \"./mark\"\n\n// ::- You can [_resolve_](#model.Node.resolve) a position to get more\n// information about it. Objects of this class represent such a\n// resolved position, providing various pieces of context information,\n// and some helper methods.\n//\n// Throughout this interface, methods that take an optional `depth`\n// parameter will interpret undefined as `this.depth` and negative\n// numbers as `this.depth + value`.\nexport class ResolvedPos {\n  constructor(pos, path, parentOffset) {\n    // :: number The position that was resolved.\n    this.pos = pos\n    this.path = path\n    // :: number\n    // The number of levels the parent node is from the root. If this\n    // position points directly into the root node, it is 0. If it\n    // points into a top-level paragraph, 1, and so on.\n    this.depth = path.length / 3 - 1\n    // :: number The offset this position has into its parent node.\n    this.parentOffset = parentOffset\n  }\n\n  resolveDepth(val) {\n    if (val == null) return this.depth\n    if (val < 0) return this.depth + val\n    return val\n  }\n\n  // :: Node\n  // The parent node that the position points into. Note that even if\n  // a position points into a text node, that node is not considered\n  // the parent—text nodes are ‘flat’ in this model, and have no content.\n  get parent() { return this.node(this.depth) }\n\n  // :: Node\n  // The root node in which the position was resolved.\n  get doc() { return this.node(0) }\n\n  // :: (?number) → Node\n  // The ancestor node at the given level. `p.node(p.depth)` is the\n  // same as `p.parent`.\n  node(depth) { return this.path[this.resolveDepth(depth) * 3] }\n\n  // :: (?number) → number\n  // The index into the ancestor at the given level. If this points at\n  // the 3rd node in the 2nd paragraph on the top level, for example,\n  // `p.index(0)` is 1 and `p.index(1)` is 2.\n  index(depth) { return this.path[this.resolveDepth(depth) * 3 + 1] }\n\n  // :: (?number) → number\n  // The index pointing after this position into the ancestor at the\n  // given level.\n  indexAfter(depth) {\n    depth = this.resolveDepth(depth)\n    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1)\n  }\n\n  // :: (?number) → number\n  // The (absolute) position at the start of the node at the given\n  // level.\n  start(depth) {\n    depth = this.resolveDepth(depth)\n    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n  }\n\n  // :: (?number) → number\n  // The (absolute) position at the end of the node at the given\n  // level.\n  end(depth) {\n    depth = this.resolveDepth(depth)\n    return this.start(depth) + this.node(depth).content.size\n  }\n\n  // :: (?number) → number\n  // The (absolute) position directly before the wrapping node at the\n  // given level, or, when `depth` is `this.depth + 1`, the original\n  // position.\n  before(depth) {\n    depth = this.resolveDepth(depth)\n    if (!depth) throw new RangeError(\"There is no position before the top-level node\")\n    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1]\n  }\n\n  // :: (?number) → number\n  // The (absolute) position directly after the wrapping node at the\n  // given level, or the original position when `depth` is `this.depth + 1`.\n  after(depth) {\n    depth = this.resolveDepth(depth)\n    if (!depth) throw new RangeError(\"There is no position after the top-level node\")\n    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize\n  }\n\n  // :: number\n  // When this position points into a text node, this returns the\n  // distance between the position and the start of the text node.\n  // Will be zero for positions that point between nodes.\n  get textOffset() { return this.pos - this.path[this.path.length - 1] }\n\n  // :: ?Node\n  // Get the node directly after the position, if any. If the position\n  // points into a text node, only the part of that node after the\n  // position is returned.\n  get nodeAfter() {\n    let parent = this.parent, index = this.index(this.depth)\n    if (index == parent.childCount) return null\n    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index)\n    return dOff ? parent.child(index).cut(dOff) : child\n  }\n\n  // :: ?Node\n  // Get the node directly before the position, if any. If the\n  // position points into a text node, only the part of that node\n  // before the position is returned.\n  get nodeBefore() {\n    let index = this.index(this.depth)\n    let dOff = this.pos - this.path[this.path.length - 1]\n    if (dOff) return this.parent.child(index).cut(0, dOff)\n    return index == 0 ? null : this.parent.child(index - 1)\n  }\n\n  // :: (number, ?number) → number\n  // Get the position at the given index in the parent node at the\n  // given depth (which defaults to `this.depth`).\n  posAtIndex(index, depth) {\n    depth = this.resolveDepth(depth)\n    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n    for (let i = 0; i < index; i++) pos += node.child(i).nodeSize\n    return pos\n  }\n\n  // :: () → [Mark]\n  // Get the marks at this position, factoring in the surrounding\n  // marks' [`inclusive`](#model.MarkSpec.inclusive) property. If the\n  // position is at the start of a non-empty node, the marks of the\n  // node after it (if any) are returned.\n  marks() {\n    let parent = this.parent, index = this.index()\n\n    // In an empty parent, return the empty array\n    if (parent.content.size == 0) return Mark.none\n\n    // When inside a text node, just return the text node's marks\n    if (this.textOffset) return parent.child(index).marks\n\n    let main = parent.maybeChild(index - 1), other = parent.maybeChild(index)\n    // If the `after` flag is true of there is no node before, make\n    // the node after this position the main reference.\n    if (!main) { let tmp = main; main = other; other = tmp }\n\n    // Use all marks in the main node, except those that have\n    // `inclusive` set to false and are not present in the other node.\n    let marks = main.marks\n    for (var i = 0; i < marks.length; i++)\n      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))\n        marks = marks[i--].removeFromSet(marks)\n\n    return marks\n  }\n\n  // :: (ResolvedPos) → ?[Mark]\n  // Get the marks after the current position, if any, except those\n  // that are non-inclusive and not present at position `$end`. This\n  // is mostly useful for getting the set of marks to preserve after a\n  // deletion. Will return `null` if this position is at the end of\n  // its parent node or its parent node isn't a textblock (in which\n  // case no marks should be preserved).\n  marksAcross($end) {\n    let after = this.parent.maybeChild(this.index())\n    if (!after || !after.isInline) return null\n\n    let marks = after.marks, next = $end.parent.maybeChild($end.index())\n    for (var i = 0; i < marks.length; i++)\n      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))\n        marks = marks[i--].removeFromSet(marks)\n    return marks\n  }\n\n  // :: (number) → number\n  // The depth up to which this position and the given (non-resolved)\n  // position share the same parent nodes.\n  sharedDepth(pos) {\n    for (let depth = this.depth; depth > 0; depth--)\n      if (this.start(depth) <= pos && this.end(depth) >= pos) return depth\n    return 0\n  }\n\n  // :: (?ResolvedPos, ?(Node) → bool) → ?NodeRange\n  // Returns a range based on the place where this position and the\n  // given position diverge around block content. If both point into\n  // the same textblock, for example, a range around that textblock\n  // will be returned. If they point into different blocks, the range\n  // around those blocks in their shared ancestor is returned. You can\n  // pass in an optional predicate that will be called with a parent\n  // node to see if a range into that parent is acceptable.\n  blockRange(other = this, pred) {\n    if (other.pos < this.pos) return other.blockRange(this)\n    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)\n      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))\n        return new NodeRange(this, other, d)\n  }\n\n  // :: (ResolvedPos) → bool\n  // Query whether the given position shares the same parent node.\n  sameParent(other) {\n    return this.pos - this.parentOffset == other.pos - other.parentOffset\n  }\n\n  // :: (ResolvedPos) → ResolvedPos\n  // Return the greater of this and the given position.\n  max(other) {\n    return other.pos > this.pos ? other : this\n  }\n\n  // :: (ResolvedPos) → ResolvedPos\n  // Return the smaller of this and the given position.\n  min(other) {\n    return other.pos < this.pos ? other : this\n  }\n\n  toString() {\n    let str = \"\"\n    for (let i = 1; i <= this.depth; i++)\n      str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1)\n    return str + \":\" + this.parentOffset\n  }\n\n  static resolve(doc, pos) {\n    if (!(pos >= 0 && pos <= doc.content.size)) throw new RangeError(\"Position \" + pos + \" out of range\")\n    let path = []\n    let start = 0, parentOffset = pos\n    for (let node = doc;;) {\n      let {index, offset} = node.content.findIndex(parentOffset)\n      let rem = parentOffset - offset\n      path.push(node, index, start + offset)\n      if (!rem) break\n      node = node.child(index)\n      if (node.isText) break\n      parentOffset = rem - 1\n      start += offset + 1\n    }\n    return new ResolvedPos(pos, path, parentOffset)\n  }\n\n  static resolveCached(doc, pos) {\n    for (let i = 0; i < resolveCache.length; i++) {\n      let cached = resolveCache[i]\n      if (cached.pos == pos && cached.doc == doc) return cached\n    }\n    let result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos)\n    resolveCachePos = (resolveCachePos + 1) % resolveCacheSize\n    return result\n  }\n}\n\nlet resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12\n\n// ::- Represents a flat range of content, i.e. one that starts and\n// ends in the same node.\nexport class NodeRange {\n  // :: (ResolvedPos, ResolvedPos, number)\n  // Construct a node range. `$from` and `$to` should point into the\n  // same node until at least the given `depth`, since a node range\n  // denotes an adjacent set of nodes in a single parent node.\n  constructor($from, $to, depth) {\n    // :: ResolvedPos A resolved position along the start of the\n    // content. May have a `depth` greater than this object's `depth`\n    // property, since these are the positions that were used to\n    // compute the range, not re-resolved positions directly at its\n    // boundaries.\n    this.$from = $from\n    // :: ResolvedPos A position along the end of the content. See\n    // caveat for [`$from`](#model.NodeRange.$from).\n    this.$to = $to\n    // :: number The depth of the node that this range points into.\n    this.depth = depth\n  }\n\n  // :: number The position at the start of the range.\n  get start() { return this.$from.before(this.depth + 1) }\n  // :: number The position at the end of the range.\n  get end() { return this.$to.after(this.depth + 1) }\n\n  // :: Node The parent node that the range points into.\n  get parent() { return this.$from.node(this.depth) }\n  // :: number The start index of the range in the parent node.\n  get startIndex() { return this.$from.index(this.depth) }\n  // :: number The end index of the range in the parent node.\n  get endIndex() { return this.$to.indexAfter(this.depth) }\n}\n","import {Fragment} from \"./fragment\"\nimport {Mark} from \"./mark\"\nimport {Slice, replace} from \"./replace\"\nimport {ResolvedPos} from \"./resolvedpos\"\nimport {compareDeep} from \"./comparedeep\"\n\nconst emptyAttrs = Object.create(null)\n\n// ::- This class represents a node in the tree that makes up a\n// ProseMirror document. So a document is an instance of `Node`, with\n// children that are also instances of `Node`.\n//\n// Nodes are persistent data structures. Instead of changing them, you\n// create new ones with the content you want. Old ones keep pointing\n// at the old document shape. This is made cheaper by sharing\n// structure between the old and new data as much as possible, which a\n// tree shape like this (without back pointers) makes easy.\n//\n// **Do not** directly mutate the properties of a `Node` object. See\n// [the guide](/docs/guide/#doc) for more information.\nexport class Node {\n  constructor(type, attrs, content, marks) {\n    // :: NodeType\n    // The type of node that this is.\n    this.type = type\n\n    // :: Object\n    // An object mapping attribute names to values. The kind of\n    // attributes allowed and required are\n    // [determined](#model.NodeSpec.attrs) by the node type.\n    this.attrs = attrs\n\n    // :: Fragment\n    // A container holding the node's children.\n    this.content = content || Fragment.empty\n\n    // :: [Mark]\n    // The marks (things like whether it is emphasized or part of a\n    // link) applied to this node.\n    this.marks = marks || Mark.none\n  }\n\n  // text:: ?string\n  // For text nodes, this contains the node's text content.\n\n  // :: number\n  // The size of this node, as defined by the integer-based [indexing\n  // scheme](/docs/guide/#doc.indexing). For text nodes, this is the\n  // amount of characters. For other leaf nodes, it is one. For\n  // non-leaf nodes, it is the size of the content plus two (the start\n  // and end token).\n  get nodeSize() { return this.isLeaf ? 1 : 2 + this.content.size }\n\n  // :: number\n  // The number of children that the node has.\n  get childCount() { return this.content.childCount }\n\n  // :: (number) → Node\n  // Get the child node at the given index. Raises an error when the\n  // index is out of range.\n  child(index) { return this.content.child(index) }\n\n  // :: (number) → ?Node\n  // Get the child node at the given index, if it exists.\n  maybeChild(index) { return this.content.maybeChild(index) }\n\n  // :: ((node: Node, offset: number, index: number))\n  // Call `f` for every child node, passing the node, its offset\n  // into this parent node, and its index.\n  forEach(f) { this.content.forEach(f) }\n\n  // :: (number, number, (node: Node, pos: number, parent: Node, index: number) → ?bool, ?number)\n  // Invoke a callback for all descendant nodes recursively between\n  // the given two positions that are relative to start of this node's\n  // content. The callback is invoked with the node, its\n  // parent-relative position, its parent node, and its child index.\n  // When the callback returns false for a given node, that node's\n  // children will not be recursed over. The last parameter can be\n  // used to specify a starting position to count from.\n  nodesBetween(from, to, f, startPos = 0) {\n    this.content.nodesBetween(from, to, f, startPos, this)\n  }\n\n  // :: ((node: Node, pos: number, parent: Node, index: number) → ?bool)\n  // Call the given callback for every descendant node. Doesn't\n  // descend into a node when the callback returns `false`.\n  descendants(f) {\n    this.nodesBetween(0, this.content.size, f)\n  }\n\n  // :: string\n  // Concatenates all the text nodes found in this fragment and its\n  // children.\n  get textContent() { return this.textBetween(0, this.content.size, \"\") }\n\n  // :: (number, number, ?string, ?union<string, ?(leafNode: Node) -> string>) → string\n  // Get all text between positions `from` and `to`. When\n  // `blockSeparator` is given, it will be inserted to separate text\n  // from different block nodes. When `leafText` is given, it'll be\n  // inserted for every non-text leaf node encountered.\n  textBetween(from, to, blockSeparator, leafText) {\n    return this.content.textBetween(from, to, blockSeparator, leafText)\n  }\n\n  // :: ?Node\n  // Returns this node's first child, or `null` if there are no\n  // children.\n  get firstChild() { return this.content.firstChild }\n\n  // :: ?Node\n  // Returns this node's last child, or `null` if there are no\n  // children.\n  get lastChild() { return this.content.lastChild }\n\n  // :: (Node) → bool\n  // Test whether two nodes represent the same piece of document.\n  eq(other) {\n    return this == other || (this.sameMarkup(other) && this.content.eq(other.content))\n  }\n\n  // :: (Node) → bool\n  // Compare the markup (type, attributes, and marks) of this node to\n  // those of another. Returns `true` if both have the same markup.\n  sameMarkup(other) {\n    return this.hasMarkup(other.type, other.attrs, other.marks)\n  }\n\n  // :: (NodeType, ?Object, ?[Mark]) → bool\n  // Check whether this node's markup correspond to the given type,\n  // attributes, and marks.\n  hasMarkup(type, attrs, marks) {\n    return this.type == type &&\n      compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&\n      Mark.sameSet(this.marks, marks || Mark.none)\n  }\n\n  // :: (?Fragment) → Node\n  // Create a new node with the same markup as this node, containing\n  // the given content (or empty, if no content is given).\n  copy(content = null) {\n    if (content == this.content) return this\n    return new this.constructor(this.type, this.attrs, content, this.marks)\n  }\n\n  // :: ([Mark]) → Node\n  // Create a copy of this node, with the given set of marks instead\n  // of the node's own marks.\n  mark(marks) {\n    return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks)\n  }\n\n  // :: (number, ?number) → Node\n  // Create a copy of this node with only the content between the\n  // given positions. If `to` is not given, it defaults to the end of\n  // the node.\n  cut(from, to) {\n    if (from == 0 && to == this.content.size) return this\n    return this.copy(this.content.cut(from, to))\n  }\n\n  // :: (number, ?number) → Slice\n  // Cut out the part of the document between the given positions, and\n  // return it as a `Slice` object.\n  slice(from, to = this.content.size, includeParents = false) {\n    if (from == to) return Slice.empty\n\n    let $from = this.resolve(from), $to = this.resolve(to)\n    let depth = includeParents ? 0 : $from.sharedDepth(to)\n    let start = $from.start(depth), node = $from.node(depth)\n    let content = node.content.cut($from.pos - start, $to.pos - start)\n    return new Slice(content, $from.depth - depth, $to.depth - depth)\n  }\n\n  // :: (number, number, Slice) → Node\n  // Replace the part of the document between the given positions with\n  // the given slice. The slice must 'fit', meaning its open sides\n  // must be able to connect to the surrounding content, and its\n  // content nodes must be valid children for the node they are placed\n  // into. If any of this is violated, an error of type\n  // [`ReplaceError`](#model.ReplaceError) is thrown.\n  replace(from, to, slice) {\n    return replace(this.resolve(from), this.resolve(to), slice)\n  }\n\n  // :: (number) → ?Node\n  // Find the node directly after the given position.\n  nodeAt(pos) {\n    for (let node = this;;) {\n      let {index, offset} = node.content.findIndex(pos)\n      node = node.maybeChild(index)\n      if (!node) return null\n      if (offset == pos || node.isText) return node\n      pos -= offset + 1\n    }\n  }\n\n  // :: (number) → {node: ?Node, index: number, offset: number}\n  // Find the (direct) child node after the given offset, if any,\n  // and return it along with its index and offset relative to this\n  // node.\n  childAfter(pos) {\n    let {index, offset} = this.content.findIndex(pos)\n    return {node: this.content.maybeChild(index), index, offset}\n  }\n\n  // :: (number) → {node: ?Node, index: number, offset: number}\n  // Find the (direct) child node before the given offset, if any,\n  // and return it along with its index and offset relative to this\n  // node.\n  childBefore(pos) {\n    if (pos == 0) return {node: null, index: 0, offset: 0}\n    let {index, offset} = this.content.findIndex(pos)\n    if (offset < pos) return {node: this.content.child(index), index, offset}\n    let node = this.content.child(index - 1)\n    return {node, index: index - 1, offset: offset - node.nodeSize}\n  }\n\n  // :: (number) → ResolvedPos\n  // Resolve the given position in the document, returning an\n  // [object](#model.ResolvedPos) with information about its context.\n  resolve(pos) { return ResolvedPos.resolveCached(this, pos) }\n\n  resolveNoCache(pos) { return ResolvedPos.resolve(this, pos) }\n\n  // :: (number, number, union<Mark, MarkType>) → bool\n  // Test whether a given mark or mark type occurs in this document\n  // between the two given positions.\n  rangeHasMark(from, to, type) {\n    let found = false\n    if (to > from) this.nodesBetween(from, to, node => {\n      if (type.isInSet(node.marks)) found = true\n      return !found\n    })\n    return found\n  }\n\n  // :: bool\n  // True when this is a block (non-inline node)\n  get isBlock() { return this.type.isBlock }\n\n  // :: bool\n  // True when this is a textblock node, a block node with inline\n  // content.\n  get isTextblock() { return this.type.isTextblock }\n\n  // :: bool\n  // True when this node allows inline content.\n  get inlineContent() { return this.type.inlineContent }\n\n  // :: bool\n  // True when this is an inline node (a text node or a node that can\n  // appear among text).\n  get isInline() { return this.type.isInline }\n\n  // :: bool\n  // True when this is a text node.\n  get isText() { return this.type.isText }\n\n  // :: bool\n  // True when this is a leaf node.\n  get isLeaf() { return this.type.isLeaf }\n\n  // :: bool\n  // True when this is an atom, i.e. when it does not have directly\n  // editable content. This is usually the same as `isLeaf`, but can\n  // be configured with the [`atom` property](#model.NodeSpec.atom) on\n  // a node's spec (typically used when the node is displayed as an\n  // uneditable [node view](#view.NodeView)).\n  get isAtom() { return this.type.isAtom }\n\n  // :: () → string\n  // Return a string representation of this node for debugging\n  // purposes.\n  toString() {\n    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)\n    let name = this.type.name\n    if (this.content.size)\n      name += \"(\" + this.content.toStringInner() + \")\"\n    return wrapMarks(this.marks, name)\n  }\n\n  // :: (number) → ContentMatch\n  // Get the content match in this node at the given index.\n  contentMatchAt(index) {\n    let match = this.type.contentMatch.matchFragment(this.content, 0, index)\n    if (!match) throw new Error(\"Called contentMatchAt on a node with invalid content\")\n    return match\n  }\n\n  // :: (number, number, ?Fragment, ?number, ?number) → bool\n  // Test whether replacing the range between `from` and `to` (by\n  // child index) with the given replacement fragment (which defaults\n  // to the empty fragment) would leave the node's content valid. You\n  // can optionally pass `start` and `end` indices into the\n  // replacement fragment.\n  canReplace(from, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {\n    let one = this.contentMatchAt(from).matchFragment(replacement, start, end)\n    let two = one && one.matchFragment(this.content, to)\n    if (!two || !two.validEnd) return false\n    for (let i = start; i < end; i++) if (!this.type.allowsMarks(replacement.child(i).marks)) return false\n    return true\n  }\n\n  // :: (number, number, NodeType, ?[Mark]) → bool\n  // Test whether replacing the range `from` to `to` (by index) with a\n  // node of the given type would leave the node's content valid.\n  canReplaceWith(from, to, type, marks) {\n    if (marks && !this.type.allowsMarks(marks)) return false\n    let start = this.contentMatchAt(from).matchType(type)\n    let end = start && start.matchFragment(this.content, to)\n    return end ? end.validEnd : false\n  }\n\n  // :: (Node) → bool\n  // Test whether the given node's content could be appended to this\n  // node. If that node is empty, this will only return true if there\n  // is at least one node type that can appear in both nodes (to avoid\n  // merging completely incompatible nodes).\n  canAppend(other) {\n    if (other.content.size) return this.canReplace(this.childCount, this.childCount, other.content)\n    else return this.type.compatibleContent(other.type)\n  }\n\n  // :: ()\n  // Check whether this node and its descendants conform to the\n  // schema, and raise error when they do not.\n  check() {\n    if (!this.type.validContent(this.content))\n      throw new RangeError(`Invalid content for node ${this.type.name}: ${this.content.toString().slice(0, 50)}`)\n    let copy = Mark.none\n    for (let i = 0; i < this.marks.length; i++) copy = this.marks[i].addToSet(copy)\n    if (!Mark.sameSet(copy, this.marks))\n      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map(m => m.type.name)}`)\n    this.content.forEach(node => node.check())\n  }\n\n  // :: () → Object\n  // Return a JSON-serializeable representation of this node.\n  toJSON() {\n    let obj = {type: this.type.name}\n    for (let _ in this.attrs) {\n      obj.attrs = this.attrs\n      break\n    }\n    if (this.content.size)\n      obj.content = this.content.toJSON()\n    if (this.marks.length)\n      obj.marks = this.marks.map(n => n.toJSON())\n    return obj\n  }\n\n  // :: (Schema, Object) → Node\n  // Deserialize a node from its JSON representation.\n  static fromJSON(schema, json) {\n    if (!json) throw new RangeError(\"Invalid input for Node.fromJSON\")\n    let marks = null\n    if (json.marks) {\n      if (!Array.isArray(json.marks)) throw new RangeError(\"Invalid mark data for Node.fromJSON\")\n      marks = json.marks.map(schema.markFromJSON)\n    }\n    if (json.type == \"text\") {\n      if (typeof json.text != \"string\") throw new RangeError(\"Invalid text node in JSON\")\n      return schema.text(json.text, marks)\n    }\n    let content = Fragment.fromJSON(schema, json.content)\n    return schema.nodeType(json.type).create(json.attrs, content, marks)\n  }\n}\n\nexport class TextNode extends Node {\n  constructor(type, attrs, content, marks) {\n    super(type, attrs, null, marks)\n\n    if (!content) throw new RangeError(\"Empty text nodes are not allowed\")\n\n    this.text = content\n  }\n\n  toString() {\n    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)\n    return wrapMarks(this.marks, JSON.stringify(this.text))\n  }\n\n  get textContent() { return this.text }\n\n  textBetween(from, to) { return this.text.slice(from, to) }\n\n  get nodeSize() { return this.text.length }\n\n  mark(marks) {\n    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks)\n  }\n\n  withText(text) {\n    if (text == this.text) return this\n    return new TextNode(this.type, this.attrs, text, this.marks)\n  }\n\n  cut(from = 0, to = this.text.length) {\n    if (from == 0 && to == this.text.length) return this\n    return this.withText(this.text.slice(from, to))\n  }\n\n  eq(other) {\n    return this.sameMarkup(other) && this.text == other.text\n  }\n\n  toJSON() {\n    let base = super.toJSON()\n    base.text = this.text\n    return base\n  }\n}\n\nfunction wrapMarks(marks, str) {\n  for (let i = marks.length - 1; i >= 0; i--)\n    str = marks[i].type.name + \"(\" + str + \")\"\n  return str\n}\n","import {Fragment} from \"./fragment\"\n\n// ::- Instances of this class represent a match state of a node\n// type's [content expression](#model.NodeSpec.content), and can be\n// used to find out whether further content matches here, and whether\n// a given position is a valid end of the node.\nexport class ContentMatch {\n  constructor(validEnd) {\n    // :: bool\n    // True when this match state represents a valid end of the node.\n    this.validEnd = validEnd\n    this.next = []\n    this.wrapCache = []\n  }\n\n  static parse(string, nodeTypes) {\n    let stream = new TokenStream(string, nodeTypes)\n    if (stream.next == null) return ContentMatch.empty\n    let expr = parseExpr(stream)\n    if (stream.next) stream.err(\"Unexpected trailing text\")\n    let match = dfa(nfa(expr))\n    checkForDeadEnds(match, stream)\n    return match\n  }\n\n  // :: (NodeType) → ?ContentMatch\n  // Match a node type, returning a match after that node if\n  // successful.\n  matchType(type) {\n    for (let i = 0; i < this.next.length; i += 2)\n      if (this.next[i] == type) return this.next[i + 1]\n    return null\n  }\n\n  // :: (Fragment, ?number, ?number) → ?ContentMatch\n  // Try to match a fragment. Returns the resulting match when\n  // successful.\n  matchFragment(frag, start = 0, end = frag.childCount) {\n    let cur = this\n    for (let i = start; cur && i < end; i++)\n      cur = cur.matchType(frag.child(i).type)\n    return cur\n  }\n\n  get inlineContent() {\n    let first = this.next[0]\n    return first ? first.isInline : false\n  }\n\n  // :: ?NodeType\n  // Get the first matching node type at this match position that can\n  // be generated.\n  get defaultType() {\n    for (let i = 0; i < this.next.length; i += 2) {\n      let type = this.next[i]\n      if (!(type.isText || type.hasRequiredAttrs())) return type\n    }\n  }\n\n  compatible(other) {\n    for (let i = 0; i < this.next.length; i += 2)\n      for (let j = 0; j < other.next.length; j += 2)\n        if (this.next[i] == other.next[j]) return true\n    return false\n  }\n\n  // :: (Fragment, bool, ?number) → ?Fragment\n  // Try to match the given fragment, and if that fails, see if it can\n  // be made to match by inserting nodes in front of it. When\n  // successful, return a fragment of inserted nodes (which may be\n  // empty if nothing had to be inserted). When `toEnd` is true, only\n  // return a fragment if the resulting match goes to the end of the\n  // content expression.\n  fillBefore(after, toEnd = false, startIndex = 0) {\n    let seen = [this]\n    function search(match, types) {\n      let finished = match.matchFragment(after, startIndex)\n      if (finished && (!toEnd || finished.validEnd))\n        return Fragment.from(types.map(tp => tp.createAndFill()))\n\n      for (let i = 0; i < match.next.length; i += 2) {\n        let type = match.next[i], next = match.next[i + 1]\n        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n          seen.push(next)\n          let found = search(next, types.concat(type))\n          if (found) return found\n        }\n      }\n    }\n\n    return search(this, [])\n  }\n\n  // :: (NodeType) → ?[NodeType]\n  // Find a set of wrapping node types that would allow a node of the\n  // given type to appear at this position. The result may be empty\n  // (when it fits directly) and will be null when no such wrapping\n  // exists.\n  findWrapping(target) {\n    for (let i = 0; i < this.wrapCache.length; i += 2)\n      if (this.wrapCache[i] == target) return this.wrapCache[i + 1]\n    let computed = this.computeWrapping(target)\n    this.wrapCache.push(target, computed)\n    return computed\n  }\n\n  computeWrapping(target) {\n    let seen = Object.create(null), active = [{match: this, type: null, via: null}]\n    while (active.length) {\n      let current = active.shift(), match = current.match\n      if (match.matchType(target)) {\n        let result = []\n        for (let obj = current; obj.type; obj = obj.via)\n          result.push(obj.type)\n        return result.reverse()\n      }\n      for (let i = 0; i < match.next.length; i += 2) {\n        let type = match.next[i]\n        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {\n          active.push({match: type.contentMatch, type, via: current})\n          seen[type.name] = true\n        }\n      }\n    }\n  }\n\n  // :: number\n  // The number of outgoing edges this node has in the finite\n  // automaton that describes the content expression.\n  get edgeCount() {\n    return this.next.length >> 1\n  }\n\n  // :: (number) → {type: NodeType, next: ContentMatch}\n  // Get the _n_​th outgoing edge from this node in the finite\n  // automaton that describes the content expression.\n  edge(n) {\n    let i = n << 1\n    if (i >= this.next.length) throw new RangeError(`There's no ${n}th edge in this content match`)\n    return {type: this.next[i], next: this.next[i + 1]}\n  }\n\n  toString() {\n    let seen = []\n    function scan(m) {\n      seen.push(m)\n      for (let i = 1; i < m.next.length; i += 2)\n        if (seen.indexOf(m.next[i]) == -1) scan(m.next[i])\n    }\n    scan(this)\n    return seen.map((m, i) => {\n      let out = i + (m.validEnd ? \"*\" : \" \") + \" \"\n      for (let i = 0; i < m.next.length; i += 2)\n        out += (i ? \", \" : \"\") + m.next[i].name + \"->\" + seen.indexOf(m.next[i + 1])\n      return out\n    }).join(\"\\n\")\n  }\n}\n\nContentMatch.empty = new ContentMatch(true)\n\nclass TokenStream {\n  constructor(string, nodeTypes) {\n    this.string = string\n    this.nodeTypes = nodeTypes\n    this.inline = null\n    this.pos = 0\n    this.tokens = string.split(/\\s*(?=\\b|\\W|$)/)\n    if (this.tokens[this.tokens.length - 1] == \"\") this.tokens.pop()\n    if (this.tokens[0] == \"\") this.tokens.shift()\n  }\n\n  get next() { return this.tokens[this.pos] }\n\n  eat(tok) { return this.next == tok && (this.pos++ || true) }\n\n  err(str) { throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\") }\n}\n\nfunction parseExpr(stream) {\n  let exprs = []\n  do { exprs.push(parseExprSeq(stream)) }\n  while (stream.eat(\"|\"))\n  return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs}\n}\n\nfunction parseExprSeq(stream) {\n  let exprs = []\n  do { exprs.push(parseExprSubscript(stream)) }\n  while (stream.next && stream.next != \")\" && stream.next != \"|\")\n  return exprs.length == 1 ? exprs[0] : {type: \"seq\", exprs}\n}\n\nfunction parseExprSubscript(stream) {\n  let expr = parseExprAtom(stream)\n  for (;;) {\n    if (stream.eat(\"+\"))\n      expr = {type: \"plus\", expr}\n    else if (stream.eat(\"*\"))\n      expr = {type: \"star\", expr}\n    else if (stream.eat(\"?\"))\n      expr = {type: \"opt\", expr}\n    else if (stream.eat(\"{\"))\n      expr = parseExprRange(stream, expr)\n    else break\n  }\n  return expr\n}\n\nfunction parseNum(stream) {\n  if (/\\D/.test(stream.next)) stream.err(\"Expected number, got '\" + stream.next + \"'\")\n  let result = Number(stream.next)\n  stream.pos++\n  return result\n}\n\nfunction parseExprRange(stream, expr) {\n  let min = parseNum(stream), max = min\n  if (stream.eat(\",\")) {\n    if (stream.next != \"}\") max = parseNum(stream)\n    else max = -1\n  }\n  if (!stream.eat(\"}\")) stream.err(\"Unclosed braced range\")\n  return {type: \"range\", min, max, expr}\n}\n\nfunction resolveName(stream, name) {\n  let types = stream.nodeTypes, type = types[name]\n  if (type) return [type]\n  let result = []\n  for (let typeName in types) {\n    let type = types[typeName]\n    if (type.groups.indexOf(name) > -1) result.push(type)\n  }\n  if (result.length == 0) stream.err(\"No node type or group '\" + name + \"' found\")\n  return result\n}\n\nfunction parseExprAtom(stream) {\n  if (stream.eat(\"(\")) {\n    let expr = parseExpr(stream)\n    if (!stream.eat(\")\")) stream.err(\"Missing closing paren\")\n    return expr\n  } else if (!/\\W/.test(stream.next)) {\n    let exprs = resolveName(stream, stream.next).map(type => {\n      if (stream.inline == null) stream.inline = type.isInline\n      else if (stream.inline != type.isInline) stream.err(\"Mixing inline and block content\")\n      return {type: \"name\", value: type}\n    })\n    stream.pos++\n    return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs}\n  } else {\n    stream.err(\"Unexpected token '\" + stream.next + \"'\")\n  }\n}\n\n// The code below helps compile a regular-expression-like language\n// into a deterministic finite automaton. For a good introduction to\n// these concepts, see https://swtch.com/~rsc/regexp/regexp1.html\n\n// : (Object) → [[{term: ?any, to: number}]]\n// Construct an NFA from an expression as returned by the parser. The\n// NFA is represented as an array of states, which are themselves\n// arrays of edges, which are `{term, to}` objects. The first state is\n// the entry state and the last node is the success state.\n//\n// Note that unlike typical NFAs, the edge ordering in this one is\n// significant, in that it is used to contruct filler content when\n// necessary.\nfunction nfa(expr) {\n  let nfa = [[]]\n  connect(compile(expr, 0), node())\n  return nfa\n\n  function node() { return nfa.push([]) - 1 }\n  function edge(from, to, term) {\n    let edge = {term, to}\n    nfa[from].push(edge)\n    return edge\n  }\n  function connect(edges, to) { edges.forEach(edge => edge.to = to) }\n\n  function compile(expr, from) {\n    if (expr.type == \"choice\") {\n      return expr.exprs.reduce((out, expr) => out.concat(compile(expr, from)), [])\n    } else if (expr.type == \"seq\") {\n      for (let i = 0;; i++) {\n        let next = compile(expr.exprs[i], from)\n        if (i == expr.exprs.length - 1) return next\n        connect(next, from = node())\n      }\n    } else if (expr.type == \"star\") {\n      let loop = node()\n      edge(from, loop)\n      connect(compile(expr.expr, loop), loop)\n      return [edge(loop)]\n    } else if (expr.type == \"plus\") {\n      let loop = node()\n      connect(compile(expr.expr, from), loop)\n      connect(compile(expr.expr, loop), loop)\n      return [edge(loop)]\n    } else if (expr.type == \"opt\") {\n      return [edge(from)].concat(compile(expr.expr, from))\n    } else if (expr.type == \"range\") {\n      let cur = from\n      for (let i = 0; i < expr.min; i++) {\n        let next = node()\n        connect(compile(expr.expr, cur), next)\n        cur = next\n      }\n      if (expr.max == -1) {\n        connect(compile(expr.expr, cur), cur)\n      } else {\n        for (let i = expr.min; i < expr.max; i++) {\n          let next = node()\n          edge(cur, next)\n          connect(compile(expr.expr, cur), next)\n          cur = next\n        }\n      }\n      return [edge(cur)]\n    } else if (expr.type == \"name\") {\n      return [edge(from, null, expr.value)]\n    }\n  }\n}\n\nfunction cmp(a, b) { return b - a }\n\n// Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\nfunction nullFrom(nfa, node) {\n  let result = []\n  scan(node)\n  return result.sort(cmp)\n\n  function scan(node) {\n    let edges = nfa[node]\n    if (edges.length == 1 && !edges[0].term) return scan(edges[0].to)\n    result.push(node)\n    for (let i = 0; i < edges.length; i++) {\n      let {term, to} = edges[i]\n      if (!term && result.indexOf(to) == -1) scan(to)\n    }\n  }\n}\n\n// : ([[{term: ?any, to: number}]]) → ContentMatch\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\nfunction dfa(nfa) {\n  let labeled = Object.create(null)\n  return explore(nullFrom(nfa, 0))\n\n  function explore(states) {\n    let out = []\n    states.forEach(node => {\n      nfa[node].forEach(({term, to}) => {\n        if (!term) return\n        let known = out.indexOf(term), set = known > -1 && out[known + 1]\n        nullFrom(nfa, to).forEach(node => {\n          if (!set) out.push(term, set = [])\n          if (set.indexOf(node) == -1) set.push(node)\n        })\n      })\n    })\n    let state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1)\n    for (let i = 0; i < out.length; i += 2) {\n      let states = out[i + 1].sort(cmp)\n      state.next.push(out[i], labeled[states.join(\",\")] || explore(states))\n    }\n    return state\n  }\n}\n\nfunction checkForDeadEnds(match, stream) {\n  for (let i = 0, work = [match]; i < work.length; i++) {\n    let state = work[i], dead = !state.validEnd, nodes = []\n    for (let j = 0; j < state.next.length; j += 2) {\n      let node = state.next[j], next = state.next[j + 1]\n      nodes.push(node.name)\n      if (dead && !(node.isText || node.hasRequiredAttrs())) dead = false\n      if (work.indexOf(next) == -1) work.push(next)\n    }\n    if (dead) stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\")\n  }\n}\n","import OrderedMap from \"orderedmap\"\n\nimport {Node, TextNode} from \"./node\"\nimport {Fragment} from \"./fragment\"\nimport {Mark} from \"./mark\"\nimport {ContentMatch} from \"./content\"\n\n// For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\nfunction defaultAttrs(attrs) {\n  let defaults = Object.create(null)\n  for (let attrName in attrs) {\n    let attr = attrs[attrName]\n    if (!attr.hasDefault) return null\n    defaults[attrName] = attr.default\n  }\n  return defaults\n}\n\nfunction computeAttrs(attrs, value) {\n  let built = Object.create(null)\n  for (let name in attrs) {\n    let given = value && value[name]\n    if (given === undefined) {\n      let attr = attrs[name]\n      if (attr.hasDefault) given = attr.default\n      else throw new RangeError(\"No value supplied for attribute \" + name)\n    }\n    built[name] = given\n  }\n  return built\n}\n\nfunction initAttrs(attrs) {\n  let result = Object.create(null)\n  if (attrs) for (let name in attrs) result[name] = new Attribute(attrs[name])\n  return result\n}\n\n// ::- Node types are objects allocated once per `Schema` and used to\n// [tag](#model.Node.type) `Node` instances. They contain information\n// about the node type, such as its name and what kind of node it\n// represents.\nexport class NodeType {\n  constructor(name, schema, spec) {\n    // :: string\n    // The name the node type has in this schema.\n    this.name = name\n\n    // :: Schema\n    // A link back to the `Schema` the node type belongs to.\n    this.schema = schema\n\n    // :: NodeSpec\n    // The spec that this type is based on\n    this.spec = spec\n\n    this.groups = spec.group ? spec.group.split(\" \") : []\n    this.attrs = initAttrs(spec.attrs)\n\n    this.defaultAttrs = defaultAttrs(this.attrs)\n\n    // :: ContentMatch\n    // The starting match of the node type's content expression.\n    this.contentMatch = null\n\n    // : ?[MarkType]\n    // The set of marks allowed in this node. `null` means all marks\n    // are allowed.\n    this.markSet = null\n\n    // :: bool\n    // True if this node type has inline content.\n    this.inlineContent = null\n\n    // :: bool\n    // True if this is a block type\n    this.isBlock = !(spec.inline || name == \"text\")\n\n    // :: bool\n    // True if this is the text node type.\n    this.isText = name == \"text\"\n  }\n\n  // :: bool\n  // True if this is an inline type.\n  get isInline() { return !this.isBlock }\n\n  // :: bool\n  // True if this is a textblock type, a block that contains inline\n  // content.\n  get isTextblock() { return this.isBlock && this.inlineContent }\n\n  // :: bool\n  // True for node types that allow no content.\n  get isLeaf() { return this.contentMatch == ContentMatch.empty }\n\n  // :: bool\n  // True when this node is an atom, i.e. when it does not have\n  // directly editable content.\n  get isAtom() { return this.isLeaf || this.spec.atom }\n\n  // :: union<\"pre\", \"normal\">\n  // The node type's [whitespace](#view.NodeSpec.whitespace) option.\n  get whitespace() { return this.spec.whitespace || (this.spec.code ? \"pre\" : \"normal\") }\n\n  // :: () → bool\n  // Tells you whether this node type has any required attributes.\n  hasRequiredAttrs() {\n    for (let n in this.attrs) if (this.attrs[n].isRequired) return true\n    return false\n  }\n\n  compatibleContent(other) {\n    return this == other || this.contentMatch.compatible(other.contentMatch)\n  }\n\n  computeAttrs(attrs) {\n    if (!attrs && this.defaultAttrs) return this.defaultAttrs\n    else return computeAttrs(this.attrs, attrs)\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Create a `Node` of this type. The given attributes are\n  // checked and defaulted (you can pass `null` to use the type's\n  // defaults entirely, if no required attributes exist). `content`\n  // may be a `Fragment`, a node, an array of nodes, or\n  // `null`. Similarly `marks` may be `null` to default to the empty\n  // set of marks.\n  create(attrs, content, marks) {\n    if (this.isText) throw new Error(\"NodeType.create can't construct text nodes\")\n    return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks))\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Like [`create`](#model.NodeType.create), but check the given content\n  // against the node type's content restrictions, and throw an error\n  // if it doesn't match.\n  createChecked(attrs, content, marks) {\n    content = Fragment.from(content)\n    if (!this.validContent(content))\n      throw new RangeError(\"Invalid content for node \" + this.name)\n    return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks))\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → ?Node\n  // Like [`create`](#model.NodeType.create), but see if it is necessary to\n  // add nodes to the start or end of the given fragment to make it\n  // fit the node. If no fitting wrapping can be found, return null.\n  // Note that, due to the fact that required nodes can always be\n  // created, this will always succeed if you pass null or\n  // `Fragment.empty` as content.\n  createAndFill(attrs, content, marks) {\n    attrs = this.computeAttrs(attrs)\n    content = Fragment.from(content)\n    if (content.size) {\n      let before = this.contentMatch.fillBefore(content)\n      if (!before) return null\n      content = before.append(content)\n    }\n    let after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true)\n    if (!after) return null\n    return new Node(this, attrs, content.append(after), Mark.setFrom(marks))\n  }\n\n  // :: (Fragment) → bool\n  // Returns true if the given fragment is valid content for this node\n  // type with the given attributes.\n  validContent(content) {\n    let result = this.contentMatch.matchFragment(content)\n    if (!result || !result.validEnd) return false\n    for (let i = 0; i < content.childCount; i++)\n      if (!this.allowsMarks(content.child(i).marks)) return false\n    return true\n  }\n\n  // :: (MarkType) → bool\n  // Check whether the given mark type is allowed in this node.\n  allowsMarkType(markType) {\n    return this.markSet == null || this.markSet.indexOf(markType) > -1\n  }\n\n  // :: ([Mark]) → bool\n  // Test whether the given set of marks are allowed in this node.\n  allowsMarks(marks) {\n    if (this.markSet == null) return true\n    for (let i = 0; i < marks.length; i++) if (!this.allowsMarkType(marks[i].type)) return false\n    return true\n  }\n\n  // :: ([Mark]) → [Mark]\n  // Removes the marks that are not allowed in this node from the given set.\n  allowedMarks(marks) {\n    if (this.markSet == null) return marks\n    let copy\n    for (let i = 0; i < marks.length; i++) {\n      if (!this.allowsMarkType(marks[i].type)) {\n        if (!copy) copy = marks.slice(0, i)\n      } else if (copy) {\n        copy.push(marks[i])\n      }\n    }\n    return !copy ? marks : copy.length ? copy : Mark.empty\n  }\n\n  static compile(nodes, schema) {\n    let result = Object.create(null)\n    nodes.forEach((name, spec) => result[name] = new NodeType(name, schema, spec))\n\n    let topType = schema.spec.topNode || \"doc\"\n    if (!result[topType]) throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\")\n    if (!result.text) throw new RangeError(\"Every schema needs a 'text' type\")\n    for (let _ in result.text.attrs) throw new RangeError(\"The text node type should not have attributes\")\n\n    return result\n  }\n}\n\n// Attribute descriptors\n\nclass Attribute {\n  constructor(options) {\n    this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\")\n    this.default = options.default\n  }\n\n  get isRequired() {\n    return !this.hasDefault\n  }\n}\n\n// Marks\n\n// ::- Like nodes, marks (which are associated with nodes to signify\n// things like emphasis or being part of a link) are\n// [tagged](#model.Mark.type) with type objects, which are\n// instantiated once per `Schema`.\nexport class MarkType {\n  constructor(name, rank, schema, spec) {\n    // :: string\n    // The name of the mark type.\n    this.name = name\n\n    // :: Schema\n    // The schema that this mark type instance is part of.\n    this.schema = schema\n\n    // :: MarkSpec\n    // The spec on which the type is based.\n    this.spec = spec\n\n    this.attrs = initAttrs(spec.attrs)\n\n    this.rank = rank\n    this.excluded = null\n    let defaults = defaultAttrs(this.attrs)\n    this.instance = defaults && new Mark(this, defaults)\n  }\n\n  // :: (?Object) → Mark\n  // Create a mark of this type. `attrs` may be `null` or an object\n  // containing only some of the mark's attributes. The others, if\n  // they have defaults, will be added.\n  create(attrs) {\n    if (!attrs && this.instance) return this.instance\n    return new Mark(this, computeAttrs(this.attrs, attrs))\n  }\n\n  static compile(marks, schema) {\n    let result = Object.create(null), rank = 0\n    marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec))\n    return result\n  }\n\n  // :: ([Mark]) → [Mark]\n  // When there is a mark of this type in the given set, a new set\n  // without it is returned. Otherwise, the input set is returned.\n  removeFromSet(set) {\n    for (var i = 0; i < set.length; i++) if (set[i].type == this) {\n      set = set.slice(0, i).concat(set.slice(i + 1))\n      i--\n    }\n    return set\n  }\n\n  // :: ([Mark]) → ?Mark\n  // Tests whether there is a mark of this type in the given set.\n  isInSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (set[i].type == this) return set[i]\n  }\n\n  // :: (MarkType) → bool\n  // Queries whether a given mark type is\n  // [excluded](#model.MarkSpec.excludes) by this one.\n  excludes(other) {\n    return this.excluded.indexOf(other) > -1\n  }\n}\n\n// SchemaSpec:: interface\n// An object describing a schema, as passed to the [`Schema`](#model.Schema)\n// constructor.\n//\n//   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>\n//   The node types in this schema. Maps names to\n//   [`NodeSpec`](#model.NodeSpec) objects that describe the node type\n//   associated with that name. Their order is significant—it\n//   determines which [parse rules](#model.NodeSpec.parseDOM) take\n//   precedence by default, and which nodes come first in a given\n//   [group](#model.NodeSpec.group).\n//\n//   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>\n//   The mark types that exist in this schema. The order in which they\n//   are provided determines the order in which [mark\n//   sets](#model.Mark.addToSet) are sorted and in which [parse\n//   rules](#model.MarkSpec.parseDOM) are tried.\n//\n//   topNode:: ?string\n//   The name of the default top-level node for the schema. Defaults\n//   to `\"doc\"`.\n\n// NodeSpec:: interface\n//\n//   content:: ?string\n//   The content expression for this node, as described in the [schema\n//   guide](/docs/guide/#schema.content_expressions). When not given,\n//   the node does not allow any content.\n//\n//   marks:: ?string\n//   The marks that are allowed inside of this node. May be a\n//   space-separated string referring to mark names or groups, `\"_\"`\n//   to explicitly allow all marks, or `\"\"` to disallow marks. When\n//   not given, nodes with inline content default to allowing all\n//   marks, other nodes default to not allowing marks.\n//\n//   group:: ?string\n//   The group or space-separated groups to which this node belongs,\n//   which can be referred to in the content expressions for the\n//   schema.\n//\n//   inline:: ?bool\n//   Should be set to true for inline nodes. (Implied for text nodes.)\n//\n//   atom:: ?bool\n//   Can be set to true to indicate that, though this isn't a [leaf\n//   node](#model.NodeType.isLeaf), it doesn't have directly editable\n//   content and should be treated as a single unit in the view.\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that nodes of this type get.\n//\n//   selectable:: ?bool\n//   Controls whether nodes of this type can be selected as a [node\n//   selection](#state.NodeSelection). Defaults to true for non-text\n//   nodes.\n//\n//   draggable:: ?bool\n//   Determines whether nodes of this type can be dragged without\n//   being selected. Defaults to false.\n//\n//   code:: ?bool\n//   Can be used to indicate that this node contains code, which\n//   causes some commands to behave differently.\n//\n//   whitespace:: ?union<\"pre\", \"normal\">\n//   Controls way whitespace in this a node is parsed. The default is\n//   `\"normal\"`, which causes the [DOM parser](#model.DOMParser) to\n//   collapse whitespace in normal mode, and normalize it (replacing\n//   newlines and such with spaces) otherwise. `\"pre\"` causes the\n//   parser to preserve spaces inside the node. When this option isn't\n//   given, but [`code`](#model.NodeSpec.code) is true, `whitespace`\n//   will default to `\"pre\"`. Note that this option doesn't influence\n//   the way the node is rendered—that should be handled by `toDOM`\n//   and/or styling.\n//\n//   defining:: ?bool\n//   Determines whether this node is considered an important parent\n//   node during replace operations (such as paste). Non-defining (the\n//   default) nodes get dropped when their entire content is replaced,\n//   whereas defining nodes persist and wrap the inserted content.\n//   Likewise, in _inserted_ content the defining parents of the\n//   content are preserved when possible. Typically,\n//   non-default-paragraph textblock types, and possibly list items,\n//   are marked as defining.\n//\n//   isolating:: ?bool\n//   When enabled (default is false), the sides of nodes of this type\n//   count as boundaries that regular editing operations, like\n//   backspacing or lifting, won't cross. An example of a node that\n//   should probably have this enabled is a table cell.\n//\n//   toDOM:: ?(node: Node) → DOMOutputSpec\n//   Defines the default way a node of this type should be serialized\n//   to DOM/HTML (as used by\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)).\n//   Should return a DOM node or an [array\n//   structure](#model.DOMOutputSpec) that describes one, with an\n//   optional number zero (“hole”) in it to indicate where the node's\n//   content should be inserted.\n//\n//   For text nodes, the default is to create a text DOM node. Though\n//   it is possible to create a serializer where text is rendered\n//   differently, this is not supported inside the editor, so you\n//   shouldn't override that in your text node spec.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this node, which can be\n//   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to\n//   automatically derive a parser. The `node` field in the rules is\n//   implied (the name of this node will be filled in automatically).\n//   If you supply your own parser, you do not need to also specify\n//   parsing rules in your schema.\n//\n//   toDebugString:: ?(node: Node) -> string\n//   Defines the default way a node of this type should be serialized\n//   to a string representation for debugging (e.g. in error messages).\n\n// MarkSpec:: interface\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that marks of this type get.\n//\n//   inclusive:: ?bool\n//   Whether this mark should be active when the cursor is positioned\n//   at its end (or at its start when that is also the start of the\n//   parent node). Defaults to true.\n//\n//   excludes:: ?string\n//   Determines which other marks this mark can coexist with. Should\n//   be a space-separated strings naming other marks or groups of marks.\n//   When a mark is [added](#model.Mark.addToSet) to a set, all marks\n//   that it excludes are removed in the process. If the set contains\n//   any mark that excludes the new mark but is not, itself, excluded\n//   by the new mark, the mark can not be added an the set. You can\n//   use the value `\"_\"` to indicate that the mark excludes all\n//   marks in the schema.\n//\n//   Defaults to only being exclusive with marks of the same type. You\n//   can set it to an empty string (or any string not containing the\n//   mark's own name) to allow multiple marks of a given type to\n//   coexist (as long as they have different attributes).\n//\n//   group:: ?string\n//   The group or space-separated groups to which this mark belongs.\n//\n//   spanning:: ?bool\n//   Determines whether marks of this type can span multiple adjacent\n//   nodes when serialized to DOM/HTML. Defaults to true.\n//\n//   toDOM:: ?(mark: Mark, inline: bool) → DOMOutputSpec\n//   Defines the default way marks of this type should be serialized\n//   to DOM/HTML. When the resulting spec contains a hole, that is\n//   where the marked content is placed. Otherwise, it is appended to\n//   the top node.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this mark (see the\n//   corresponding [node spec field](#model.NodeSpec.parseDOM)). The\n//   `mark` field in the rules is implied.\n\n// AttributeSpec:: interface\n//\n// Used to [define](#model.NodeSpec.attrs) attributes on nodes or\n// marks.\n//\n//   default:: ?any\n//   The default value for this attribute, to use when no explicit\n//   value is provided. Attributes that have no default must be\n//   provided whenever a node or mark of a type that has them is\n//   created.\n\n// ::- A document schema. Holds [node](#model.NodeType) and [mark\n// type](#model.MarkType) objects for the nodes and marks that may\n// occur in conforming documents, and provides functionality for\n// creating and deserializing such documents.\nexport class Schema {\n  // :: (SchemaSpec)\n  // Construct a schema from a schema [specification](#model.SchemaSpec).\n  constructor(spec) {\n    // :: SchemaSpec\n    // The [spec](#model.SchemaSpec) on which the schema is based,\n    // with the added guarantee that its `nodes` and `marks`\n    // properties are\n    // [`OrderedMap`](https://github.com/marijnh/orderedmap) instances\n    // (not raw objects).\n    this.spec = {}\n    for (let prop in spec) this.spec[prop] = spec[prop]\n    this.spec.nodes = OrderedMap.from(spec.nodes)\n    this.spec.marks = OrderedMap.from(spec.marks)\n\n    // :: Object<NodeType>\n    // An object mapping the schema's node names to node type objects.\n    this.nodes = NodeType.compile(this.spec.nodes, this)\n\n    // :: Object<MarkType>\n    // A map from mark names to mark type objects.\n    this.marks = MarkType.compile(this.spec.marks, this)\n\n    let contentExprCache = Object.create(null)\n    for (let prop in this.nodes) {\n      if (prop in this.marks)\n        throw new RangeError(prop + \" can not be both a node and a mark\")\n      let type = this.nodes[prop], contentExpr = type.spec.content || \"\", markExpr = type.spec.marks\n      type.contentMatch = contentExprCache[contentExpr] ||\n        (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes))\n      type.inlineContent = type.contentMatch.inlineContent\n      type.markSet = markExpr == \"_\" ? null :\n        markExpr ? gatherMarks(this, markExpr.split(\" \")) :\n        markExpr == \"\" || !type.inlineContent ? [] : null\n    }\n    for (let prop in this.marks) {\n      let type = this.marks[prop], excl = type.spec.excludes\n      type.excluded = excl == null ? [type] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"))\n    }\n\n    this.nodeFromJSON = this.nodeFromJSON.bind(this)\n    this.markFromJSON = this.markFromJSON.bind(this)\n\n    // :: NodeType\n    // The type of the [default top node](#model.SchemaSpec.topNode)\n    // for this schema.\n    this.topNodeType = this.nodes[this.spec.topNode || \"doc\"]\n\n    // :: Object\n    // An object for storing whatever values modules may want to\n    // compute and cache per schema. (If you want to store something\n    // in it, try to use property names unlikely to clash.)\n    this.cached = Object.create(null)\n    this.cached.wrappings = Object.create(null)\n  }\n\n  // :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node\n  // Create a node in this schema. The `type` may be a string or a\n  // `NodeType` instance. Attributes will be extended\n  // with defaults, `content` may be a `Fragment`,\n  // `null`, a `Node`, or an array of nodes.\n  node(type, attrs, content, marks) {\n    if (typeof type == \"string\")\n      type = this.nodeType(type)\n    else if (!(type instanceof NodeType))\n      throw new RangeError(\"Invalid node type: \" + type)\n    else if (type.schema != this)\n      throw new RangeError(\"Node type from different schema used (\" + type.name + \")\")\n\n    return type.createChecked(attrs, content, marks)\n  }\n\n  // :: (string, ?[Mark]) → Node\n  // Create a text node in the schema. Empty text nodes are not\n  // allowed.\n  text(text, marks) {\n    let type = this.nodes.text\n    return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks))\n  }\n\n  // :: (union<string, MarkType>, ?Object) → Mark\n  // Create a mark with the given type and attributes.\n  mark(type, attrs) {\n    if (typeof type == \"string\") type = this.marks[type]\n    return type.create(attrs)\n  }\n\n  // :: (Object) → Node\n  // Deserialize a node from its JSON representation. This method is\n  // bound.\n  nodeFromJSON(json) {\n    return Node.fromJSON(this, json)\n  }\n\n  // :: (Object) → Mark\n  // Deserialize a mark from its JSON representation. This method is\n  // bound.\n  markFromJSON(json) {\n    return Mark.fromJSON(this, json)\n  }\n\n  nodeType(name) {\n    let found = this.nodes[name]\n    if (!found) throw new RangeError(\"Unknown node type: \" + name)\n    return found\n  }\n}\n\nfunction gatherMarks(schema, marks) {\n  let found = []\n  for (let i = 0; i < marks.length; i++) {\n    let name = marks[i], mark = schema.marks[name], ok = mark\n    if (mark) {\n      found.push(mark)\n    } else {\n      for (let prop in schema.marks) {\n        let mark = schema.marks[prop]\n        if (name == \"_\" || (mark.spec.group && mark.spec.group.split(\" \").indexOf(name) > -1))\n          found.push(ok = mark)\n      }\n    }\n    if (!ok) throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\")\n  }\n  return found\n}\n","import {Fragment} from \"./fragment\"\nimport {Slice} from \"./replace\"\nimport {Mark} from \"./mark\"\n\n// ParseOptions:: interface\n// These are the options recognized by the\n// [`parse`](#model.DOMParser.parse) and\n// [`parseSlice`](#model.DOMParser.parseSlice) methods.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   By default, whitespace is collapsed as per HTML's rules. Pass\n//   `true` to preserve whitespace, but normalize newlines to\n//   spaces, and `\"full\"` to preserve whitespace entirely.\n//\n//   findPositions:: ?[{node: dom.Node, offset: number}]\n//   When given, the parser will, beside parsing the content,\n//   record the document positions of the given DOM positions. It\n//   will do so by writing to the objects, adding a `pos` property\n//   that holds the document position. DOM positions that are not\n//   in the parsed content will not be written to.\n//\n//   from:: ?number\n//   The child node index to start parsing from.\n//\n//   to:: ?number\n//   The child node index to stop parsing at.\n//\n//   topNode:: ?Node\n//   By default, the content is parsed into the schema's default\n//   [top node type](#model.Schema.topNodeType). You can pass this\n//   option to use the type and attributes from a different node\n//   as the top container.\n//\n//   topMatch:: ?ContentMatch\n//   Provide the starting content match that content parsed into the\n//   top node is matched against.\n//\n//   context:: ?ResolvedPos\n//   A set of additional nodes to count as\n//   [context](#model.ParseRule.context) when parsing, above the\n//   given [top node](#model.ParseOptions.topNode).\n\n// ParseRule:: interface\n// A value that describes how to parse a given DOM node or inline\n// style as a ProseMirror node or mark.\n//\n//   tag:: ?string\n//   A CSS selector describing the kind of DOM elements to match. A\n//   single rule should have _either_ a `tag` or a `style` property.\n//\n//   namespace:: ?string\n//   The namespace to match. This should be used with `tag`.\n//   Nodes are only matched when the namespace matches or this property\n//   is null.\n//\n//   style:: ?string\n//   A CSS property name to match. When given, this rule matches\n//   inline styles that list that property. May also have the form\n//   `\"property=value\"`, in which case the rule only matches if the\n//   property's value exactly matches the given value. (For more\n//   complicated filters, use [`getAttrs`](#model.ParseRule.getAttrs)\n//   and return false to indicate that the match failed.) Rules\n//   matching styles may only produce [marks](#model.ParseRule.mark),\n//   not nodes.\n//\n//   priority:: ?number\n//   Can be used to change the order in which the parse rules in a\n//   schema are tried. Those with higher priority come first. Rules\n//   without a priority are counted as having priority 50. This\n//   property is only meaningful in a schema—when directly\n//   constructing a parser, the order of the rule array is used.\n//\n//   consuming:: ?boolean\n//   By default, when a rule matches an element or style, no further\n//   rules get a chance to match it. By setting this to `false`, you\n//   indicate that even when this rule matches, other rules that come\n//   after it should also run.\n//\n//   context:: ?string\n//   When given, restricts this rule to only match when the current\n//   context—the parent nodes into which the content is being\n//   parsed—matches this expression. Should contain one or more node\n//   names or node group names followed by single or double slashes.\n//   For example `\"paragraph/\"` means the rule only matches when the\n//   parent node is a paragraph, `\"blockquote/paragraph/\"` restricts\n//   it to be in a paragraph that is inside a blockquote, and\n//   `\"section//\"` matches any position inside a section—a double\n//   slash matches any sequence of ancestor nodes. To allow multiple\n//   different contexts, they can be separated by a pipe (`|`)\n//   character, as in `\"blockquote/|list_item/\"`.\n//\n//   node:: ?string\n//   The name of the node type to create when this rule matches. Only\n//   valid for rules with a `tag` property, not for style rules. Each\n//   rule should have one of a `node`, `mark`, or `ignore` property\n//   (except when it appears in a [node](#model.NodeSpec.parseDOM) or\n//   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`\n//   or `mark` property will be derived from its position).\n//\n//   mark:: ?string\n//   The name of the mark type to wrap the matched content in.\n//\n//   ignore:: ?bool\n//   When true, ignore content that matches this rule.\n//\n//   closeParent:: ?bool\n//   When true, finding an element that matches this rule will close\n//   the current node.\n//\n//   skip:: ?bool\n//   When true, ignore the node that matches this rule, but do parse\n//   its content.\n//\n//   attrs:: ?Object\n//   Attributes for the node or mark created by this rule. When\n//   `getAttrs` is provided, it takes precedence.\n//\n//   getAttrs:: ?(union<dom.Node, string>) → ?union<Object, false>\n//   A function used to compute the attributes for the node or mark\n//   created by this rule. Can also be used to describe further\n//   conditions the DOM element or style must match. When it returns\n//   `false`, the rule won't match. When it returns null or undefined,\n//   that is interpreted as an empty/default set of attributes.\n//\n//   Called with a DOM Element for `tag` rules, and with a string (the\n//   style's value) for `style` rules.\n//\n//   contentElement:: ?union<string, (dom.Node) → dom.Node>\n//   For `tag` rules that produce non-leaf nodes or marks, by default\n//   the content of the DOM element is parsed as content of the mark\n//   or node. If the child nodes are in a descendent node, this may be\n//   a CSS selector string that the parser must use to find the actual\n//   content element, or a function that returns the actual content\n//   element to the parser.\n//\n//   getContent:: ?(dom.Node, schema: Schema) → Fragment\n//   Can be used to override the content of a matched node. When\n//   present, instead of parsing the node's child nodes, the result of\n//   this function is used.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   Controls whether whitespace should be preserved when parsing the\n//   content inside the matched element. `false` means whitespace may\n//   be collapsed, `true` means that whitespace should be preserved\n//   but newlines normalized to spaces, and `\"full\"` means that\n//   newlines should also be preserved.\n\n// ::- A DOM parser represents a strategy for parsing DOM content into\n// a ProseMirror document conforming to a given schema. Its behavior\n// is defined by an array of [rules](#model.ParseRule).\nexport class DOMParser {\n  // :: (Schema, [ParseRule])\n  // Create a parser that targets the given schema, using the given\n  // parsing rules.\n  constructor(schema, rules) {\n    // :: Schema\n    // The schema into which the parser parses.\n    this.schema = schema\n    // :: [ParseRule]\n    // The set of [parse rules](#model.ParseRule) that the parser\n    // uses, in order of precedence.\n    this.rules = rules\n    this.tags = []\n    this.styles = []\n\n    rules.forEach(rule => {\n      if (rule.tag) this.tags.push(rule)\n      else if (rule.style) this.styles.push(rule)\n    })\n\n    // Only normalize list elements when lists in the schema can't directly contain themselves\n    this.normalizeLists = !this.tags.some(r => {\n      if (!/^(ul|ol)\\b/.test(r.tag) || !r.node) return false\n      let node = schema.nodes[r.node]\n      return node.contentMatch.matchType(node)\n    })\n  }\n\n  // :: (dom.Node, ?ParseOptions) → Node\n  // Parse a document from the content of a DOM node.\n  parse(dom, options = {}) {\n    let context = new ParseContext(this, options, false)\n    context.addAll(dom, null, options.from, options.to)\n    return context.finish()\n  }\n\n  // :: (dom.Node, ?ParseOptions) → Slice\n  // Parses the content of the given DOM node, like\n  // [`parse`](#model.DOMParser.parse), and takes the same set of\n  // options. But unlike that method, which produces a whole node,\n  // this one returns a slice that is open at the sides, meaning that\n  // the schema constraints aren't applied to the start of nodes to\n  // the left of the input and the end of nodes at the end.\n  parseSlice(dom, options = {}) {\n    let context = new ParseContext(this, options, true)\n    context.addAll(dom, null, options.from, options.to)\n    return Slice.maxOpen(context.finish())\n  }\n\n  matchTag(dom, context, after) {\n    for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {\n      let rule = this.tags[i]\n      if (matches(dom, rule.tag) &&\n          (rule.namespace === undefined || dom.namespaceURI == rule.namespace) &&\n          (!rule.context || context.matchesContext(rule.context))) {\n        if (rule.getAttrs) {\n          let result = rule.getAttrs(dom)\n          if (result === false) continue\n          rule.attrs = result\n        }\n        return rule\n      }\n    }\n  }\n\n  matchStyle(prop, value, context, after) {\n    for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {\n      let rule = this.styles[i]\n      if (rule.style.indexOf(prop) != 0 ||\n          rule.context && !context.matchesContext(rule.context) ||\n          // Test that the style string either precisely matches the prop,\n          // or has an '=' sign after the prop, followed by the given\n          // value.\n          rule.style.length > prop.length &&\n          (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value))\n        continue\n      if (rule.getAttrs) {\n        let result = rule.getAttrs(value)\n        if (result === false) continue\n        rule.attrs = result\n      }\n      return rule\n    }\n  }\n\n  // : (Schema) → [ParseRule]\n  static schemaRules(schema) {\n    let result = []\n    function insert(rule) {\n      let priority = rule.priority == null ? 50 : rule.priority, i = 0\n      for (; i < result.length; i++) {\n        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority\n        if (nextPriority < priority) break\n      }\n      result.splice(i, 0, rule)\n    }\n\n    for (let name in schema.marks) {\n      let rules = schema.marks[name].spec.parseDOM\n      if (rules) rules.forEach(rule => {\n        insert(rule = copy(rule))\n        rule.mark = name\n      })\n    }\n    for (let name in schema.nodes) {\n      let rules = schema.nodes[name].spec.parseDOM\n      if (rules) rules.forEach(rule => {\n        insert(rule = copy(rule))\n        rule.node = name\n      })\n    }\n    return result\n  }\n\n  // :: (Schema) → DOMParser\n  // Construct a DOM parser using the parsing rules listed in a\n  // schema's [node specs](#model.NodeSpec.parseDOM), reordered by\n  // [priority](#model.ParseRule.priority).\n  static fromSchema(schema) {\n    return schema.cached.domParser ||\n      (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)))\n  }\n}\n\n// : Object<bool> The block-level tags in HTML5\nconst blockTags = {\n  address: true, article: true, aside: true, blockquote: true, canvas: true,\n  dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,\n  footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,\n  h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,\n  output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true\n}\n\n// : Object<bool> The tags that we normally ignore.\nconst ignoreTags = {\n  head: true, noscript: true, object: true, script: true, style: true, title: true\n}\n\n// : Object<bool> List tags.\nconst listTags = {ol: true, ul: true}\n\n// Using a bitfield for node context options\nconst OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4\n\nfunction wsOptionsFor(type, preserveWhitespace, base) {\n  if (preserveWhitespace != null) return (preserveWhitespace ? OPT_PRESERVE_WS : 0) |\n    (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0)\n  return type && type.whitespace == \"pre\" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT\n}\n\nclass NodeContext {\n  constructor(type, attrs, marks, pendingMarks, solid, match, options) {\n    this.type = type\n    this.attrs = attrs\n    this.solid = solid\n    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch)\n    this.options = options\n    this.content = []\n    // Marks applied to this node itself\n    this.marks = marks\n    // Marks applied to its children\n    this.activeMarks = Mark.none\n    // Marks that can't apply here, but will be used in children if possible\n    this.pendingMarks = pendingMarks\n    // Nested Marks with same type\n    this.stashMarks = []\n  }\n\n  findWrapping(node) {\n    if (!this.match) {\n      if (!this.type) return []\n      let fill = this.type.contentMatch.fillBefore(Fragment.from(node))\n      if (fill) {\n        this.match = this.type.contentMatch.matchFragment(fill)\n      } else {\n        let start = this.type.contentMatch, wrap\n        if (wrap = start.findWrapping(node.type)) {\n          this.match = start\n          return wrap\n        } else {\n          return null\n        }\n      }\n    }\n    return this.match.findWrapping(node.type)\n  }\n\n  finish(openEnd) {\n    if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace\n      let last = this.content[this.content.length - 1], m\n      if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n        if (last.text.length == m[0].length) this.content.pop()\n        else this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length))\n      }\n    }\n    let content = Fragment.from(this.content)\n    if (!openEnd && this.match)\n      content = content.append(this.match.fillBefore(Fragment.empty, true))\n    return this.type ? this.type.create(this.attrs, content, this.marks) : content\n  }\n\n  popFromStashMark(mark) {\n    for (let i = this.stashMarks.length - 1; i >= 0; i--)\n      if (mark.eq(this.stashMarks[i])) return this.stashMarks.splice(i, 1)[0]\n  }\n\n  applyPending(nextType) {\n    for (let i = 0, pending = this.pendingMarks; i < pending.length; i++) {\n      let mark = pending[i]\n      if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) &&\n          !mark.isInSet(this.activeMarks)) {\n        this.activeMarks = mark.addToSet(this.activeMarks)\n        this.pendingMarks = mark.removeFromSet(this.pendingMarks)\n      }\n    }\n  }\n\n  inlineContext(node) {\n    if (this.type) return this.type.inlineContent\n    if (this.content.length) return this.content[0].isInline\n    return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase())\n  }\n}\n\nclass ParseContext {\n  // : (DOMParser, Object)\n  constructor(parser, options, open) {\n    // : DOMParser The parser we are using.\n    this.parser = parser\n    // : Object The options passed to this parse.\n    this.options = options\n    this.isOpen = open\n    let topNode = options.topNode, topContext\n    let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (open ? OPT_OPEN_LEFT : 0)\n    if (topNode)\n      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true,\n                                   options.topMatch || topNode.type.contentMatch, topOptions)\n    else if (open)\n      topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions)\n    else\n      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions)\n    this.nodes = [topContext]\n    // : [Mark] The current set of marks\n    this.open = 0\n    this.find = options.findPositions\n    this.needsBlock = false\n  }\n\n  get top() {\n    return this.nodes[this.open]\n  }\n\n  // : (dom.Node)\n  // Add a DOM node to the content. Text is inserted as text node,\n  // otherwise, the node is passed to `addElement` or, if it has a\n  // `style` attribute, `addElementWithStyles`.\n  addDOM(dom) {\n    if (dom.nodeType == 3) {\n      this.addTextNode(dom)\n    } else if (dom.nodeType == 1) {\n      let style = dom.getAttribute(\"style\")\n      let marks = style ? this.readStyles(parseStyles(style)) : null, top = this.top\n      if (marks != null) for (let i = 0; i < marks.length; i++) this.addPendingMark(marks[i])\n      this.addElement(dom)\n      if (marks != null) for (let i = 0; i < marks.length; i++) this.removePendingMark(marks[i], top)\n    }\n  }\n\n  addTextNode(dom) {\n    let value = dom.nodeValue\n    let top = this.top\n    if (top.options & OPT_PRESERVE_WS_FULL ||\n        top.inlineContext(dom) ||\n        /[^ \\t\\r\\n\\u000c]/.test(value)) {\n      if (!(top.options & OPT_PRESERVE_WS)) {\n        value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \")\n        // If this starts with whitespace, and there is no node before it, or\n        // a hard break, or a text node that ends with whitespace, strip the\n        // leading space.\n        if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n          let nodeBefore = top.content[top.content.length - 1]\n          let domNodeBefore = dom.previousSibling\n          if (!nodeBefore ||\n              (domNodeBefore && domNodeBefore.nodeName == 'BR') ||\n              (nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)))\n            value = value.slice(1)\n        }\n      } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {\n        value = value.replace(/\\r?\\n|\\r/g, \" \")\n      } else {\n        value = value.replace(/\\r\\n?/g, \"\\n\")\n      }\n      if (value) this.insertNode(this.parser.schema.text(value))\n      this.findInText(dom)\n    } else {\n      this.findInside(dom)\n    }\n  }\n\n  // : (dom.Element, ?ParseRule)\n  // Try to find a handler for the given tag and use that to parse. If\n  // none is found, the element's content nodes are added directly.\n  addElement(dom, matchAfter) {\n    let name = dom.nodeName.toLowerCase(), ruleID\n    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) normalizeList(dom)\n    let rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) ||\n        (ruleID = this.parser.matchTag(dom, this, matchAfter))\n    if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n      this.findInside(dom)\n      this.ignoreFallback(dom)\n    } else if (!rule || rule.skip || rule.closeParent) {\n      if (rule && rule.closeParent) this.open = Math.max(0, this.open - 1)\n      else if (rule && rule.skip.nodeType) dom = rule.skip\n      let sync, top = this.top, oldNeedsBlock = this.needsBlock\n      if (blockTags.hasOwnProperty(name)) {\n        sync = true\n        if (!top.type) this.needsBlock = true\n      } else if (!dom.firstChild) {\n        this.leafFallback(dom)\n        return\n      }\n      this.addAll(dom)\n      if (sync) this.sync(top)\n      this.needsBlock = oldNeedsBlock\n    } else {\n      this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null)\n    }\n  }\n\n  // Called for leaf DOM nodes that would otherwise be ignored\n  leafFallback(dom) {\n    if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent)\n      this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\"))\n  }\n\n  // Called for ignored nodes\n  ignoreFallback(dom) {\n    // Ignored BR nodes should at least create an inline context\n    if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent))\n      this.findPlace(this.parser.schema.text(\"-\"))\n  }\n\n  // Run any style parser associated with the node's styles. Either\n  // return an array of marks, or null to indicate some of the styles\n  // had a rule with `ignore` set.\n  readStyles(styles) {\n    let marks = Mark.none\n    style: for (let i = 0; i < styles.length; i += 2) {\n      for (let after = null;;) {\n        let rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after)\n        if (!rule) continue style\n        if (rule.ignore) return null\n        marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks)\n        if (rule.consuming === false) after = rule\n        else break\n      }\n    }\n    return marks\n  }\n\n  // : (dom.Element, ParseRule) → bool\n  // Look up a handler for the given node. If none are found, return\n  // false. Otherwise, apply it, use its return value to drive the way\n  // the node's content is wrapped, and return true.\n  addElementByRule(dom, rule, continueAfter) {\n    let sync, nodeType, markType, mark\n    if (rule.node) {\n      nodeType = this.parser.schema.nodes[rule.node]\n      if (!nodeType.isLeaf) {\n        sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace)\n      } else if (!this.insertNode(nodeType.create(rule.attrs))) {\n        this.leafFallback(dom)\n      }\n    } else {\n      markType = this.parser.schema.marks[rule.mark]\n      mark = markType.create(rule.attrs)\n      this.addPendingMark(mark)\n    }\n    let startIn = this.top\n\n    if (nodeType && nodeType.isLeaf) {\n      this.findInside(dom)\n    } else if (continueAfter) {\n      this.addElement(dom, continueAfter)\n    } else if (rule.getContent) {\n      this.findInside(dom)\n      rule.getContent(dom, this.parser.schema).forEach(node => this.insertNode(node))\n    } else {\n      let contentDOM = rule.contentElement\n      if (typeof contentDOM == \"string\") contentDOM = dom.querySelector(contentDOM)\n      else if (typeof contentDOM == \"function\") contentDOM = contentDOM(dom)\n      if (!contentDOM) contentDOM = dom\n      this.findAround(dom, contentDOM, true)\n      this.addAll(contentDOM, sync)\n    }\n    if (sync) { this.sync(startIn); this.open-- }\n    if (mark) this.removePendingMark(mark, startIn)\n  }\n\n  // : (dom.Node, ?NodeBuilder, ?number, ?number)\n  // Add all child nodes between `startIndex` and `endIndex` (or the\n  // whole node, if not given). If `sync` is passed, use it to\n  // synchronize after every block element.\n  addAll(parent, sync, startIndex, endIndex) {\n    let index = startIndex || 0\n    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild,\n             end = endIndex == null ? null : parent.childNodes[endIndex];\n         dom != end; dom = dom.nextSibling, ++index) {\n      this.findAtPoint(parent, index)\n      this.addDOM(dom)\n      if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase()))\n        this.sync(sync)\n    }\n    this.findAtPoint(parent, index)\n  }\n\n  // Try to find a way to fit the given node type into the current\n  // context. May add intermediate wrappers and/or leave non-solid\n  // nodes that we're in.\n  findPlace(node) {\n    let route, sync\n    for (let depth = this.open; depth >= 0; depth--) {\n      let cx = this.nodes[depth]\n      let found = cx.findWrapping(node)\n      if (found && (!route || route.length > found.length)) {\n        route = found\n        sync = cx\n        if (!found.length) break\n      }\n      if (cx.solid) break\n    }\n    if (!route) return false\n    this.sync(sync)\n    for (let i = 0; i < route.length; i++)\n      this.enterInner(route[i], null, false)\n    return true\n  }\n\n  // : (Node) → ?Node\n  // Try to insert the given node, adjusting the context when needed.\n  insertNode(node) {\n    if (node.isInline && this.needsBlock && !this.top.type) {\n      let block = this.textblockFromContext()\n      if (block) this.enterInner(block)\n    }\n    if (this.findPlace(node)) {\n      this.closeExtra()\n      let top = this.top\n      top.applyPending(node.type)\n      if (top.match) top.match = top.match.matchType(node.type)\n      let marks = top.activeMarks\n      for (let i = 0; i < node.marks.length; i++)\n        if (!top.type || top.type.allowsMarkType(node.marks[i].type))\n          marks = node.marks[i].addToSet(marks)\n      top.content.push(node.mark(marks))\n      return true\n    }\n    return false\n  }\n\n  // : (NodeType, ?Object) → bool\n  // Try to start a node of the given type, adjusting the context when\n  // necessary.\n  enter(type, attrs, preserveWS) {\n    let ok = this.findPlace(type.create(attrs))\n    if (ok) this.enterInner(type, attrs, true, preserveWS)\n    return ok\n  }\n\n  // Open a node of the given type\n  enterInner(type, attrs, solid, preserveWS) {\n    this.closeExtra()\n    let top = this.top\n    top.applyPending(type)\n    top.match = top.match && top.match.matchType(type, attrs)\n    let options = wsOptionsFor(type, preserveWS, top.options)\n    if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0) options |= OPT_OPEN_LEFT\n    this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options))\n    this.open++\n  }\n\n  // Make sure all nodes above this.open are finished and added to\n  // their parents\n  closeExtra(openEnd) {\n    let i = this.nodes.length - 1\n    if (i > this.open) {\n      for (; i > this.open; i--) this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd))\n      this.nodes.length = this.open + 1\n    }\n  }\n\n  finish() {\n    this.open = 0\n    this.closeExtra(this.isOpen)\n    return this.nodes[0].finish(this.isOpen || this.options.topOpen)\n  }\n\n  sync(to) {\n    for (let i = this.open; i >= 0; i--) if (this.nodes[i] == to) {\n      this.open = i\n      return\n    }\n  }\n\n  get currentPos() {\n    this.closeExtra()\n    let pos = 0\n    for (let i = this.open; i >= 0; i--) {\n      let content = this.nodes[i].content\n      for (let j = content.length - 1; j >= 0; j--)\n        pos += content[j].nodeSize\n      if (i) pos++\n    }\n    return pos\n  }\n\n  findAtPoint(parent, offset) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].node == parent && this.find[i].offset == offset)\n        this.find[i].pos = this.currentPos\n    }\n  }\n\n  findInside(parent) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))\n        this.find[i].pos = this.currentPos\n    }\n  }\n\n  findAround(parent, content, before) {\n    if (parent != content && this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n        let pos = content.compareDocumentPosition(this.find[i].node)\n        if (pos & (before ? 2 : 4))\n          this.find[i].pos = this.currentPos\n      }\n    }\n  }\n\n  findInText(textNode) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].node == textNode)\n        this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset)\n    }\n  }\n\n  // : (string) → bool\n  // Determines whether the given [context\n  // string](#ParseRule.context) matches this context.\n  matchesContext(context) {\n    if (context.indexOf(\"|\") > -1)\n      return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this)\n\n    let parts = context.split(\"/\")\n    let option = this.options.context\n    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type)\n    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1)\n    let match = (i, depth) => {\n      for (; i >= 0; i--) {\n        let part = parts[i]\n        if (part == \"\") {\n          if (i == parts.length - 1 || i == 0) continue\n          for (; depth >= minDepth; depth--)\n            if (match(i - 1, depth)) return true\n          return false\n        } else {\n          let next = depth > 0 || (depth == 0 && useRoot) ? this.nodes[depth].type\n              : option && depth >= minDepth ? option.node(depth - minDepth).type\n              : null\n          if (!next || (next.name != part && next.groups.indexOf(part) == -1))\n            return false\n          depth--\n        }\n      }\n      return true\n    }\n    return match(parts.length - 1, this.open)\n  }\n\n  textblockFromContext() {\n    let $context = this.options.context\n    if ($context) for (let d = $context.depth; d >= 0; d--) {\n      let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType\n      if (deflt && deflt.isTextblock && deflt.defaultAttrs) return deflt\n    }\n    for (let name in this.parser.schema.nodes) {\n      let type = this.parser.schema.nodes[name]\n      if (type.isTextblock && type.defaultAttrs) return type\n    }\n  }\n\n  addPendingMark(mark) {\n    let found = findSameMarkInSet(mark, this.top.pendingMarks)\n    if (found) this.top.stashMarks.push(found)\n    this.top.pendingMarks = mark.addToSet(this.top.pendingMarks)\n  }\n\n  removePendingMark(mark, upto) {\n    for (let depth = this.open; depth >= 0; depth--) {\n      let level = this.nodes[depth]\n      let found = level.pendingMarks.lastIndexOf(mark)\n      if (found > -1) {\n        level.pendingMarks = mark.removeFromSet(level.pendingMarks)\n      } else {\n        level.activeMarks = mark.removeFromSet(level.activeMarks)\n        let stashMark = level.popFromStashMark(mark)\n        if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))\n          level.activeMarks = stashMark.addToSet(level.activeMarks)\n      }\n      if (level == upto) break\n    }\n  }\n}\n\n// Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\nfunction normalizeList(dom) {\n  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child)\n      child = prevItem\n    } else if (name == \"li\") {\n      prevItem = child\n    } else if (name) {\n      prevItem = null\n    }\n  }\n}\n\n// Apply a CSS selector.\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector)\n}\n\n// : (string) → [string]\n// Tokenize a style attribute into property/value pairs.\nfunction parseStyles(style) {\n  let re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g, m, result = []\n  while (m = re.exec(style)) result.push(m[1], m[2].trim())\n  return result\n}\n\nfunction copy(obj) {\n  let copy = {}\n  for (let prop in obj) copy[prop] = obj[prop]\n  return copy\n}\n\n// Used when finding a mark at the top level of a fragment parse.\n// Checks whether it would be reasonable to apply a given mark type to\n// a given node, by looking at the way the mark occurs in the schema.\nfunction markMayApply(markType, nodeType) {\n  let nodes = nodeType.schema.nodes\n  for (let name in nodes) {\n    let parent = nodes[name]\n    if (!parent.allowsMarkType(markType)) continue\n    let seen = [], scan = match => {\n      seen.push(match)\n      for (let i = 0; i < match.edgeCount; i++) {\n        let {type, next} = match.edge(i)\n        if (type == nodeType) return true\n        if (seen.indexOf(next) < 0 && scan(next)) return true\n      }\n    }\n    if (scan(parent.contentMatch)) return true\n  }\n}\n\nfunction findSameMarkInSet(mark, set) {\n  for (let i = 0; i < set.length; i++) {\n    if (mark.eq(set[i])) return set[i]\n  }\n}\n","// DOMOutputSpec:: interface\n// A description of a DOM structure. Can be either a string, which is\n// interpreted as a text node, a DOM node, which is interpreted as\n// itself, a `{dom: Node, contentDOM: ?Node}` object, or an array.\n//\n// An array describes a DOM element. The first value in the array\n// should be a string—the name of the DOM element, optionally prefixed\n// by a namespace URL and a space. If the second element is plain\n// object, it is interpreted as a set of attributes for the element.\n// Any elements after that (including the 2nd if it's not an attribute\n// object) are interpreted as children of the DOM elements, and must\n// either be valid `DOMOutputSpec` values, or the number zero.\n//\n// The number zero (pronounced “hole”) is used to indicate the place\n// where a node's child nodes should be inserted. If it occurs in an\n// output spec, it should be the only child element in its parent\n// node.\n\n// ::- A DOM serializer knows how to convert ProseMirror nodes and\n// marks of various types to DOM nodes.\nexport class DOMSerializer {\n  // :: (Object<(node: Node) → DOMOutputSpec>, Object<?(mark: Mark, inline: bool) → DOMOutputSpec>)\n  // Create a serializer. `nodes` should map node names to functions\n  // that take a node and return a description of the corresponding\n  // DOM. `marks` does the same for mark names, but also gets an\n  // argument that tells it whether the mark's content is block or\n  // inline content (for typical use, it'll always be inline). A mark\n  // serializer may be `null` to indicate that marks of that type\n  // should not be serialized.\n  constructor(nodes, marks) {\n    // :: Object<(node: Node) → DOMOutputSpec>\n    // The node serialization functions.\n    this.nodes = nodes || {}\n    // :: Object<?(mark: Mark, inline: bool) → DOMOutputSpec>\n    // The mark serialization functions.\n    this.marks = marks || {}\n  }\n\n  // :: (Fragment, ?Object) → dom.DocumentFragment\n  // Serialize the content of this fragment to a DOM fragment. When\n  // not in the browser, the `document` option, containing a DOM\n  // document, should be passed so that the serializer can create\n  // nodes.\n  serializeFragment(fragment, options = {}, target) {\n    if (!target) target = doc(options).createDocumentFragment()\n\n    let top = target, active = null\n    fragment.forEach(node => {\n      if (active || node.marks.length) {\n        if (!active) active = []\n        let keep = 0, rendered = 0\n        while (keep < active.length && rendered < node.marks.length) {\n          let next = node.marks[rendered]\n          if (!this.marks[next.type.name]) { rendered++; continue }\n          if (!next.eq(active[keep]) || next.type.spec.spanning === false) break\n          keep += 2; rendered++\n        }\n        while (keep < active.length) {\n          top = active.pop()\n          active.pop()\n        }\n        while (rendered < node.marks.length) {\n          let add = node.marks[rendered++]\n          let markDOM = this.serializeMark(add, node.isInline, options)\n          if (markDOM) {\n            active.push(add, top)\n            top.appendChild(markDOM.dom)\n            top = markDOM.contentDOM || markDOM.dom\n          }\n        }\n      }\n      top.appendChild(this.serializeNodeInner(node, options))\n    })\n\n    return target\n  }\n\n  serializeNodeInner(node, options = {}) {\n    let {dom, contentDOM} =\n        DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node))\n    if (contentDOM) {\n      if (node.isLeaf)\n        throw new RangeError(\"Content hole not allowed in a leaf node spec\")\n      if (options.onContent)\n        options.onContent(node, contentDOM, options)\n      else\n        this.serializeFragment(node.content, options, contentDOM)\n    }\n    return dom\n  }\n\n  // :: (Node, ?Object) → dom.Node\n  // Serialize this node to a DOM node. This can be useful when you\n  // need to serialize a part of a document, as opposed to the whole\n  // document. To serialize a whole document, use\n  // [`serializeFragment`](#model.DOMSerializer.serializeFragment) on\n  // its [content](#model.Node.content).\n  serializeNode(node, options = {}) {\n    let dom = this.serializeNodeInner(node, options)\n    for (let i = node.marks.length - 1; i >= 0; i--) {\n      let wrap = this.serializeMark(node.marks[i], node.isInline, options)\n      if (wrap) {\n        ;(wrap.contentDOM || wrap.dom).appendChild(dom)\n        dom = wrap.dom\n      }\n    }\n    return dom\n  }\n\n  serializeMark(mark, inline, options = {}) {\n    let toDOM = this.marks[mark.type.name]\n    return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline))\n  }\n\n  // :: (dom.Document, DOMOutputSpec) → {dom: dom.Node, contentDOM: ?dom.Node}\n  // Render an [output spec](#model.DOMOutputSpec) to a DOM node. If\n  // the spec has a hole (zero) in it, `contentDOM` will point at the\n  // node with the hole.\n  static renderSpec(doc, structure, xmlNS = null) {\n    if (typeof structure == \"string\")\n      return {dom: doc.createTextNode(structure)}\n    if (structure.nodeType != null)\n      return {dom: structure}\n    if (structure.dom && structure.dom.nodeType != null)\n      return structure\n    let tagName = structure[0], space = tagName.indexOf(\" \")\n    if (space > 0) {\n      xmlNS = tagName.slice(0, space)\n      tagName = tagName.slice(space + 1)\n    }\n    let contentDOM = null, dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName)\n    let attrs = structure[1], start = 1\n    if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n      start = 2\n      for (let name in attrs) if (attrs[name] != null) {\n        let space = name.indexOf(\" \")\n        if (space > 0) dom.setAttributeNS(name.slice(0, space), name.slice(space + 1), attrs[name])\n        else dom.setAttribute(name, attrs[name])\n      }\n    }\n    for (let i = start; i < structure.length; i++) {\n      let child = structure[i]\n      if (child === 0) {\n        if (i < structure.length - 1 || i > start)\n          throw new RangeError(\"Content hole must be the only child of its parent node\")\n        return {dom, contentDOM: dom}\n      } else {\n        let {dom: inner, contentDOM: innerContent} = DOMSerializer.renderSpec(doc, child, xmlNS)\n        dom.appendChild(inner)\n        if (innerContent) {\n          if (contentDOM) throw new RangeError(\"Multiple content holes\")\n          contentDOM = innerContent\n        }\n      }\n    }\n    return {dom, contentDOM}\n  }\n\n  // :: (Schema) → DOMSerializer\n  // Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)\n  // properties in a schema's node and mark specs.\n  static fromSchema(schema) {\n    return schema.cached.domSerializer ||\n      (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)))\n  }\n\n  // : (Schema) → Object<(node: Node) → DOMOutputSpec>\n  // Gather the serializers in a schema's node specs into an object.\n  // This can be useful as a base to build a custom serializer from.\n  static nodesFromSchema(schema) {\n    let result = gatherToDOM(schema.nodes)\n    if (!result.text) result.text = node => node.text\n    return result\n  }\n\n  // : (Schema) → Object<(mark: Mark) → DOMOutputSpec>\n  // Gather the serializers in a schema's mark specs into an object.\n  static marksFromSchema(schema) {\n    return gatherToDOM(schema.marks)\n  }\n}\n\nfunction gatherToDOM(obj) {\n  let result = {}\n  for (let name in obj) {\n    let toDOM = obj[name].spec.toDOM\n    if (toDOM) result[name] = toDOM\n  }\n  return result\n}\n\nfunction doc(options) {\n  // declare global: window\n  return options.document || window.document\n}\n","// Mappable:: interface\n// There are several things that positions can be mapped through.\n// Such objects conform to this interface.\n//\n//   map:: (pos: number, assoc: ?number) → number\n//   Map a position through this object. When given, `assoc` (should\n//   be -1 or 1, defaults to 1) determines with which side the\n//   position is associated, which determines in which direction to\n//   move when a chunk of content is inserted at the mapped position.\n//\n//   mapResult:: (pos: number, assoc: ?number) → MapResult\n//   Map a position, and return an object containing additional\n//   information about the mapping. The result's `deleted` field tells\n//   you whether the position was deleted (completely enclosed in a\n//   replaced range) during the mapping. When content on only one side\n//   is deleted, the position itself is only considered deleted when\n//   `assoc` points in the direction of the deleted content.\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\n\nconst lower16 = 0xffff\nconst factor16 = Math.pow(2, 16)\n\nfunction makeRecover(index, offset) { return index + offset * factor16 }\nfunction recoverIndex(value) { return value & lower16 }\nfunction recoverOffset(value) { return (value - (value & lower16)) / factor16 }\n\n// ::- An object representing a mapped position with extra\n// information.\nexport class MapResult {\n  constructor(pos, deleted = false, recover = null) {\n    // :: number The mapped version of the position.\n    this.pos = pos\n    // :: bool Tells you whether the position was deleted, that is,\n    // whether the step removed its surroundings from the document.\n    this.deleted = deleted\n    this.recover = recover\n  }\n}\n\n// :: class extends Mappable\n// A map describing the deletions and insertions made by a step, which\n// can be used to find the correspondence between positions in the\n// pre-step version of a document and the same position in the\n// post-step version.\nexport class StepMap {\n  // :: ([number])\n  // Create a position map. The modifications to the document are\n  // represented as an array of numbers, in which each group of three\n  // represents a modified chunk as `[start, oldSize, newSize]`.\n  constructor(ranges, inverted = false) {\n    if (!ranges.length && StepMap.empty) return StepMap.empty\n    this.ranges = ranges\n    this.inverted = inverted\n  }\n\n  recover(value) {\n    let diff = 0, index = recoverIndex(value)\n    if (!this.inverted) for (let i = 0; i < index; i++)\n      diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]\n    return this.ranges[index * 3] + diff + recoverOffset(value)\n  }\n\n  // : (number, ?number) → MapResult\n  mapResult(pos, assoc = 1) { return this._map(pos, assoc, false) }\n\n  // : (number, ?number) → number\n  map(pos, assoc = 1) { return this._map(pos, assoc, true) }\n\n  _map(pos, assoc, simple) {\n    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0)\n      if (start > pos) break\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize\n      if (pos <= end) {\n        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc\n        let result = start + diff + (side < 0 ? 0 : newSize)\n        if (simple) return result\n        let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start)\n        return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover)\n      }\n      diff += newSize - oldSize\n    }\n    return simple ? pos + diff : new MapResult(pos + diff)\n  }\n\n  touches(pos, recover) {\n    let diff = 0, index = recoverIndex(recover)\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0)\n      if (start > pos) break\n      let oldSize = this.ranges[i + oldIndex], end = start + oldSize\n      if (pos <= end && i == index * 3) return true\n      diff += this.ranges[i + newIndex] - oldSize\n    }\n    return false\n  }\n\n  // :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))\n  // Calls the given function on each of the changed ranges included in\n  // this map.\n  forEach(f) {\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff)\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex]\n      f(oldStart, oldStart + oldSize, newStart, newStart + newSize)\n      diff += newSize - oldSize\n    }\n  }\n\n  // :: () → StepMap\n  // Create an inverted version of this map. The result can be used to\n  // map positions in the post-step document to the pre-step document.\n  invert() {\n    return new StepMap(this.ranges, !this.inverted)\n  }\n\n  toString() {\n    return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges)\n  }\n\n  // :: (n: number) → StepMap\n  // Create a map that moves all positions by offset `n` (which may be\n  // negative). This can be useful when applying steps meant for a\n  // sub-document to a larger document, or vice-versa.\n  static offset(n) {\n    return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n])\n  }\n}\n\nStepMap.empty = new StepMap([])\n\n// :: class extends Mappable\n// A mapping represents a pipeline of zero or more [step\n// maps](#transform.StepMap). It has special provisions for losslessly\n// handling mapping positions through a series of steps in which some\n// steps are inverted versions of earlier steps. (This comes up when\n// ‘[rebasing](/docs/guide/#transform.rebasing)’ steps for\n// collaboration or history management.)\nexport class Mapping {\n  // :: (?[StepMap])\n  // Create a new mapping with the given position maps.\n  constructor(maps, mirror, from, to) {\n    // :: [StepMap]\n    // The step maps in this mapping.\n    this.maps = maps || []\n    // :: number\n    // The starting position in the `maps` array, used when `map` or\n    // `mapResult` is called.\n    this.from = from || 0\n    // :: number\n    // The end position in the `maps` array.\n    this.to = to == null ? this.maps.length : to\n    this.mirror = mirror\n  }\n\n  // :: (?number, ?number) → Mapping\n  // Create a mapping that maps only through a part of this one.\n  slice(from = 0, to = this.maps.length) {\n    return new Mapping(this.maps, this.mirror, from, to)\n  }\n\n  copy() {\n    return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)\n  }\n\n  // :: (StepMap, ?number)\n  // Add a step map to the end of this mapping. If `mirrors` is\n  // given, it should be the index of the step map that is the mirror\n  // image of this one.\n  appendMap(map, mirrors) {\n    this.to = this.maps.push(map)\n    if (mirrors != null) this.setMirror(this.maps.length - 1, mirrors)\n  }\n\n  // :: (Mapping)\n  // Add all the step maps in a given mapping to this one (preserving\n  // mirroring information).\n  appendMapping(mapping) {\n    for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n      let mirr = mapping.getMirror(i)\n      this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null)\n    }\n  }\n\n  // :: (number) → ?number\n  // Finds the offset of the step map that mirrors the map at the\n  // given offset, in this mapping (as per the second argument to\n  // `appendMap`).\n  getMirror(n) {\n    if (this.mirror) for (let i = 0; i < this.mirror.length; i++)\n      if (this.mirror[i] == n) return this.mirror[i + (i % 2 ? -1 : 1)]\n  }\n\n  setMirror(n, m) {\n    if (!this.mirror) this.mirror = []\n    this.mirror.push(n, m)\n  }\n\n  // :: (Mapping)\n  // Append the inverse of the given mapping to this one.\n  appendMappingInverted(mapping) {\n    for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n      let mirr = mapping.getMirror(i)\n      this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null)\n    }\n  }\n\n  // :: () → Mapping\n  // Create an inverted version of this mapping.\n  invert() {\n    let inverse = new Mapping\n    inverse.appendMappingInverted(this)\n    return inverse\n  }\n\n  // : (number, ?number) → number\n  // Map a position through this mapping.\n  map(pos, assoc = 1) {\n    if (this.mirror) return this._map(pos, assoc, true)\n    for (let i = this.from; i < this.to; i++)\n      pos = this.maps[i].map(pos, assoc)\n    return pos\n  }\n\n  // : (number, ?number) → MapResult\n  // Map a position through this mapping, returning a mapping\n  // result.\n  mapResult(pos, assoc = 1) { return this._map(pos, assoc, false) }\n\n  _map(pos, assoc, simple) {\n    let deleted = false\n\n    for (let i = this.from; i < this.to; i++) {\n      let map = this.maps[i], result = map.mapResult(pos, assoc)\n      if (result.recover != null) {\n        let corr = this.getMirror(i)\n        if (corr != null && corr > i && corr < this.to) {\n          i = corr\n          pos = this.maps[corr].recover(result.recover)\n          continue\n        }\n      }\n\n      if (result.deleted) deleted = true\n      pos = result.pos\n    }\n\n    return simple ? pos : new MapResult(pos, deleted)\n  }\n}\n","import {Mapping} from \"./map\"\n\nexport function TransformError(message) {\n  let err = Error.call(this, message)\n  err.__proto__ = TransformError.prototype\n  return err\n}\n\nTransformError.prototype = Object.create(Error.prototype)\nTransformError.prototype.constructor = TransformError\nTransformError.prototype.name = \"TransformError\"\n\n// ::- Abstraction to build up and track an array of\n// [steps](#transform.Step) representing a document transformation.\n//\n// Most transforming methods return the `Transform` object itself, so\n// that they can be chained.\nexport class Transform {\n  // :: (Node)\n  // Create a transform that starts with the given document.\n  constructor(doc) {\n    // :: Node\n    // The current document (the result of applying the steps in the\n    // transform).\n    this.doc = doc\n    // :: [Step]\n    // The steps in this transform.\n    this.steps = []\n    // :: [Node]\n    // The documents before each of the steps.\n    this.docs = []\n    // :: Mapping\n    // A mapping with the maps for each of the steps in this transform.\n    this.mapping = new Mapping\n  }\n\n  // :: Node The starting document.\n  get before() { return this.docs.length ? this.docs[0] : this.doc }\n\n  // :: (step: Step) → this\n  // Apply a new step in this transform, saving the result. Throws an\n  // error when the step fails.\n  step(object) {\n    let result = this.maybeStep(object)\n    if (result.failed) throw new TransformError(result.failed)\n    return this\n  }\n\n  // :: (Step) → StepResult\n  // Try to apply a step in this transformation, ignoring it if it\n  // fails. Returns the step result.\n  maybeStep(step) {\n    let result = step.apply(this.doc)\n    if (!result.failed) this.addStep(step, result.doc)\n    return result\n  }\n\n  // :: bool\n  // True when the document has been changed (when there are any\n  // steps).\n  get docChanged() {\n    return this.steps.length > 0\n  }\n\n  addStep(step, doc) {\n    this.docs.push(this.doc)\n    this.steps.push(step)\n    this.mapping.appendMap(step.getMap())\n    this.doc = doc\n  }\n}\n","import {ReplaceError} from \"prosemirror-model\"\n\nimport {StepMap} from \"./map\"\n\nfunction mustOverride() { throw new Error(\"Override me\") }\n\nconst stepsByID = Object.create(null)\n\n// ::- A step object represents an atomic change. It generally applies\n// only to the document it was created for, since the positions\n// stored in it will only make sense for that document.\n//\n// New steps are defined by creating classes that extend `Step`,\n// overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\n// methods, and registering your class with a unique\n// JSON-serialization identifier using\n// [`Step.jsonID`](#transform.Step^jsonID).\nexport class Step {\n  // :: (doc: Node) → StepResult\n  // Applies this step to the given document, returning a result\n  // object that either indicates failure, if the step can not be\n  // applied to this document, or indicates success by containing a\n  // transformed document.\n  apply(_doc) { return mustOverride() }\n\n  // :: () → StepMap\n  // Get the step map that represents the changes made by this step,\n  // and which can be used to transform between positions in the old\n  // and the new document.\n  getMap() { return StepMap.empty }\n\n  // :: (doc: Node) → Step\n  // Create an inverted version of this step. Needs the document as it\n  // was before the step as argument.\n  invert(_doc) { return mustOverride() }\n\n  // :: (mapping: Mappable) → ?Step\n  // Map this step through a mappable thing, returning either a\n  // version of that step with its positions adjusted, or `null` if\n  // the step was entirely deleted by the mapping.\n  map(_mapping) { return mustOverride() }\n\n  // :: (other: Step) → ?Step\n  // Try to merge this step with another one, to be applied directly\n  // after it. Returns the merged step when possible, null if the\n  // steps can't be merged.\n  merge(_other) { return null }\n\n  // :: () → Object\n  // Create a JSON-serializeable representation of this step. When\n  // defining this for a custom subclass, make sure the result object\n  // includes the step type's [JSON id](#transform.Step^jsonID) under\n  // the `stepType` property.\n  toJSON() { return mustOverride() }\n\n  // :: (Schema, Object) → Step\n  // Deserialize a step from its JSON representation. Will call\n  // through to the step class' own implementation of this method.\n  static fromJSON(schema, json) {\n    if (!json || !json.stepType) throw new RangeError(\"Invalid input for Step.fromJSON\")\n    let type = stepsByID[json.stepType]\n    if (!type) throw new RangeError(`No step type ${json.stepType} defined`)\n    return type.fromJSON(schema, json)\n  }\n\n  // :: (string, constructor<Step>)\n  // To be able to serialize steps to JSON, each step needs a string\n  // ID to attach to its JSON representation. Use this method to\n  // register an ID for your step classes. Try to pick something\n  // that's unlikely to clash with steps from other modules.\n  static jsonID(id, stepClass) {\n    if (id in stepsByID) throw new RangeError(\"Duplicate use of step JSON ID \" + id)\n    stepsByID[id] = stepClass\n    stepClass.prototype.jsonID = id\n    return stepClass\n  }\n}\n\n// ::- The result of [applying](#transform.Step.apply) a step. Contains either a\n// new document or a failure value.\nexport class StepResult {\n  // : (?Node, ?string)\n  constructor(doc, failed) {\n    // :: ?Node The transformed document.\n    this.doc = doc\n    // :: ?string Text providing information about a failed step.\n    this.failed = failed\n  }\n\n  // :: (Node) → StepResult\n  // Create a successful step result.\n  static ok(doc) { return new StepResult(doc, null) }\n\n  // :: (string) → StepResult\n  // Create a failed step result.\n  static fail(message) { return new StepResult(null, message) }\n\n  // :: (Node, number, number, Slice) → StepResult\n  // Call [`Node.replace`](#model.Node.replace) with the given\n  // arguments. Create a successful result if it succeeds, and a\n  // failed one if it throws a `ReplaceError`.\n  static fromReplace(doc, from, to, slice) {\n    try {\n      return StepResult.ok(doc.replace(from, to, slice))\n    } catch (e) {\n      if (e instanceof ReplaceError) return StepResult.fail(e.message)\n      throw e\n    }\n  }\n}\n","import {Slice} from \"prosemirror-model\"\n\nimport {Step, StepResult} from \"./step\"\nimport {StepMap} from \"./map\"\n\n// ::- Replace a part of the document with a slice of new content.\nexport class ReplaceStep extends Step {\n  // :: (number, number, Slice, ?bool)\n  // The given `slice` should fit the 'gap' between `from` and\n  // `to`—the depths must line up, and the surrounding nodes must be\n  // able to be joined with the open sides of the slice. When\n  // `structure` is true, the step will fail if the content between\n  // from and to is not just a sequence of closing and then opening\n  // tokens (this is to guard against rebased replace steps\n  // overwriting something they weren't supposed to).\n  constructor(from, to, slice, structure) {\n    super()\n    // :: number\n    // The start position of the replaced range.\n    this.from = from\n    // :: number\n    // The end position of the replaced range.\n    this.to = to\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice\n    this.structure = !!structure\n  }\n\n  apply(doc) {\n    if (this.structure && contentBetween(doc, this.from, this.to))\n      return StepResult.fail(\"Structure replace would overwrite content\")\n    return StepResult.fromReplace(doc, this.from, this.to, this.slice)\n  }\n\n  getMap() {\n    return new StepMap([this.from, this.to - this.from, this.slice.size])\n  }\n\n  invert(doc) {\n    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to))\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted) return null\n    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice)\n  }\n\n  merge(other) {\n    if (!(other instanceof ReplaceStep) || other.structure || this.structure) return null\n\n    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd)\n      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure)\n    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd)\n      return new ReplaceStep(other.from, this.to, slice, this.structure)\n    } else {\n      return null\n    }\n  }\n\n  toJSON() {\n    let json = {stepType: \"replace\", from: this.from, to: this.to}\n    if (this.slice.size) json.slice = this.slice.toJSON()\n    if (this.structure) json.structure = true\n    return json\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\")\n    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure)\n  }\n}\n\nStep.jsonID(\"replace\", ReplaceStep)\n\n// ::- Replace a part of the document with a slice of content, but\n// preserve a range of the replaced content by moving it into the\n// slice.\nexport class ReplaceAroundStep extends Step {\n  // :: (number, number, number, number, Slice, number, ?bool)\n  // Create a replace-around step with the given range and gap.\n  // `insert` should be the point in the slice into which the content\n  // of the gap should be moved. `structure` has the same meaning as\n  // it has in the [`ReplaceStep`](#transform.ReplaceStep) class.\n  constructor(from, to, gapFrom, gapTo, slice, insert, structure) {\n    super()\n    // :: number\n    // The start position of the replaced range.\n    this.from = from\n    // :: number\n    // The end position of the replaced range.\n    this.to = to\n    // :: number\n    // The start of preserved range.\n    this.gapFrom = gapFrom\n    // :: number\n    // The end of preserved range.\n    this.gapTo = gapTo\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice\n    // :: number\n    // The position in the slice where the preserved range should be\n    // inserted.\n    this.insert = insert\n    this.structure = !!structure\n  }\n\n  apply(doc) {\n    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||\n                           contentBetween(doc, this.gapTo, this.to)))\n      return StepResult.fail(\"Structure gap-replace would overwrite content\")\n\n    let gap = doc.slice(this.gapFrom, this.gapTo)\n    if (gap.openStart || gap.openEnd)\n      return StepResult.fail(\"Gap is not a flat range\")\n    let inserted = this.slice.insertAt(this.insert, gap.content)\n    if (!inserted) return StepResult.fail(\"Content does not fit in gap\")\n    return StepResult.fromReplace(doc, this.from, this.to, inserted)\n  }\n\n  getMap() {\n    return new StepMap([this.from, this.gapFrom - this.from, this.insert,\n                        this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])\n  }\n\n  invert(doc) {\n    let gap = this.gapTo - this.gapFrom\n    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap,\n                                 this.from + this.insert, this.from + this.insert + gap,\n                                 doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),\n                                 this.gapFrom - this.from, this.structure)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1)\n    if ((from.deleted && to.deleted) || gapFrom < from.pos || gapTo > to.pos) return null\n    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure)\n  }\n\n  toJSON() {\n    let json = {stepType: \"replaceAround\", from: this.from, to: this.to,\n                gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert}\n    if (this.slice.size) json.slice = this.slice.toJSON()\n    if (this.structure) json.structure = true\n    return json\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\" ||\n        typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\")\n    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo,\n                                 Slice.fromJSON(schema, json.slice), json.insert, !!json.structure)\n  }\n}\n\nStep.jsonID(\"replaceAround\", ReplaceAroundStep)\n\nfunction contentBetween(doc, from, to) {\n  let $from = doc.resolve(from), dist = to - from, depth = $from.depth\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--\n    dist--\n  }\n  if (dist > 0) {\n    let next = $from.node(depth).maybeChild($from.indexAfter(depth))\n    while (dist > 0) {\n      if (!next || next.isLeaf) return true\n      next = next.firstChild\n      dist--\n    }\n  }\n  return false\n}\n","import {Slice, Fragment} from \"prosemirror-model\"\n\nimport {Transform} from \"./transform\"\nimport {ReplaceStep, ReplaceAroundStep} from \"./replace_step\"\n\nfunction canCut(node, start, end) {\n  return (start == 0 || node.canReplace(start, node.childCount)) &&\n    (end == node.childCount || node.canReplace(0, end))\n}\n\n// :: (NodeRange) → ?number\n// Try to find a target depth to which the content in the given range\n// can be lifted. Will not go across\n// [isolating](#model.NodeSpec.isolating) parent nodes.\nexport function liftTarget(range) {\n  let parent = range.parent\n  let content = parent.content.cutByIndex(range.startIndex, range.endIndex)\n  for (let depth = range.depth;; --depth) {\n    let node = range.$from.node(depth)\n    let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth)\n    if (depth < range.depth && node.canReplace(index, endIndex, content))\n      return depth\n    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) break\n  }\n}\n\n// :: (NodeRange, number) → this\n// Split the content in the given range off from its parent, if there\n// is sibling content before or after it, and move it up the tree to\n// the depth specified by `target`. You'll probably want to use\n// [`liftTarget`](#transform.liftTarget) to compute `target`, to make\n// sure the lift is valid.\nTransform.prototype.lift = function(range, target) {\n  let {$from, $to, depth} = range\n\n  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1)\n  let start = gapStart, end = gapEnd\n\n  let before = Fragment.empty, openStart = 0\n  for (let d = depth, splitting = false; d > target; d--)\n    if (splitting || $from.index(d) > 0) {\n      splitting = true\n      before = Fragment.from($from.node(d).copy(before))\n      openStart++\n    } else {\n      start--\n    }\n  let after = Fragment.empty, openEnd = 0\n  for (let d = depth, splitting = false; d > target; d--)\n    if (splitting || $to.after(d + 1) < $to.end(d)) {\n      splitting = true\n      after = Fragment.from($to.node(d).copy(after))\n      openEnd++\n    } else {\n      end++\n    }\n\n  return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd,\n                                         new Slice(before.append(after), openStart, openEnd),\n                                         before.size - openStart, true))\n}\n\n// :: (NodeRange, NodeType, ?Object, ?NodeRange) → ?[{type: NodeType, attrs: ?Object}]\n// Try to find a valid way to wrap the content in the given range in a\n// node of the given type. May introduce extra nodes around and inside\n// the wrapper node, if necessary. Returns null if no valid wrapping\n// could be found. When `innerRange` is given, that range's content is\n// used as the content to fit into the wrapping, instead of the\n// content of `range`.\nexport function findWrapping(range, nodeType, attrs, innerRange = range) {\n  let around = findWrappingOutside(range, nodeType)\n  let inner = around && findWrappingInside(innerRange, nodeType)\n  if (!inner) return null\n  return around.map(withAttrs).concat({type: nodeType, attrs}).concat(inner.map(withAttrs))\n}\n\nfunction withAttrs(type) { return {type, attrs: null} }\n\nfunction findWrappingOutside(range, type) {\n  let {parent, startIndex, endIndex} = range\n  let around = parent.contentMatchAt(startIndex).findWrapping(type)\n  if (!around) return null\n  let outer = around.length ? around[0] : type\n  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null\n}\n\nfunction findWrappingInside(range, type) {\n  let {parent, startIndex, endIndex} = range\n  let inner = parent.child(startIndex)\n  let inside = type.contentMatch.findWrapping(inner.type)\n  if (!inside) return null\n  let lastType = inside.length ? inside[inside.length - 1] : type\n  let innerMatch = lastType.contentMatch\n  for (let i = startIndex; innerMatch && i < endIndex; i++)\n    innerMatch = innerMatch.matchType(parent.child(i).type)\n  if (!innerMatch || !innerMatch.validEnd) return null\n  return inside\n}\n\n// :: (NodeRange, [{type: NodeType, attrs: ?Object}]) → this\n// Wrap the given [range](#model.NodeRange) in the given set of wrappers.\n// The wrappers are assumed to be valid in this position, and should\n// probably be computed with [`findWrapping`](#transform.findWrapping).\nTransform.prototype.wrap = function(range, wrappers) {\n  let content = Fragment.empty\n  for (let i = wrappers.length - 1; i >= 0; i--) {\n    if (content.size) {\n      let match = wrappers[i].type.contentMatch.matchFragment(content)\n      if (!match || !match.validEnd)\n        throw new RangeError(\"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper\")\n    }\n    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content))\n  }\n\n  let start = range.start, end = range.end\n  return this.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true))\n}\n\n// :: (number, ?number, NodeType, ?Object) → this\n// Set the type of all textblocks (partly) between `from` and `to` to\n// the given node type with the given attributes.\nTransform.prototype.setBlockType = function(from, to = from, type, attrs) {\n  if (!type.isTextblock) throw new RangeError(\"Type given to setBlockType should be a textblock\")\n  let mapFrom = this.steps.length\n  this.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(this.doc, this.mapping.slice(mapFrom).map(pos), type)) {\n      // Ensure all markup that isn't allowed in the new node type is cleared\n      this.clearIncompatible(this.mapping.slice(mapFrom).map(pos, 1), type)\n      let mapping = this.mapping.slice(mapFrom)\n      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1)\n      this.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1,\n                                      new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true))\n      return false\n    }\n  })\n  return this\n}\n\nfunction canChangeType(doc, pos, type) {\n  let $pos = doc.resolve(pos), index = $pos.index()\n  return $pos.parent.canReplaceWith(index, index + 1, type)\n}\n\n// :: (number, ?NodeType, ?Object, ?[Mark]) → this\n// Change the type, attributes, and/or marks of the node at `pos`.\n// When `type` isn't given, the existing node type is preserved,\nTransform.prototype.setNodeMarkup = function(pos, type, attrs, marks) {\n  let node = this.doc.nodeAt(pos)\n  if (!node) throw new RangeError(\"No node at given position\")\n  if (!type) type = node.type\n  let newNode = type.create(attrs, null, marks || node.marks)\n  if (node.isLeaf)\n    return this.replaceWith(pos, pos + node.nodeSize, newNode)\n\n  if (!type.validContent(node.content))\n    throw new RangeError(\"Invalid content for node type \" + type.name)\n\n  return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1,\n                                         new Slice(Fragment.from(newNode), 0, 0), 1, true))\n}\n\n// :: (Node, number, number, ?[?{type: NodeType, attrs: ?Object}]) → bool\n// Check whether splitting at the given position is allowed.\nexport function canSplit(doc, pos, depth = 1, typesAfter) {\n  let $pos = doc.resolve(pos), base = $pos.depth - depth\n  let innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent\n  if (base < 0 || $pos.parent.type.spec.isolating ||\n      !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||\n      !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))\n    return false\n  for (let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n    let node = $pos.node(d), index = $pos.index(d)\n    if (node.type.spec.isolating) return false\n    let rest = node.content.cutByIndex(index, node.childCount)\n    let after = (typesAfter && typesAfter[i]) || node\n    if (after != node) rest = rest.replaceChild(0, after.type.create(after.attrs))\n    if (!node.canReplace(index + 1, node.childCount) || !after.type.validContent(rest))\n      return false\n  }\n  let index = $pos.indexAfter(base)\n  let baseType = typesAfter && typesAfter[0]\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type)\n}\n\n// :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}]) → this\n// Split the node at the given position, and optionally, if `depth` is\n// greater than one, any number of nodes above that. By default, the\n// parts split off will inherit the node type of the original node.\n// This can be changed by passing an array of types and attributes to\n// use after the split.\nTransform.prototype.split = function(pos, depth = 1, typesAfter) {\n  let $pos = this.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty\n  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n    before = Fragment.from($pos.node(d).copy(before))\n    let typeAfter = typesAfter && typesAfter[i]\n    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after))\n  }\n  return this.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true))\n}\n\n// :: (Node, number) → bool\n// Test whether the blocks before and after a given position can be\n// joined.\nexport function canJoin(doc, pos) {\n  let $pos = doc.resolve(pos), index = $pos.index()\n  return joinable($pos.nodeBefore, $pos.nodeAfter) &&\n    $pos.parent.canReplace(index, index + 1)\n}\n\nfunction joinable(a, b) {\n  return a && b && !a.isLeaf && a.canAppend(b)\n}\n\n// :: (Node, number, ?number) → ?number\n// Find an ancestor of the given position that can be joined to the\n// block before (or after if `dir` is positive). Returns the joinable\n// point, if any.\nexport function joinPoint(doc, pos, dir = -1) {\n  let $pos = doc.resolve(pos)\n  for (let d = $pos.depth;; d--) {\n    let before, after, index = $pos.index(d)\n    if (d == $pos.depth) {\n      before = $pos.nodeBefore\n      after = $pos.nodeAfter\n    } else if (dir > 0) {\n      before = $pos.node(d + 1)\n      index++\n      after = $pos.node(d).maybeChild(index)\n    } else {\n      before = $pos.node(d).maybeChild(index - 1)\n      after = $pos.node(d + 1)\n    }\n    if (before && !before.isTextblock && joinable(before, after) &&\n        $pos.node(d).canReplace(index, index + 1)) return pos\n    if (d == 0) break\n    pos = dir < 0 ? $pos.before(d) : $pos.after(d)\n  }\n}\n\n// :: (number, ?number) → this\n// Join the blocks around the given position. If depth is 2, their\n// last and first siblings are also joined, and so on.\nTransform.prototype.join = function(pos, depth = 1) {\n  let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true)\n  return this.step(step)\n}\n\n// :: (Node, number, NodeType) → ?number\n// Try to find a point where a node of the given type can be inserted\n// near `pos`, by searching up the node hierarchy when `pos` itself\n// isn't a valid place but is at the start or end of a node. Return\n// null if no position was found.\nexport function insertPoint(doc, pos, nodeType) {\n  let $pos = doc.resolve(pos)\n  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) return pos\n\n  if ($pos.parentOffset == 0)\n    for (let d = $pos.depth - 1; d >= 0; d--) {\n      let index = $pos.index(d)\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.before(d + 1)\n      if (index > 0) return null\n    }\n  if ($pos.parentOffset == $pos.parent.content.size)\n    for (let d = $pos.depth - 1; d >= 0; d--) {\n      let index = $pos.indexAfter(d)\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.after(d + 1)\n      if (index < $pos.node(d).childCount) return null\n    }\n}\n\n// :: (Node, number, Slice) → ?number\n// Finds a position at or around the given position where the given\n// slice can be inserted. Will look at parent nodes' nearest boundary\n// and try there, even if the original position wasn't directly at the\n// start or end of that node. Returns null when no position was found.\nexport function dropPoint(doc, pos, slice) {\n  let $pos = doc.resolve(pos)\n  if (!slice.content.size) return pos\n  let content = slice.content\n  for (let i = 0; i < slice.openStart; i++) content = content.firstChild.content\n  for (let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n    for (let d = $pos.depth; d >= 0; d--) {\n      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1\n      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0)\n      let parent = $pos.node(d), fits = false\n      if (pass == 1) {\n        fits = parent.canReplace(insertPos, insertPos, content)\n      } else {\n        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type)\n        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0])\n      }\n      if (fits)\n        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1)\n    }\n  }\n  return null\n}\n","import {Fragment, Slice} from \"prosemirror-model\"\nimport {Step, StepResult} from \"./step\"\n\nfunction mapFragment(fragment, f, parent) {\n  let mapped = []\n  for (let i = 0; i < fragment.childCount; i++) {\n    let child = fragment.child(i)\n    if (child.content.size) child = child.copy(mapFragment(child.content, f, child))\n    if (child.isInline) child = f(child, parent, i)\n    mapped.push(child)\n  }\n  return Fragment.fromArray(mapped)\n}\n\n// ::- Add a mark to all inline content between two positions.\nexport class AddMarkStep extends Step {\n  // :: (number, number, Mark)\n  constructor(from, to, mark) {\n    super()\n    // :: number\n    // The start of the marked range.\n    this.from = from\n    // :: number\n    // The end of the marked range.\n    this.to = to\n    // :: Mark\n    // The mark to add.\n    this.mark = mark\n  }\n\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from)\n    let parent = $from.node($from.sharedDepth(this.to))\n    let slice = new Slice(mapFragment(oldSlice.content, (node, parent) => {\n      if (!node.isAtom || !parent.type.allowsMarkType(this.mark.type)) return node\n      return node.mark(this.mark.addToSet(node.marks))\n    }, parent), oldSlice.openStart, oldSlice.openEnd)\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  }\n\n  invert() {\n    return new RemoveMarkStep(this.from, this.to, this.mark)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted || from.pos >= to.pos) return null\n    return new AddMarkStep(from.pos, to.pos, this.mark)\n  }\n\n  merge(other) {\n    if (other instanceof AddMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      return new AddMarkStep(Math.min(this.from, other.from),\n                             Math.max(this.to, other.to), this.mark)\n  }\n\n  toJSON() {\n    return {stepType: \"addMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\")\n    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  }\n}\n\nStep.jsonID(\"addMark\", AddMarkStep)\n\n// ::- Remove a mark from all inline content between two positions.\nexport class RemoveMarkStep extends Step {\n  // :: (number, number, Mark)\n  constructor(from, to, mark) {\n    super()\n    // :: number\n    // The start of the unmarked range.\n    this.from = from\n    // :: number\n    // The end of the unmarked range.\n    this.to = to\n    // :: Mark\n    // The mark to remove.\n    this.mark = mark\n  }\n\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to)\n    let slice = new Slice(mapFragment(oldSlice.content, node => {\n      return node.mark(this.mark.removeFromSet(node.marks))\n    }), oldSlice.openStart, oldSlice.openEnd)\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  }\n\n  invert() {\n    return new AddMarkStep(this.from, this.to, this.mark)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted || from.pos >= to.pos) return null\n    return new RemoveMarkStep(from.pos, to.pos, this.mark)\n  }\n\n  merge(other) {\n    if (other instanceof RemoveMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      return new RemoveMarkStep(Math.min(this.from, other.from),\n                                Math.max(this.to, other.to), this.mark)\n  }\n\n  toJSON() {\n    return {stepType: \"removeMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\")\n    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  }\n}\n\nStep.jsonID(\"removeMark\", RemoveMarkStep)\n","import {Slice, Fragment} from \"prosemirror-model\"\nimport {ReplaceStep, ReplaceAroundStep} from \"prosemirror-transform\"\n\nconst classesById = Object.create(null)\n\n// ::- Superclass for editor selections. Every selection type should\n// extend this. Should not be instantiated directly.\nexport class Selection {\n  // :: (ResolvedPos, ResolvedPos, ?[SelectionRange])\n  // Initialize a selection with the head and anchor and ranges. If no\n  // ranges are given, constructs a single range across `$anchor` and\n  // `$head`.\n  constructor($anchor, $head, ranges) {\n    // :: [SelectionRange]\n    // The ranges covered by the selection.\n    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))]\n    // :: ResolvedPos\n    // The resolved anchor of the selection (the side that stays in\n    // place when the selection is modified).\n    this.$anchor = $anchor\n    // :: ResolvedPos\n    // The resolved head of the selection (the side that moves when\n    // the selection is modified).\n    this.$head = $head\n  }\n\n  // :: number\n  // The selection's anchor, as an unresolved position.\n  get anchor() { return this.$anchor.pos }\n\n  // :: number\n  // The selection's head.\n  get head() { return this.$head.pos }\n\n  // :: number\n  // The lower bound of the selection's main range.\n  get from() { return this.$from.pos }\n\n  // :: number\n  // The upper bound of the selection's main range.\n  get to() { return this.$to.pos }\n\n  // :: ResolvedPos\n  // The resolved lower  bound of the selection's main range.\n  get $from() {\n    return this.ranges[0].$from\n  }\n\n  // :: ResolvedPos\n  // The resolved upper bound of the selection's main range.\n  get $to() {\n    return this.ranges[0].$to\n  }\n\n  // :: bool\n  // Indicates whether the selection contains any content.\n  get empty() {\n    let ranges = this.ranges\n    for (let i = 0; i < ranges.length; i++)\n      if (ranges[i].$from.pos != ranges[i].$to.pos) return false\n    return true\n  }\n\n  // eq:: (Selection) → bool\n  // Test whether the selection is the same as another selection.\n\n  // map:: (doc: Node, mapping: Mappable) → Selection\n  // Map this selection through a [mappable](#transform.Mappable) thing. `doc`\n  // should be the new document to which we are mapping.\n\n  // :: () → Slice\n  // Get the content of this selection as a slice.\n  content() {\n    return this.$from.node(0).slice(this.from, this.to, true)\n  }\n\n  // :: (Transaction, ?Slice)\n  // Replace the selection with a slice or, if no slice is given,\n  // delete the selection. Will append to the given transaction.\n  replace(tr, content = Slice.empty) {\n    // Put the new selection at the position after the inserted\n    // content. When that ended in an inline node, search backwards,\n    // to get the position after that node. If not, search forward.\n    let lastNode = content.content.lastChild, lastParent = null\n    for (let i = 0; i < content.openEnd; i++) {\n      lastParent = lastNode\n      lastNode = lastNode.lastChild\n    }\n\n    let mapFrom = tr.steps.length, ranges = this.ranges\n    for (let i = 0; i < ranges.length; i++) {\n      let {$from, $to} = ranges[i], mapping = tr.mapping.slice(mapFrom)\n      tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content)\n      if (i == 0)\n        selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1)\n    }\n  }\n\n  // :: (Transaction, Node)\n  // Replace the selection with the given node, appending the changes\n  // to the given transaction.\n  replaceWith(tr, node) {\n    let mapFrom = tr.steps.length, ranges = this.ranges\n    for (let i = 0; i < ranges.length; i++) {\n      let {$from, $to} = ranges[i], mapping = tr.mapping.slice(mapFrom)\n      let from = mapping.map($from.pos), to = mapping.map($to.pos)\n      if (i) {\n        tr.deleteRange(from, to)\n      } else {\n        tr.replaceRangeWith(from, to, node)\n        selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1)\n      }\n    }\n  }\n\n  // toJSON:: () → Object\n  // Convert the selection to a JSON representation. When implementing\n  // this for a custom selection class, make sure to give the object a\n  // `type` property whose value matches the ID under which you\n  // [registered](#state.Selection^jsonID) your class.\n\n  // :: (ResolvedPos, number, ?bool) → ?Selection\n  // Find a valid cursor or leaf node selection starting at the given\n  // position and searching back if `dir` is negative, and forward if\n  // positive. When `textOnly` is true, only consider cursor\n  // selections. Will return null when no valid selection position is\n  // found.\n  static findFrom($pos, dir, textOnly) {\n    let inner = $pos.parent.inlineContent ? new TextSelection($pos)\n        : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly)\n    if (inner) return inner\n\n    for (let depth = $pos.depth - 1; depth >= 0; depth--) {\n      let found = dir < 0\n          ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly)\n          : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly)\n      if (found) return found\n    }\n  }\n\n  // :: (ResolvedPos, ?number) → Selection\n  // Find a valid cursor or leaf node selection near the given\n  // position. Searches forward first by default, but if `bias` is\n  // negative, it will search backwards first.\n  static near($pos, bias = 1) {\n    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0))\n  }\n\n  // :: (Node) → Selection\n  // Find the cursor or leaf node selection closest to the start of\n  // the given document. Will return an\n  // [`AllSelection`](#state.AllSelection) if no valid position\n  // exists.\n  static atStart(doc) {\n    return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc)\n  }\n\n  // :: (Node) → Selection\n  // Find the cursor or leaf node selection closest to the end of the\n  // given document.\n  static atEnd(doc) {\n    return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc)\n  }\n\n  // :: (Node, Object) → Selection\n  // Deserialize the JSON representation of a selection. Must be\n  // implemented for custom classes (as a static class method).\n  static fromJSON(doc, json) {\n    if (!json || !json.type) throw new RangeError(\"Invalid input for Selection.fromJSON\")\n    let cls = classesById[json.type]\n    if (!cls) throw new RangeError(`No selection type ${json.type} defined`)\n    return cls.fromJSON(doc, json)\n  }\n\n  // :: (string, constructor<Selection>)\n  // To be able to deserialize selections from JSON, custom selection\n  // classes must register themselves with an ID string, so that they\n  // can be disambiguated. Try to pick something that's unlikely to\n  // clash with classes from other modules.\n  static jsonID(id, selectionClass) {\n    if (id in classesById) throw new RangeError(\"Duplicate use of selection JSON ID \" + id)\n    classesById[id] = selectionClass\n    selectionClass.prototype.jsonID = id\n    return selectionClass\n  }\n\n  // :: () → SelectionBookmark\n  // Get a [bookmark](#state.SelectionBookmark) for this selection,\n  // which is a value that can be mapped without having access to a\n  // current document, and later resolved to a real selection for a\n  // given document again. (This is used mostly by the history to\n  // track and restore old selections.) The default implementation of\n  // this method just converts the selection to a text selection and\n  // returns the bookmark for that.\n  getBookmark() {\n    return TextSelection.between(this.$anchor, this.$head).getBookmark()\n  }\n}\n\n// :: bool\n// Controls whether, when a selection of this type is active in the\n// browser, the selected range should be visible to the user. Defaults\n// to `true`.\nSelection.prototype.visible = true\n\n// SelectionBookmark:: interface\n// A lightweight, document-independent representation of a selection.\n// You can define a custom bookmark type for a custom selection class\n// to make the history handle it well.\n//\n//   map:: (mapping: Mapping) → SelectionBookmark\n//   Map the bookmark through a set of changes.\n//\n//   resolve:: (doc: Node) → Selection\n//   Resolve the bookmark to a real selection again. This may need to\n//   do some error checking and may fall back to a default (usually\n//   [`TextSelection.between`](#state.TextSelection^between)) if\n//   mapping made the bookmark invalid.\n\n// ::- Represents a selected range in a document.\nexport class SelectionRange {\n  // :: (ResolvedPos, ResolvedPos)\n  constructor($from, $to) {\n    // :: ResolvedPos\n    // The lower bound of the range.\n    this.$from = $from\n    // :: ResolvedPos\n    // The upper bound of the range.\n    this.$to = $to\n  }\n}\n\n// ::- A text selection represents a classical editor selection, with\n// a head (the moving side) and anchor (immobile side), both of which\n// point into textblock nodes. It can be empty (a regular cursor\n// position).\nexport class TextSelection extends Selection {\n  // :: (ResolvedPos, ?ResolvedPos)\n  // Construct a text selection between the given points.\n  constructor($anchor, $head = $anchor) {\n    super($anchor, $head)\n  }\n\n  // :: ?ResolvedPos\n  // Returns a resolved position if this is a cursor selection (an\n  // empty text selection), and null otherwise.\n  get $cursor() { return this.$anchor.pos == this.$head.pos ? this.$head : null }\n\n  map(doc, mapping) {\n    let $head = doc.resolve(mapping.map(this.head))\n    if (!$head.parent.inlineContent) return Selection.near($head)\n    let $anchor = doc.resolve(mapping.map(this.anchor))\n    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head)\n  }\n\n  replace(tr, content = Slice.empty) {\n    super.replace(tr, content)\n    if (content == Slice.empty) {\n      let marks = this.$from.marksAcross(this.$to)\n      if (marks) tr.ensureMarks(marks)\n    }\n  }\n\n  eq(other) {\n    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head\n  }\n\n  getBookmark() {\n    return new TextBookmark(this.anchor, this.head)\n  }\n\n  toJSON() {\n    return {type: \"text\", anchor: this.anchor, head: this.head}\n  }\n\n  static fromJSON(doc, json) {\n    if (typeof json.anchor != \"number\" || typeof json.head != \"number\")\n      throw new RangeError(\"Invalid input for TextSelection.fromJSON\")\n    return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head))\n  }\n\n  // :: (Node, number, ?number) → TextSelection\n  // Create a text selection from non-resolved positions.\n  static create(doc, anchor, head = anchor) {\n    let $anchor = doc.resolve(anchor)\n    return new this($anchor, head == anchor ? $anchor : doc.resolve(head))\n  }\n\n  // :: (ResolvedPos, ResolvedPos, ?number) → Selection\n  // Return a text selection that spans the given positions or, if\n  // they aren't text positions, find a text selection near them.\n  // `bias` determines whether the method searches forward (default)\n  // or backwards (negative number) first. Will fall back to calling\n  // [`Selection.near`](#state.Selection^near) when the document\n  // doesn't contain a valid text position.\n  static between($anchor, $head, bias) {\n    let dPos = $anchor.pos - $head.pos\n    if (!bias || dPos) bias = dPos >= 0 ? 1 : -1\n    if (!$head.parent.inlineContent) {\n      let found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true)\n      if (found) $head = found.$head\n      else return Selection.near($head, bias)\n    }\n    if (!$anchor.parent.inlineContent) {\n      if (dPos == 0) {\n        $anchor = $head\n      } else {\n        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor\n        if (($anchor.pos < $head.pos) != (dPos < 0)) $anchor = $head\n      }\n    }\n    return new TextSelection($anchor, $head)\n  }\n}\n\nSelection.jsonID(\"text\", TextSelection)\n\nclass TextBookmark {\n  constructor(anchor, head) {\n    this.anchor = anchor\n    this.head = head\n  }\n  map(mapping) {\n    return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head))\n  }\n  resolve(doc) {\n    return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head))\n  }\n}\n\n// ::- A node selection is a selection that points at a single node.\n// All nodes marked [selectable](#model.NodeSpec.selectable) can be\n// the target of a node selection. In such a selection, `from` and\n// `to` point directly before and after the selected node, `anchor`\n// equals `from`, and `head` equals `to`..\nexport class NodeSelection extends Selection {\n  // :: (ResolvedPos)\n  // Create a node selection. Does not verify the validity of its\n  // argument.\n  constructor($pos) {\n    let node = $pos.nodeAfter\n    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize)\n    super($pos, $end)\n    // :: Node The selected node.\n    this.node = node\n  }\n\n  map(doc, mapping) {\n    let {deleted, pos} = mapping.mapResult(this.anchor)\n    let $pos = doc.resolve(pos)\n    if (deleted) return Selection.near($pos)\n    return new NodeSelection($pos)\n  }\n\n  content() {\n    return new Slice(Fragment.from(this.node), 0, 0)\n  }\n\n  eq(other) {\n    return other instanceof NodeSelection && other.anchor == this.anchor\n  }\n\n  toJSON() {\n    return {type: \"node\", anchor: this.anchor}\n  }\n\n  getBookmark() { return new NodeBookmark(this.anchor) }\n\n  static fromJSON(doc, json) {\n    if (typeof json.anchor != \"number\")\n      throw new RangeError(\"Invalid input for NodeSelection.fromJSON\")\n    return new NodeSelection(doc.resolve(json.anchor))\n  }\n\n  // :: (Node, number) → NodeSelection\n  // Create a node selection from non-resolved positions.\n  static create(doc, from) {\n    return new this(doc.resolve(from))\n  }\n\n  // :: (Node) → bool\n  // Determines whether the given node may be selected as a node\n  // selection.\n  static isSelectable(node) {\n    return !node.isText && node.type.spec.selectable !== false\n  }\n}\n\nNodeSelection.prototype.visible = false\n\nSelection.jsonID(\"node\", NodeSelection)\n\nclass NodeBookmark {\n  constructor(anchor) {\n    this.anchor = anchor\n  }\n  map(mapping) {\n    let {deleted, pos} = mapping.mapResult(this.anchor)\n    return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos)\n  }\n  resolve(doc) {\n    let $pos = doc.resolve(this.anchor), node = $pos.nodeAfter\n    if (node && NodeSelection.isSelectable(node)) return new NodeSelection($pos)\n    return Selection.near($pos)\n  }\n}\n\n// ::- A selection type that represents selecting the whole document\n// (which can not necessarily be expressed with a text selection, when\n// there are for example leaf block nodes at the start or end of the\n// document).\nexport class AllSelection extends Selection {\n  // :: (Node)\n  // Create an all-selection over the given document.\n  constructor(doc) {\n    super(doc.resolve(0), doc.resolve(doc.content.size))\n  }\n\n  replace(tr, content = Slice.empty) {\n    if (content == Slice.empty) {\n      tr.delete(0, tr.doc.content.size)\n      let sel = Selection.atStart(tr.doc)\n      if (!sel.eq(tr.selection)) tr.setSelection(sel)\n    } else {\n      super.replace(tr, content)\n    }\n  }\n\n  toJSON() { return {type: \"all\"} }\n\n  static fromJSON(doc) { return new AllSelection(doc) }\n\n  map(doc) { return new AllSelection(doc) }\n\n  eq(other) { return other instanceof AllSelection }\n\n  getBookmark() { return AllBookmark }\n}\n\nSelection.jsonID(\"all\", AllSelection)\n\nconst AllBookmark = {\n  map() { return this },\n  resolve(doc) { return new AllSelection(doc) }\n}\n\n// FIXME we'll need some awareness of text direction when scanning for selections\n\n// Try to find a selection inside the given node. `pos` points at the\n// position where the search starts. When `text` is true, only return\n// text selections.\nfunction findSelectionIn(doc, node, pos, index, dir, text) {\n  if (node.inlineContent) return TextSelection.create(doc, pos)\n  for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n    let child = node.child(i)\n    if (!child.isAtom) {\n      let inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text)\n      if (inner) return inner\n    } else if (!text && NodeSelection.isSelectable(child)) {\n      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0))\n    }\n    pos += child.nodeSize * dir\n  }\n}\n\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  let last = tr.steps.length - 1\n  if (last < startLen) return\n  let step = tr.steps[last]\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) return\n  let map = tr.mapping.maps[last], end\n  map.forEach((_from, _to, _newFrom, newTo) => { if (end == null) end = newTo })\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias))\n}\n","import {Transform} from \"prosemirror-transform\"\nimport {Mark} from \"prosemirror-model\"\nimport {Selection} from \"./selection\"\n\nconst UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4\n\n// ::- An editor state transaction, which can be applied to a state to\n// create an updated state. Use\n// [`EditorState.tr`](#state.EditorState.tr) to create an instance.\n//\n// Transactions track changes to the document (they are a subclass of\n// [`Transform`](#transform.Transform)), but also other state changes,\n// like selection updates and adjustments of the set of [stored\n// marks](#state.EditorState.storedMarks). In addition, you can store\n// metadata properties in a transaction, which are extra pieces of\n// information that client code or plugins can use to describe what a\n// transacion represents, so that they can update their [own\n// state](#state.StateField) accordingly.\n//\n// The [editor view](#view.EditorView) uses a few metadata properties:\n// it will attach a property `\"pointer\"` with the value `true` to\n// selection transactions directly caused by mouse or touch input, and\n// a `\"uiEvent\"` property of that may be `\"paste\"`, `\"cut\"`, or `\"drop\"`.\nexport class Transaction extends Transform {\n  constructor(state) {\n    super(state.doc)\n    // :: number\n    // The timestamp associated with this transaction, in the same\n    // format as `Date.now()`.\n    this.time = Date.now()\n    this.curSelection = state.selection\n    // The step count for which the current selection is valid.\n    this.curSelectionFor = 0\n    // :: ?[Mark]\n    // The stored marks set by this transaction, if any.\n    this.storedMarks = state.storedMarks\n    // Bitfield to track which aspects of the state were updated by\n    // this transaction.\n    this.updated = 0\n    // Object used to store metadata properties for the transaction.\n    this.meta = Object.create(null)\n  }\n\n  // :: Selection\n  // The transaction's current selection. This defaults to the editor\n  // selection [mapped](#state.Selection.map) through the steps in the\n  // transaction, but can be overwritten with\n  // [`setSelection`](#state.Transaction.setSelection).\n  get selection() {\n    if (this.curSelectionFor < this.steps.length) {\n      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor))\n      this.curSelectionFor = this.steps.length\n    }\n    return this.curSelection\n  }\n\n  // :: (Selection) → Transaction\n  // Update the transaction's current selection. Will determine the\n  // selection that the editor gets when the transaction is applied.\n  setSelection(selection) {\n    if (selection.$from.doc != this.doc)\n      throw new RangeError(\"Selection passed to setSelection must point at the current document\")\n    this.curSelection = selection\n    this.curSelectionFor = this.steps.length\n    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS\n    this.storedMarks = null\n    return this\n  }\n\n  // :: bool\n  // Whether the selection was explicitly updated by this transaction.\n  get selectionSet() {\n    return (this.updated & UPDATED_SEL) > 0\n  }\n\n  // :: (?[Mark]) → Transaction\n  // Set the current stored marks.\n  setStoredMarks(marks) {\n    this.storedMarks = marks\n    this.updated |= UPDATED_MARKS\n    return this\n  }\n\n  // :: ([Mark]) → Transaction\n  // Make sure the current stored marks or, if that is null, the marks\n  // at the selection, match the given set of marks. Does nothing if\n  // this is already the case.\n  ensureMarks(marks) {\n    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))\n      this.setStoredMarks(marks)\n    return this\n  }\n\n  // :: (Mark) → Transaction\n  // Add a mark to the set of stored marks.\n  addStoredMark(mark) {\n    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()))\n  }\n\n  // :: (union<Mark, MarkType>) → Transaction\n  // Remove a mark or mark type from the set of stored marks.\n  removeStoredMark(mark) {\n    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()))\n  }\n\n  // :: bool\n  // Whether the stored marks were explicitly set for this transaction.\n  get storedMarksSet() {\n    return (this.updated & UPDATED_MARKS) > 0\n  }\n\n  addStep(step, doc) {\n    super.addStep(step, doc)\n    this.updated = this.updated & ~UPDATED_MARKS\n    this.storedMarks = null\n  }\n\n  // :: (number) → Transaction\n  // Update the timestamp for the transaction.\n  setTime(time) {\n    this.time = time\n    return this\n  }\n\n  // :: (Slice) → Transaction\n  // Replace the current selection with the given slice.\n  replaceSelection(slice) {\n    this.selection.replace(this, slice)\n    return this\n  }\n\n  // :: (Node, ?bool) → Transaction\n  // Replace the selection with the given node. When `inheritMarks` is\n  // true and the content is inline, it inherits the marks from the\n  // place where it is inserted.\n  replaceSelectionWith(node, inheritMarks) {\n    let selection = this.selection\n    if (inheritMarks !== false)\n      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : (selection.$from.marksAcross(selection.$to) || Mark.none)))\n    selection.replaceWith(this, node)\n    return this\n  }\n\n  // :: () → Transaction\n  // Delete the selection.\n  deleteSelection() {\n    this.selection.replace(this)\n    return this\n  }\n\n  // :: (string, from: ?number, to: ?number) → Transaction\n  // Replace the given range, or the selection if no range is given,\n  // with a text node containing the given string.\n  insertText(text, from, to = from) {\n    let schema = this.doc.type.schema\n    if (from == null) {\n      if (!text) return this.deleteSelection()\n      return this.replaceSelectionWith(schema.text(text), true)\n    } else {\n      if (!text) return this.deleteRange(from, to)\n      let marks = this.storedMarks\n      if (!marks) {\n        let $from = this.doc.resolve(from)\n        marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to))\n      }\n      this.replaceRangeWith(from, to, schema.text(text, marks))\n      if (!this.selection.empty) this.setSelection(Selection.near(this.selection.$to))\n      return this\n    }\n  }\n\n  // :: (union<string, Plugin, PluginKey>, any) → Transaction\n  // Store a metadata property in this transaction, keyed either by\n  // name or by plugin.\n  setMeta(key, value) {\n    this.meta[typeof key == \"string\" ? key : key.key] = value\n    return this\n  }\n\n  // :: (union<string, Plugin, PluginKey>) → any\n  // Retrieve a metadata property for a given name or plugin.\n  getMeta(key) {\n    return this.meta[typeof key == \"string\" ? key : key.key]\n  }\n\n  // :: bool\n  // Returns true if this transaction doesn't contain any metadata,\n  // and can thus safely be extended.\n  get isGeneric() {\n    for (let _ in this.meta) return false\n    return true\n  }\n\n  // :: () → Transaction\n  // Indicate that the editor should scroll the selection into view\n  // when updated to the state produced by this transaction.\n  scrollIntoView() {\n    this.updated |= UPDATED_SCROLL\n    return this\n  }\n\n  get scrolledIntoView() {\n    return (this.updated & UPDATED_SCROLL) > 0\n  }\n}\n","import {Node} from \"prosemirror-model\"\n\nimport {Selection} from \"./selection\"\nimport {Transaction} from \"./transaction\"\n\nfunction bind(f, self) {\n  return !self || !f ? f : f.bind(self)\n}\n\nclass FieldDesc {\n  constructor(name, desc, self) {\n    this.name = name\n    this.init = bind(desc.init, self)\n    this.apply = bind(desc.apply, self)\n  }\n}\n\nconst baseFields = [\n  new FieldDesc(\"doc\", {\n    init(config) { return config.doc || config.schema.topNodeType.createAndFill() },\n    apply(tr) { return tr.doc }\n  }),\n\n  new FieldDesc(\"selection\", {\n    init(config, instance) { return config.selection || Selection.atStart(instance.doc) },\n    apply(tr) { return tr.selection }\n  }),\n\n  new FieldDesc(\"storedMarks\", {\n    init(config) { return config.storedMarks || null },\n    apply(tr, _marks, _old, state) { return state.selection.$cursor ? tr.storedMarks : null }\n  }),\n\n  new FieldDesc(\"scrollToSelection\", {\n    init() { return 0 },\n    apply(tr, prev) { return tr.scrolledIntoView ? prev + 1 : prev }\n  })\n]\n\n// Object wrapping the part of a state object that stays the same\n// across transactions. Stored in the state's `config` property.\nclass Configuration {\n  constructor(schema, plugins) {\n    this.schema = schema\n    this.fields = baseFields.concat()\n    this.plugins = []\n    this.pluginsByKey = Object.create(null)\n    if (plugins) plugins.forEach(plugin => {\n      if (this.pluginsByKey[plugin.key])\n        throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\")\n      this.plugins.push(plugin)\n      this.pluginsByKey[plugin.key] = plugin\n      if (plugin.spec.state)\n        this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin))\n    })\n  }\n}\n\n// ::- The state of a ProseMirror editor is represented by an object\n// of this type. A state is a persistent data structure—it isn't\n// updated, but rather a new state value is computed from an old one\n// using the [`apply`](#state.EditorState.apply) method.\n//\n// A state holds a number of built-in fields, and plugins can\n// [define](#state.PluginSpec.state) additional fields.\nexport class EditorState {\n  constructor(config) {\n    this.config = config\n  }\n\n  // doc:: Node\n  // The current document.\n\n  // selection:: Selection\n  // The selection.\n\n  // storedMarks:: ?[Mark]\n  // A set of marks to apply to the next input. Will be null when\n  // no explicit marks have been set.\n\n  // :: Schema\n  // The schema of the state's document.\n  get schema() {\n    return this.config.schema\n  }\n\n  // :: [Plugin]\n  // The plugins that are active in this state.\n  get plugins() {\n    return this.config.plugins\n  }\n\n  // :: (Transaction) → EditorState\n  // Apply the given transaction to produce a new state.\n  apply(tr) {\n    return this.applyTransaction(tr).state\n  }\n\n  // : (Transaction) → bool\n  filterTransaction(tr, ignore = -1) {\n    for (let i = 0; i < this.config.plugins.length; i++) if (i != ignore) {\n      let plugin = this.config.plugins[i]\n      if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))\n        return false\n    }\n    return true\n  }\n\n  // :: (Transaction) → {state: EditorState, transactions: [Transaction]}\n  // Verbose variant of [`apply`](#state.EditorState.apply) that\n  // returns the precise transactions that were applied (which might\n  // be influenced by the [transaction\n  // hooks](#state.PluginSpec.filterTransaction) of\n  // plugins) along with the new state.\n  applyTransaction(rootTr) {\n    if (!this.filterTransaction(rootTr)) return {state: this, transactions: []}\n\n    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null\n    // This loop repeatedly gives plugins a chance to respond to\n    // transactions as new transactions are added, making sure to only\n    // pass the transactions the plugin did not see before.\n    outer: for (;;) {\n      let haveNew = false\n      for (let i = 0; i < this.config.plugins.length; i++) {\n        let plugin = this.config.plugins[i]\n        if (plugin.spec.appendTransaction) {\n          let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this\n          let tr = n < trs.length &&\n              plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState)\n          if (tr && newState.filterTransaction(tr, i)) {\n            tr.setMeta(\"appendedTransaction\", rootTr)\n            if (!seen) {\n              seen = []\n              for (let j = 0; j < this.config.plugins.length; j++)\n                seen.push(j < i ? {state: newState, n: trs.length} : {state: this, n: 0})\n            }\n            trs.push(tr)\n            newState = newState.applyInner(tr)\n            haveNew = true\n          }\n          if (seen) seen[i] = {state: newState, n: trs.length}\n        }\n      }\n      if (!haveNew) return {state: newState, transactions: trs}\n    }\n  }\n\n  // : (Transaction) → EditorState\n  applyInner(tr) {\n    if (!tr.before.eq(this.doc)) throw new RangeError(\"Applying a mismatched transaction\")\n    let newInstance = new EditorState(this.config), fields = this.config.fields\n    for (let i = 0; i < fields.length; i++) {\n      let field = fields[i]\n      newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance)\n    }\n    for (let i = 0; i < applyListeners.length; i++) applyListeners[i](this, tr, newInstance)\n    return newInstance\n  }\n\n  // :: Transaction\n  // Start a [transaction](#state.Transaction) from this state.\n  get tr() { return new Transaction(this) }\n\n  // :: (Object) → EditorState\n  // Create a new state.\n  //\n  //   config::- Configuration options. Must contain `schema` or `doc` (or both).\n  //\n  //      schema:: ?Schema\n  //      The schema to use (only relevant if no `doc` is specified).\n  //\n  //      doc:: ?Node\n  //      The starting document.\n  //\n  //      selection:: ?Selection\n  //      A valid selection in the document.\n  //\n  //      storedMarks:: ?[Mark]\n  //      The initial set of [stored marks](#state.EditorState.storedMarks).\n  //\n  //      plugins:: ?[Plugin]\n  //      The plugins that should be active in this state.\n  static create(config) {\n    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins)\n    let instance = new EditorState($config)\n    for (let i = 0; i < $config.fields.length; i++)\n      instance[$config.fields[i].name] = $config.fields[i].init(config, instance)\n    return instance\n  }\n\n  // :: (Object) → EditorState\n  // Create a new state based on this one, but with an adjusted set of\n  // active plugins. State fields that exist in both sets of plugins\n  // are kept unchanged. Those that no longer exist are dropped, and\n  // those that are new are initialized using their\n  // [`init`](#state.StateField.init) method, passing in the new\n  // configuration object..\n  //\n  //   config::- configuration options\n  //\n  //     plugins:: [Plugin]\n  //     New set of active plugins.\n  reconfigure(config) {\n    let $config = new Configuration(this.schema, config.plugins)\n    let fields = $config.fields, instance = new EditorState($config)\n    for (let i = 0; i < fields.length; i++) {\n      let name = fields[i].name\n      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance)\n    }\n    return instance\n  }\n\n  // :: (?union<Object<Plugin>, string, number>) → Object\n  // Serialize this state to JSON. If you want to serialize the state\n  // of plugins, pass an object mapping property names to use in the\n  // resulting JSON object to plugin objects. The argument may also be\n  // a string or number, in which case it is ignored, to support the\n  // way `JSON.stringify` calls `toString` methods.\n  toJSON(pluginFields) {\n    let result = {doc: this.doc.toJSON(), selection: this.selection.toJSON()}\n    if (this.storedMarks) result.storedMarks = this.storedMarks.map(m => m.toJSON())\n    if (pluginFields && typeof pluginFields == 'object') for (let prop in pluginFields) {\n      if (prop == \"doc\" || prop == \"selection\")\n        throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\")\n      let plugin = pluginFields[prop], state = plugin.spec.state\n      if (state && state.toJSON) result[prop] = state.toJSON.call(plugin, this[plugin.key])\n    }\n    return result\n  }\n\n  // :: (Object, Object, ?Object<Plugin>) → EditorState\n  // Deserialize a JSON representation of a state. `config` should\n  // have at least a `schema` field, and should contain array of\n  // plugins to initialize the state with. `pluginFields` can be used\n  // to deserialize the state of plugins, by associating plugin\n  // instances with the property names they use in the JSON object.\n  //\n  //   config::- configuration options\n  //\n  //     schema:: Schema\n  //     The schema to use.\n  //\n  //     plugins:: ?[Plugin]\n  //     The set of active plugins.\n  static fromJSON(config, json, pluginFields) {\n    if (!json) throw new RangeError(\"Invalid input for EditorState.fromJSON\")\n    if (!config.schema) throw new RangeError(\"Required config field 'schema' missing\")\n    let $config = new Configuration(config.schema, config.plugins)\n    let instance = new EditorState($config)\n    $config.fields.forEach(field => {\n      if (field.name == \"doc\") {\n        instance.doc = Node.fromJSON(config.schema, json.doc)\n      } else if (field.name == \"selection\") {\n        instance.selection = Selection.fromJSON(instance.doc, json.selection)\n      } else if (field.name == \"storedMarks\") {\n        if (json.storedMarks) instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON)\n      } else {\n        if (pluginFields) for (let prop in pluginFields) {\n          let plugin = pluginFields[prop], state = plugin.spec.state\n          if (plugin.key == field.name && state && state.fromJSON &&\n              Object.prototype.hasOwnProperty.call(json, prop)) {\n            // This field belongs to a plugin mapped to a JSON field, read it from there.\n            instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance)\n            return\n          }\n        }\n        instance[field.name] = field.init(config, instance)\n      }\n    })\n    return instance\n  }\n\n  // Kludge to allow the view to track mappings between different\n  // instances of a state.\n  //\n  // FIXME this is no longer needed as of prosemirror-view 1.9.0,\n  // though due to backwards-compat we should probably keep it around\n  // for a while (if only as a no-op)\n  static addApplyListener(f) {\n    applyListeners.push(f)\n  }\n  static removeApplyListener(f) {\n    let found = applyListeners.indexOf(f)\n    if (found > -1) applyListeners.splice(found, 1)\n  }\n}\n\nconst applyListeners = []\n","// PluginSpec:: interface\n//\n// This is the type passed to the [`Plugin`](#state.Plugin)\n// constructor. It provides a definition for a plugin.\n//\n//   props:: ?EditorProps\n//   The [view props](#view.EditorProps) added by this plugin. Props\n//   that are functions will be bound to have the plugin instance as\n//   their `this` binding.\n//\n//   state:: ?StateField<any>\n//   Allows a plugin to define a [state field](#state.StateField), an\n//   extra slot in the state object in which it can keep its own data.\n//\n//   key:: ?PluginKey\n//   Can be used to make this a keyed plugin. You can have only one\n//   plugin with a given key in a given state, but it is possible to\n//   access the plugin's configuration and state through the key,\n//   without having access to the plugin instance object.\n//\n//   view:: ?(EditorView) → Object\n//   When the plugin needs to interact with the editor view, or\n//   set something up in the DOM, use this field. The function\n//   will be called when the plugin's state is associated with an\n//   editor view.\n//\n//     return::-\n//     Should return an object with the following optional\n//     properties:\n//\n//       update:: ?(view: EditorView, prevState: EditorState)\n//       Called whenever the view's state is updated.\n//\n//       destroy:: ?()\n//       Called when the view is destroyed or receives a state\n//       with different plugins.\n//\n//   filterTransaction:: ?(Transaction, EditorState) → bool\n//   When present, this will be called before a transaction is\n//   applied by the state, allowing the plugin to cancel it (by\n//   returning false).\n//\n//   appendTransaction:: ?(transactions: [Transaction], oldState: EditorState, newState: EditorState) → ?Transaction\n//   Allows the plugin to append another transaction to be applied\n//   after the given array of transactions. When another plugin\n//   appends a transaction after this was called, it is called again\n//   with the new state and new transactions—but only the new\n//   transactions, i.e. it won't be passed transactions that it\n//   already saw.\n\nfunction bindProps(obj, self, target) {\n  for (let prop in obj) {\n    let val = obj[prop]\n    if (val instanceof Function) val = val.bind(self)\n    else if (prop == \"handleDOMEvents\") val = bindProps(val, self, {})\n    target[prop] = val\n  }\n  return target\n}\n\n// ::- Plugins bundle functionality that can be added to an editor.\n// They are part of the [editor state](#state.EditorState) and\n// may influence that state and the view that contains it.\nexport class Plugin {\n  // :: (PluginSpec)\n  // Create a plugin.\n  constructor(spec) {\n    // :: EditorProps\n    // The [props](#view.EditorProps) exported by this plugin.\n    this.props = {}\n    if (spec.props) bindProps(spec.props, this, this.props)\n    // :: Object\n    // The plugin's [spec object](#state.PluginSpec).\n    this.spec = spec\n    this.key = spec.key ? spec.key.key : createKey(\"plugin\")\n  }\n\n  // :: (EditorState) → any\n  // Extract the plugin's state field from an editor state.\n  getState(state) { return state[this.key] }\n}\n\n// StateField:: interface<T>\n// A plugin spec may provide a state field (under its\n// [`state`](#state.PluginSpec.state) property) of this type, which\n// describes the state it wants to keep. Functions provided here are\n// always called with the plugin instance as their `this` binding.\n//\n//   init:: (config: Object, instance: EditorState) → T\n//   Initialize the value of the field. `config` will be the object\n//   passed to [`EditorState.create`](#state.EditorState^create). Note\n//   that `instance` is a half-initialized state instance, and will\n//   not have values for plugin fields initialized after this one.\n//\n//   apply:: (tr: Transaction, value: T, oldState: EditorState, newState: EditorState) → T\n//   Apply the given transaction to this state field, producing a new\n//   field value. Note that the `newState` argument is again a partially\n//   constructed state does not yet contain the state from plugins\n//   coming after this one.\n//\n//   toJSON:: ?(value: T) → *\n//   Convert this field to JSON. Optional, can be left off to disable\n//   JSON serialization for the field.\n//\n//   fromJSON:: ?(config: Object, value: *, state: EditorState) → T\n//   Deserialize the JSON representation of this field. Note that the\n//   `state` argument is again a half-initialized state.\n\nconst keys = Object.create(null)\n\nfunction createKey(name) {\n  if (name in keys) return name + \"$\" + ++keys[name]\n  keys[name] = 0\n  return name + \"$\"\n}\n\n// ::- A key is used to [tag](#state.PluginSpec.key)\n// plugins in a way that makes it possible to find them, given an\n// editor state. Assigning a key does mean only one plugin of that\n// type can be active in a state.\nexport class PluginKey {\n  // :: (?string)\n  // Create a plugin key.\n  constructor(name = \"key\") { this.key = createKey(name) }\n\n  // :: (EditorState) → ?Plugin\n  // Get the active plugin with this key, if any, from an editor\n  // state.\n  get(state) { return state.config.pluginsByKey[this.key] }\n\n  // :: (EditorState) → ?any\n  // Get the plugin's state from an editor state.\n  getState(state) { return state[this.key] }\n}\n","import {joinPoint, canJoin, findWrapping, liftTarget, canSplit, ReplaceAroundStep, replaceStep} from \"prosemirror-transform\"\nimport {Slice, Fragment} from \"prosemirror-model\"\nimport {Selection, TextSelection, NodeSelection, AllSelection} from \"prosemirror-state\"\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Delete the selection, if there is one.\nexport function deleteSelection(state, dispatch) {\n  if (state.selection.empty) return false\n  if (dispatch) dispatch(state.tr.deleteSelection().scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and at the start of a textblock, try to\n// reduce the distance between that block and the one before it—if\n// there's a block directly before it that can be joined, join them.\n// If not, try to move the selected block closer to the next one in\n// the document structure by lifting it out of its parent or moving it\n// into a parent of the previous block. Will use the view for accurate\n// (bidi-aware) start-of-textblock detection if given.\nexport function joinBackward(state, dispatch, view) {\n  let {$cursor} = state.selection\n  if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state)\n                        : $cursor.parentOffset > 0))\n    return false\n\n  let $cut = findCutBefore($cursor)\n\n  // If there is no node before this, try to lift\n  if (!$cut) {\n    let range = $cursor.blockRange(), target = range && liftTarget(range)\n    if (target == null) return false\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n    return true\n  }\n\n  let before = $cut.nodeBefore\n  // Apply the joining algorithm\n  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))\n    return true\n\n  // If the node below has no content and the node above is\n  // selectable, delete the node below and select the one above.\n  if ($cursor.parent.content.size == 0 &&\n      (textblockAt(before, \"end\") || NodeSelection.isSelectable(before))) {\n    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty)\n    if (delStep.slice.size < delStep.to - delStep.from) {\n      if (dispatch) {\n        let tr = state.tr.step(delStep)\n        tr.setSelection(textblockAt(before, \"end\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1)\n                        : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize))\n        dispatch(tr.scrollIntoView())\n      }\n      return true\n    }\n  }\n\n  // If the node before is an atom, delete it\n  if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView())\n    return true\n  }\n\n  return false\n}\n\nfunction textblockAt(node, side, only) {\n  for (; node; node = (side == \"start\" ? node.firstChild : node.lastChild)) {\n    if (node.isTextblock) return true\n    if (only && node.childCount != 1) return false\n  }\n  return false\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// When the selection is empty and at the start of a textblock, select\n// the node before that textblock, if possible. This is intended to be\n// bound to keys like backspace, after\n// [`joinBackward`](#commands.joinBackward) or other deleting\n// commands, as a fall-back behavior when the schema doesn't allow\n// deletion at the selected point.\nexport function selectNodeBackward(state, dispatch, view) {\n  let {$head, empty} = state.selection, $cut = $head\n  if (!empty) return false\n\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0) return false\n    $cut = findCutBefore($head)\n  }\n  let node = $cut && $cut.nodeBefore\n  if (!node || !NodeSelection.isSelectable(node)) return false\n  if (dispatch)\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView())\n  return true\n}\n\nfunction findCutBefore($pos) {\n  if (!$pos.parent.type.spec.isolating) for (let i = $pos.depth - 1; i >= 0; i--) {\n    if ($pos.index(i) > 0) return $pos.doc.resolve($pos.before(i + 1))\n    if ($pos.node(i).type.spec.isolating) break\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and the cursor is at the end of a\n// textblock, try to reduce or remove the boundary between that block\n// and the one after it, either by joining them or by moving the other\n// block closer to this one in the tree structure. Will use the view\n// for accurate start-of-textblock detection if given.\nexport function joinForward(state, dispatch, view) {\n  let {$cursor} = state.selection\n  if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state)\n                        : $cursor.parentOffset < $cursor.parent.content.size))\n    return false\n\n  let $cut = findCutAfter($cursor)\n\n  // If there is no node after this, there's nothing to do\n  if (!$cut) return false\n\n  let after = $cut.nodeAfter\n  // Try the joining algorithm\n  if (deleteBarrier(state, $cut, dispatch)) return true\n\n  // If the node above has no content and the node below is\n  // selectable, delete the node above and select the one below.\n  if ($cursor.parent.content.size == 0 &&\n      (textblockAt(after, \"start\") || NodeSelection.isSelectable(after))) {\n    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty)\n    if (delStep.slice.size < delStep.to - delStep.from) {\n      if (dispatch) {\n        let tr = state.tr.step(delStep)\n        tr.setSelection(textblockAt(after, \"start\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1)\n                        : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)))\n        dispatch(tr.scrollIntoView())\n      }\n      return true\n    }\n  }\n\n  // If the next node is an atom, delete it\n  if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView())\n    return true\n  }\n\n  return false\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// When the selection is empty and at the end of a textblock, select\n// the node coming after that textblock, if possible. This is intended\n// to be bound to keys like delete, after\n// [`joinForward`](#commands.joinForward) and similar deleting\n// commands, to provide a fall-back behavior when the schema doesn't\n// allow deletion at the selected point.\nexport function selectNodeForward(state, dispatch, view) {\n  let {$head, empty} = state.selection, $cut = $head\n  if (!empty) return false\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size)\n      return false\n    $cut = findCutAfter($head)\n  }\n  let node = $cut && $cut.nodeAfter\n  if (!node || !NodeSelection.isSelectable(node)) return false\n  if (dispatch)\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView())\n  return true\n}\n\nfunction findCutAfter($pos) {\n  if (!$pos.parent.type.spec.isolating) for (let i = $pos.depth - 1; i >= 0; i--) {\n    let parent = $pos.node(i)\n    if ($pos.index(i) + 1 < parent.childCount) return $pos.doc.resolve($pos.after(i + 1))\n    if (parent.type.spec.isolating) break\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block or, if there is a text selection, the\n// closest ancestor block of the selection that can be joined, with\n// the sibling above it.\nexport function joinUp(state, dispatch) {\n  let sel = state.selection, nodeSel = sel instanceof NodeSelection, point\n  if (nodeSel) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.from)) return false\n    point = sel.from\n  } else {\n    point = joinPoint(state.doc, sel.from, -1)\n    if (point == null) return false\n  }\n  if (dispatch) {\n    let tr = state.tr.join(point)\n    if (nodeSel) tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block, or the closest ancestor of the selection\n// that can be joined, with the sibling after it.\nexport function joinDown(state, dispatch) {\n  let sel = state.selection, point\n  if (sel instanceof NodeSelection) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.to)) return false\n    point = sel.to\n  } else {\n    point = joinPoint(state.doc, sel.to, 1)\n    if (point == null) return false\n  }\n  if (dispatch)\n    dispatch(state.tr.join(point).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Lift the selected block, or the closest ancestor block of the\n// selection that can be lifted, out of its parent node.\nexport function lift(state, dispatch) {\n  let {$from, $to} = state.selection\n  let range = $from.blockRange($to), target = range && liftTarget(range)\n  if (target == null) return false\n  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If the selection is in a node whose type has a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, replace the\n// selection with a newline character.\nexport function newlineInCode(state, dispatch) {\n  let {$head, $anchor} = state.selection\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false\n  if (dispatch) dispatch(state.tr.insertText(\"\\n\").scrollIntoView())\n  return true\n}\n\nfunction defaultBlockAt(match) {\n  for (let i = 0; i < match.edgeCount; i++) {\n    let {type} = match.edge(i)\n    if (type.isTextblock && !type.hasRequiredAttrs()) return type\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// When the selection is in a node with a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, create a\n// default block after the code block, and move the cursor there.\nexport function exitCode(state, dispatch) {\n  let {$head, $anchor} = state.selection\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false\n  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after))\n  if (!above.canReplaceWith(after, after, type)) return false\n  if (dispatch) {\n    let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill())\n    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If a block node is selected, create an empty paragraph before (if\n// it is its parent's first child) or after it.\nexport function createParagraphNear(state, dispatch) {\n  let sel = state.selection, {$from, $to} = sel\n  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) return false\n  let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()))\n  if (!type || !type.isTextblock) return false\n  if (dispatch) {\n    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos\n    let tr = state.tr.insert(side, type.createAndFill())\n    tr.setSelection(TextSelection.create(tr.doc, side + 1))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// If the cursor is in an empty textblock that can be lifted, lift the\n// block.\nexport function liftEmptyBlock(state, dispatch) {\n  let {$cursor} = state.selection\n  if (!$cursor || $cursor.parent.content.size) return false\n  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n    let before = $cursor.before()\n    if (canSplit(state.doc, before)) {\n      if (dispatch) dispatch(state.tr.split(before).scrollIntoView())\n      return true\n    }\n  }\n  let range = $cursor.blockRange(), target = range && liftTarget(range)\n  if (target == null) return false\n  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Split the parent block of the selection. If the selection is a text\n// selection, also delete its content.\nexport function splitBlock(state, dispatch) {\n  let {$from, $to} = state.selection\n  if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(state.doc, $from.pos)) return false\n    if (dispatch) dispatch(state.tr.split($from.pos).scrollIntoView())\n    return true\n  }\n\n  if (!$from.parent.isBlock) return false\n\n  if (dispatch) {\n    let atEnd = $to.parentOffset == $to.parent.content.size\n    let tr = state.tr\n    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection) tr.deleteSelection()\n    let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)))\n    let types = atEnd && deflt ? [{type: deflt}] : null\n    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types)\n    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{type: deflt}])) {\n      types = [{type: deflt}]\n      can = true\n    }\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types)\n      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {\n        let first = tr.mapping.map($from.before()), $first = tr.doc.resolve(first)\n        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt))\n          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt)\n      }\n    }\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Acts like [`splitBlock`](#commands.splitBlock), but without\n// resetting the set of active marks at the cursor.\nexport function splitBlockKeepMarks(state, dispatch) {\n  return splitBlock(state, dispatch && (tr => {\n    let marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks())\n    if (marks) tr.ensureMarks(marks)\n    dispatch(tr)\n  }))\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Move the selection to the node wrapping the current selection, if\n// any. (Will not select the document node.)\nexport function selectParentNode(state, dispatch) {\n  let {$from, to} = state.selection, pos\n  let same = $from.sharedDepth(to)\n  if (same == 0) return false\n  pos = $from.before(same)\n  if (dispatch) dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)))\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Select the whole document.\nexport function selectAll(state, dispatch) {\n  if (dispatch) dispatch(state.tr.setSelection(new AllSelection(state.doc)))\n  return true\n}\n\nfunction joinMaybeClear(state, $pos, dispatch) {\n  let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index()\n  if (!before || !after || !before.type.compatibleContent(after.type)) return false\n  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n    if (dispatch) dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView())\n    return true\n  }\n  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))\n    return false\n  if (dispatch)\n    dispatch(state.tr\n             .clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount))\n             .join($pos.pos)\n             .scrollIntoView())\n  return true\n}\n\nfunction deleteBarrier(state, $cut, dispatch) {\n  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match\n  if (before.type.spec.isolating || after.type.spec.isolating) return false\n  if (joinMaybeClear(state, $cut, dispatch)) return true\n\n  let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1)\n  if (canDelAfter &&\n      (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) &&\n      match.matchType(conn[0] || after.type).validEnd) {\n    if (dispatch) {\n      let end = $cut.pos + after.nodeSize, wrap = Fragment.empty\n      for (let i = conn.length - 1; i >= 0; i--)\n        wrap = Fragment.from(conn[i].create(null, wrap))\n      wrap = Fragment.from(before.copy(wrap))\n      let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap, 1, 0), conn.length, true))\n      let joinAt = end + 2 * conn.length\n      if (canJoin(tr.doc, joinAt)) tr.join(joinAt)\n      dispatch(tr.scrollIntoView())\n    }\n    return true\n  }\n\n  let selAfter = Selection.findFrom($cut, 1)\n  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range)\n  if (target != null && target >= $cut.depth) {\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n    return true\n  }\n\n  if (canDelAfter && textblockAt(after, \"start\", true) && textblockAt(before, \"end\")) {\n    let at = before, wrap = []\n    for (;;) {\n      wrap.push(at)\n      if (at.isTextblock) break\n      at = at.lastChild\n    }\n    let afterText = after, afterDepth = 1\n    for (; !afterText.isTextblock; afterText = afterText.firstChild) afterDepth++\n    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {\n      if (dispatch) {\n        let end = Fragment.empty\n        for (let i = wrap.length - 1; i >= 0; i--) end = Fragment.from(wrap[i].copy(end))\n        let tr = state.tr.step(new ReplaceAroundStep($cut.pos - wrap.length, $cut.pos + after.nodeSize,\n                                                     $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth,\n                                                     new Slice(end, wrap.length, 0), 0, true))\n        dispatch(tr.scrollIntoView())\n      }\n      return true\n    }\n  }\n\n  return false\n}\n\nfunction selectTextblockSide(side) {\n  return function(state, dispatch) {\n    let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to\n    let depth = $pos.depth\n    while ($pos.node(depth).isInline) {\n      if (!depth) return false\n      depth--\n    }\n    if (!$pos.node(depth).isTextblock) return false\n    if (dispatch)\n      dispatch(state.tr.setSelection(TextSelection.create(\n        state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))))\n    return true\n  }\n}\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Moves the cursor to the start of current text block.\nexport const selectTextblockStart = selectTextblockSide(-1)\n\n// :: (EditorState, ?(tr: Transaction)) → bool\n// Moves the cursor to the end of current text block.\nexport const selectTextblockEnd = selectTextblockSide(1)\n\n// Parameterized commands\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Wrap the selection in a node of the given type with the given\n// attributes.\nexport function wrapIn(nodeType, attrs) {\n  return function(state, dispatch) {\n    let {$from, $to} = state.selection\n    let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs)\n    if (!wrapping) return false\n    if (dispatch) dispatch(state.tr.wrap(range, wrapping).scrollIntoView())\n    return true\n  }\n}\n\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command that tries to set the selected textblocks to the\n// given node type with the given attributes.\nexport function setBlockType(nodeType, attrs) {\n  return function(state, dispatch) {\n    let {from, to} = state.selection\n    let applicable = false\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (applicable) return false\n      if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) return\n      if (node.type == nodeType) {\n        applicable = true\n      } else {\n        let $pos = state.doc.resolve(pos), index = $pos.index()\n        applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType)\n      }\n    })\n    if (!applicable) return false\n    if (dispatch) dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView())\n    return true\n  }\n}\n\nfunction markApplies(doc, ranges, type) {\n  for (let i = 0; i < ranges.length; i++) {\n    let {$from, $to} = ranges[i]\n    let can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false\n    doc.nodesBetween($from.pos, $to.pos, node => {\n      if (can) return false\n      can = node.inlineContent && node.type.allowsMarkType(type)\n    })\n    if (can) return true\n  }\n  return false\n}\n\n// :: (MarkType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command function that toggles the given mark with the\n// given attributes. Will return `false` when the current selection\n// doesn't support that mark. This will remove the mark if any marks\n// of that type exist in the selection, or add it otherwise. If the\n// selection is empty, this applies to the [stored\n// marks](#state.EditorState.storedMarks) instead of a range of the\n// document.\nexport function toggleMark(markType, attrs) {\n  return function(state, dispatch) {\n    let {empty, $cursor, ranges} = state.selection\n    if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType)) return false\n    if (dispatch) {\n      if ($cursor) {\n        if (markType.isInSet(state.storedMarks || $cursor.marks()))\n          dispatch(state.tr.removeStoredMark(markType))\n        else\n          dispatch(state.tr.addStoredMark(markType.create(attrs)))\n      } else {\n        let has = false, tr = state.tr\n        for (let i = 0; !has && i < ranges.length; i++) {\n          let {$from, $to} = ranges[i]\n          has = state.doc.rangeHasMark($from.pos, $to.pos, markType)\n        }\n        for (let i = 0; i < ranges.length; i++) {\n          let {$from, $to} = ranges[i]\n          if (has) {\n            tr.removeMark($from.pos, $to.pos, markType)\n          } else {\n            let from = $from.pos, to = $to.pos, start = $from.nodeAfter, end = $to.nodeBefore\n            let spaceStart = start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0\n            let spaceEnd = end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0\n            if (from + spaceStart < to) { from += spaceStart; to -= spaceEnd }\n            tr.addMark(from, to, markType.create(attrs))\n          }\n        }\n        dispatch(tr.scrollIntoView())\n      }\n    }\n    return true\n  }\n}\n\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n  return tr => {\n    if (!tr.isGeneric) return dispatch(tr)\n\n    let ranges = []\n    for (let i = 0; i < tr.mapping.maps.length; i++) {\n      let map = tr.mapping.maps[i]\n      for (let j = 0; j < ranges.length; j++)\n        ranges[j] = map.map(ranges[j])\n      map.forEach((_s, _e, from, to) => ranges.push(from, to))\n    }\n\n    // Figure out which joinable points exist inside those ranges,\n    // by checking all node boundaries in their parent nodes.\n    let joinable = []\n    for (let i = 0; i < ranges.length; i += 2) {\n      let from = ranges[i], to = ranges[i + 1]\n      let $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth)\n      for (let index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n        let after = parent.maybeChild(index)\n        if (!after) break\n        if (index && joinable.indexOf(pos) == -1) {\n          let before = parent.child(index - 1)\n          if (before.type == after.type && isJoinable(before, after))\n            joinable.push(pos)\n        }\n        pos += after.nodeSize\n      }\n    }\n    // Join the joinable points\n    joinable.sort((a, b) => a - b)\n    for (let i = joinable.length - 1; i >= 0; i--) {\n      if (canJoin(tr.doc, joinable[i])) tr.join(joinable[i])\n    }\n    dispatch(tr)\n  }\n}\n\n// :: ((state: EditorState, ?(tr: Transaction)) → bool, union<(before: Node, after: Node) → bool, [string]>) → (state: EditorState, ?(tr: Transaction)) → bool\n// Wrap a command so that, when it produces a transform that causes\n// two joinable nodes to end up next to each other, those are joined.\n// Nodes are considered joinable when they are of the same type and\n// when the `isJoinable` predicate returns true for them or, if an\n// array of strings was passed, if their node type name is in that\n// array.\nexport function autoJoin(command, isJoinable) {\n  if (Array.isArray(isJoinable)) {\n    let types = isJoinable\n    isJoinable = node => types.indexOf(node.type.name) > -1\n  }\n  return (state, dispatch, view) => command(state, dispatch && wrapDispatchForJoin(dispatch, isJoinable), view)\n}\n\n// :: (...[(EditorState, ?(tr: Transaction), ?EditorView) → bool]) → (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// Combine a number of command functions into a single function (which\n// calls them one by one until one returns true).\nexport function chainCommands(...commands) {\n  return function(state, dispatch, view) {\n    for (let i = 0; i < commands.length; i++)\n      if (commands[i](state, dispatch, view)) return true\n    return false\n  }\n}\n\nlet backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward)\nlet del = chainCommands(deleteSelection, joinForward, selectNodeForward)\n\n// :: Object\n// A basic keymap containing bindings not specific to any schema.\n// Binds the following keys (when multiple commands are listed, they\n// are chained with [`chainCommands`](#commands.chainCommands)):\n//\n// * **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n// * **Mod-Enter** to `exitCode`\n// * **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n// * **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-a** to `selectAll`\nexport let pcBaseKeymap = {\n  \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n  \"Mod-Enter\": exitCode,\n  \"Backspace\": backspace,\n  \"Mod-Backspace\": backspace,\n  \"Shift-Backspace\": backspace,\n  \"Delete\": del,\n  \"Mod-Delete\": del,\n  \"Mod-a\": selectAll\n}\n\n// :: Object\n// A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n// **Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n// **Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\n// Ctrl-Delete.\nexport let macBaseKeymap = {\n  \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n  \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n  \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n  \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Ctrl-a\": selectTextblockStart,\n  \"Ctrl-e\": selectTextblockEnd\n}\nfor (let key in pcBaseKeymap) macBaseKeymap[key] = pcBaseKeymap[key]\n\npcBaseKeymap.Home = selectTextblockStart\npcBaseKeymap.End = selectTextblockEnd\n\n// declare global: os, navigator\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)\n          : typeof os != \"undefined\" ? os.platform() == \"darwin\" : false\n\n// :: Object\n// Depending on the detected platform, this will hold\n// [`pcBasekeymap`](#commands.pcBaseKeymap) or\n// [`macBaseKeymap`](#commands.macBaseKeymap).\nexport let baseKeymap = mac ? macBaseKeymap : pcBaseKeymap\n","import {Plugin} from \"prosemirror-state\"\n\n// ::- Input rules are regular expressions describing a piece of text\n// that, when typed, causes something to happen. This might be\n// changing two dashes into an emdash, wrapping a paragraph starting\n// with `\"> \"` into a blockquote, or something entirely different.\nexport class InputRule {\n  // :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number) → ?Transaction>)\n  // Create an input rule. The rule applies when the user typed\n  // something and the text directly in front of the cursor matches\n  // `match`, which should end with `$`.\n  //\n  // The `handler` can be a string, in which case the matched text, or\n  // the first matched group in the regexp, is replaced by that\n  // string.\n  //\n  // Or a it can be a function, which will be called with the match\n  // array produced by\n  // [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),\n  // as well as the start and end of the matched range, and which can\n  // return a [transaction](#state.Transaction) that describes the\n  // rule's effect, or null to indicate the input was not handled.\n  constructor(match, handler) {\n    this.match = match\n    this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler\n  }\n}\n\nfunction stringHandler(string) {\n  return function(state, match, start, end) {\n    let insert = string\n    if (match[1]) {\n      let offset = match[0].lastIndexOf(match[1])\n      insert += match[0].slice(offset + match[1].length)\n      start += offset\n      let cutOff = start - end\n      if (cutOff > 0) {\n        insert = match[0].slice(offset - cutOff, offset) + insert\n        start = end\n      }\n    }\n    return state.tr.insertText(insert, start, end)\n  }\n}\n\nconst MAX_MATCH = 500\n\n// :: (config: {rules: [InputRule]}) → Plugin\n// Create an input rules plugin. When enabled, it will cause text\n// input that matches any of the given rules to trigger the rule's\n// action.\nexport function inputRules({rules}) {\n  let plugin = new Plugin({\n    state: {\n      init() { return null },\n      apply(tr, prev) {\n        let stored = tr.getMeta(this)\n        if (stored) return stored\n        return tr.selectionSet || tr.docChanged ? null : prev\n      }\n    },\n\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run(view, from, to, text, rules, plugin)\n      },\n      handleDOMEvents: {\n        compositionend: (view) => {\n          setTimeout(() => {\n            let {$cursor} = view.state.selection\n            if ($cursor) run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin)\n          })\n        }\n      }\n    },\n\n    isInputRules: true\n  })\n  return plugin\n}\n\nfunction run(view, from, to, text, rules, plugin) {\n  if (view.composing) return false\n  let state = view.state, $from = state.doc.resolve(from)\n  if ($from.parent.type.spec.code) return false\n  let textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset,\n                                            null, \"\\ufffc\") + text\n  for (let i = 0; i < rules.length; i++) {\n    let match = rules[i].match.exec(textBefore)\n    let tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to)\n    if (!tr) continue\n    view.dispatch(tr.setMeta(plugin, {transform: tr, from, to, text}))\n    return true\n  }\n  return false\n}\n\n// :: (EditorState, ?(Transaction)) → bool\n// This is a command that will undo an input rule, if applying such a\n// rule was the last thing that the user did.\nexport function undoInputRule(state, dispatch) {\n  let plugins = state.plugins\n  for (let i = 0; i < plugins.length; i++) {\n    let plugin = plugins[i], undoable\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        let tr = state.tr, toUndo = undoable.transform\n        for (let j = toUndo.steps.length - 1; j >= 0; j--)\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]))\n        if (undoable.text) {\n          let marks = tr.doc.resolve(undoable.from).marks()\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks))\n        } else {\n          tr.delete(undoable.from, undoable.to)\n        }\n        dispatch(tr)\n      }\n      return true\n    }\n  }\n  return false\n}\n","import {InputRule} from \"./inputrules\"\n\n// :: InputRule Converts double dashes to an emdash.\nexport const emDash = new InputRule(/--$/, \"—\")\n// :: InputRule Converts three dots to an ellipsis character.\nexport const ellipsis = new InputRule(/\\.\\.\\.$/, \"…\")\n// :: InputRule “Smart” opening double quotes.\nexport const openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"“\")\n// :: InputRule “Smart” closing double quotes.\nexport const closeDoubleQuote = new InputRule(/\"$/, \"”\")\n// :: InputRule “Smart” opening single quotes.\nexport const openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"‘\")\n// :: InputRule “Smart” closing single quotes.\nexport const closeSingleQuote = new InputRule(/'$/, \"’\")\n\n// :: [InputRule] Smart-quote related input rules.\nexport const smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote]\n","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  setPrototypeOf(subClass, superClass);\n}","import Modal from \"flarum/components/Modal\";\r\nimport Button from 'flarum/components/Button';\r\nimport Stream from 'flarum/common/utils/Stream';\r\n\r\nexport default class DefaultRefModal extends Modal {\r\n  oninit(vnode) {\r\n    super.oninit(vnode);\r\n\r\n    this.value = app.composer.fields.content() || '';\r\n    // this.allReferences = this.value.match(/\\[reference\\ id=[\\w]*\\][\\w\\ \\(\\)\\[\\]\\.\\,\\/\\\\\\-_\\+;:\"'?&]*\\[\\/reference\\]/gm);\r\n    this.allReferences = this.value.match(/\\[reference\\ id=[\\w]* type=[\\w]*\\].*\\[\\/reference\\]/gm);\r\n    this.referenceId = this.allReferences?.length || 0;\r\n\r\n    // console.log(this.value);\r\n    // console.log(this.allReferences);\r\n    // console.log(this.referenceId);\r\n    this.fields = {\r\n      title: Stream(''),\r\n      link: Stream(''),\r\n    };\r\n  }\r\n\r\n  className() {\r\n    return \"\";\r\n  }\r\n\r\n  title() {\r\n    return app.translator.trans('flarum-references.forum.modal.ref_default_modal');\r\n  }\r\n\r\n  content() {\r\n    // console.log(this.$('input[required]')[0]?.validity.valid);\r\n    // console.log(app.composer.editor.attrs.menuState.editorView.dom.outerText);\r\n    // console.log(app.composer.editor.attrs.menuState.editorView.dom.outerText.length);\r\n    return [\r\n      m('.Modal-body',\r\n        m('Form.Form--left',\r\n        m('.Form-group',\r\n          m('label', app.translator.trans('flarum-references.forum.modal.ref_title_label')),\r\n          m('input.FormControl', {\r\n            type: \"text\",\r\n            value: this.fields.title(),\r\n            placeholder: \"ex. Cultura în Evul Mediu\",\r\n            required: true,\r\n            oninput: (e) => {\r\n              this.fields.title(e.target.value);\r\n              this.removeRedStyle();\r\n            }\r\n          },\r\n          )\r\n        ),\r\n        m('.Form-group',\r\n          m('label', app.translator.trans('flarum-references.forum.modal.ref_link_label')),\r\n          m('input.FormControl', {\r\n            type: \"url\",\r\n            placeholder: \"ex. http://example.com\",\r\n            value: this.fields.link(),\r\n            oninput: (e) => {\r\n              this.fields.link(e.target.value);\r\n              this.removeRedStyle();\r\n            }\r\n          },\r\n          )\r\n        ),\r\n          Button.component(\r\n            {\r\n              className: \"Button Button--primary\",\r\n              onclick: () => this.addReference(),\r\n            },\r\n            \"Adaugare\"\r\n          ),\r\n        )\r\n      )\r\n    ];\r\n  }\r\n\r\n  removeRedStyle() {\r\n    const requiredFields = this.$('input');\r\n\r\n    for (let k = 0; k < requiredFields.length; k++) {\r\n      if (requiredFields[k].validity.valid) {\r\n        requiredFields[k].removeAttribute(\"style\");\r\n      }\r\n    }\r\n  }\r\n\r\n  areSetRequiredFields() {\r\n    const requiredFields = this.$('input');\r\n    let i = 0;\r\n    // console.log(requiredFields);\r\n    \r\n    for (let k = 0; k < requiredFields.length; k++) {\r\n      if (!requiredFields[k].validity.valid) {\r\n        requiredFields[k].style.setProperty('border-color', 'red', 'important');\r\n        i++;\r\n      }\r\n    }\r\n\r\n    if (i == 0) return true;\r\n\r\n    return false;\r\n  }\r\n\r\n  addReference() {\r\n    if (!this.areSetRequiredFields()) return;\r\n\r\n    let date = new Date();\r\n\r\n    if (flarum.extensions['askvortsov-rich-text']) { // implements for askvortsov-rich-text editor\r\n      app.composer.editor.insertAtCursor(\"[ref id=ref\" + ++this.referenceId + \"]\" + this.referenceId + \"[/ref]\");\r\n\r\n      const position = app.composer.editor.getSelectionRange();\r\n      \r\n      if (this.referenceId == 1) {\r\n        app.composer.editor.moveCursorTo(app.composer.editor.attrs.menuState.editorView.dom.outerText.length + 1);\r\n        app.composer.editor.setEnter();\r\n        app.composer.editor.insertAtCursor(\"Referinte:\");\r\n        app.composer.editor.setEnter();\r\n      } else {\r\n        app.composer.editor.moveCursorTo(app.composer.editor.attrs.menuState.editorView.dom.outerText.length + 1);\r\n        app.composer.editor.setEnter();\r\n      }\r\n\r\n      app.composer.editor.insertAtCursor(\r\n        this.referenceId +\r\n        \". [reference id=ref\" + this.referenceId + \" type=default] \" +\r\n        this.fields.title() +\r\n        \". \" +\r\n        \"[citat la \" +\r\n        date.getDate() + \r\n        \".\" + (date.getMonth() + 1) +\r\n        \".\" + date.getFullYear() +\r\n        \"] \" +\r\n        this.fields.link() +\r\n        ((this.fields.link().length === 0) ? \"[/reference]\" : \" [/reference]\")\r\n      );\r\n\r\n      app.composer.editor.setSelectionRange(position[0], position[1]);\r\n      app.composer.editor.setEnter();\r\n      app.composer.editor.delete();\r\n\r\n    } else { // implements for flarum-markdown editor\r\n      console.log(app.composer.editor.el.value);\r\n      console.log(app.composer.fields.content());\r\n      app.composer.editor.insertAtCursor(\"[ref id=ref\" + ++this.referenceId + \"]\" + this.referenceId + \"[/ref]\");\r\n\r\n      const position = app.composer.editor.getSelectionRange();\r\n\r\n      if (this.referenceId == 1) {\r\n        app.composer.editor.moveCursorTo(app.composer.editor.el.value.length + 1);\r\n        // app.composer.editor.setEnter();\r\n        app.composer.editor.insertAtCursor(\"\\n\\nReferinte:\\n\");\r\n        // app.composer.editor.setEnter();\r\n      } else {\r\n        app.composer.editor.moveCursorTo(app.composer.editor.el.value.length + 1);\r\n        app.composer.editor.insertAtCursor(\"\\n\");\r\n        // app.composer.editor.setEnter();\r\n      }\r\n\r\n      app.composer.editor.insertAtCursor(\r\n        \"\\n\" +\r\n        this.referenceId +\r\n        \"\\\\. [reference id=ref\" + this.referenceId + \" type=default] \" +\r\n        this.fields.title() +\r\n        \". \" +\r\n        \"[citat la \" +\r\n        date.getDate() + \r\n        \".\" + (date.getMonth() + 1) +\r\n        \".\" + date.getFullYear() +\r\n        \"] \" +\r\n        this.fields.link() +\r\n        ((this.fields.link().length === 0) ? \"[/reference]\" : \" [/reference]\")\r\n      );\r\n\r\n      app.composer.editor.setSelectionRange(position[0], position[1]);\r\n\r\n      // console.log(\"non rich-text\");\r\n      // app.composer.editor.moveCursorTo(app.composer.fields.content().length + 1);\r\n    }\r\n\r\n    // console.log(this.fields.link().length);\r\n    app.modal.close();\r\n  }\r\n}","import Modal from \"flarum/components/Modal\";\r\nimport Button from 'flarum/components/Button';\r\nimport Stream from 'flarum/common/utils/Stream';\r\n\r\nexport default class SiteRefModal extends Modal {\r\n  oninit(vnode) {\r\n    super.oninit(vnode);\r\n\r\n    this.value = app.composer.fields.content() || '';\r\n    // this.allReferences = this.value.match(/\\[reference\\ id=[\\w]*\\][\\w\\ \\(\\)\\[\\]\\.\\,\\/\\\\\\-_\\+;:\"'?&]*\\[\\/reference\\]/gm);\r\n    this.allReferences = this.value.match(/\\[reference\\ id=[\\w]* type=[\\w]*\\].*\\[\\/reference\\]/gm);\r\n    this.referenceId = this.allReferences?.length || 0;\r\n\r\n    this.fields = {\r\n      title: Stream(''),\r\n      link: Stream(''),\r\n      author: Stream(''),\r\n      createAt: Stream(''),\r\n      siteName: Stream(''),\r\n    };\r\n  }\r\n\r\n  className() {\r\n    return \"\";\r\n  }\r\n\r\n  title() {\r\n    return app.translator.trans('flarum-references.forum.modal.ref_site_modal');\r\n  }\r\n\r\n  content() {\r\n    return [\r\n      m('.Modal-body',\r\n        m('Form.Form--left',\r\n         m('span.description', app.translator.trans('flarum-references.forum.modal.ref_site_description')),\r\n          m('.Form-group',\r\n            m('label', app.translator.trans('flarum-references.forum.modal.ref_title_label')),\r\n            m('input.FormControl', {\r\n              type: \"text\",\r\n              value: this.fields.title(),\r\n              placeholder: \"ex. Cultura în Evul Mediu\",\r\n              required: true,\r\n              oninput: (e) => {\r\n                this.fields.title(e.target.value);\r\n                this.removeRedStyle();\r\n              }\r\n            },\r\n            )\r\n          ),\r\n          m('.Form-group',\r\n            m('label', app.translator.trans('flarum-references.forum.modal.ref_link_label')),\r\n            m('input.FormControl', {\r\n              type: \"url\",\r\n              value: this.fields.link(),\r\n              placeholder: \"ex. http://example.com\",\r\n              required: true,\r\n              oninput: (e) => {\r\n                this.fields.link(e.target.value);\r\n                this.fields.siteName(e.target.value?.split('//')[1]?.split('/')[0] || \"\");\r\n                this.removeRedStyle();\r\n              },\r\n            },\r\n            )\r\n          ),\r\n          m('.Form-group',\r\n            m('label', app.translator.trans('flarum-references.forum.modal.ref_author_label')),\r\n            m('input.FormControl', {\r\n              type: \"text\",\r\n              placeholder: \"ex. Shakespeare\",\r\n              bidi: this.fields.author,\r\n            },\r\n            )\r\n          ),\r\n          m('.Form-group',\r\n            m('label', app.translator.trans('flarum-references.forum.modal.ref_createat_label')),\r\n            m('input.FormControl', {\r\n              type: \"text\",\r\n              placeholder: \"ex. 01.01.1970\",\r\n              pattern: \"^(?:(?:31(\\\\.)(?:0?[13578]|1[02]))\\\\1|(?:(?:29|30)(\\\\.)(?:0?[1,3-9]|1[0-2])\\\\2))(?:(?:1[6-9]|[2-9]\\\\d)?\\\\d{2})$|^(?:29(\\\\.)0?2\\\\3(?:(?:(?:1[6-9]|[2-9]\\\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:0?[1-9]|1\\\\d|2[0-8])(\\\\.)(?:(?:0?[1-9])|(?:1[0-2]))\\\\4(?:(?:1[6-9]|[2-9]\\\\d)?\\\\d{2})$\",\r\n              value: this.fields.createAt(),\r\n              oninput: (e) => {\r\n                this.fields.createAt(e.target.value);\r\n                this.removeRedStyle();\r\n              }\r\n            },\r\n            )\r\n          ),\r\n          m('.Form-group',\r\n            m('label', app.translator.trans('flarum-references.forum.modal.ref_sourcename_label')),\r\n            m('input.FormControl', {\r\n              type: \"text\",\r\n              value: this.fields.siteName(),\r\n              placeholder: \"ex. example.com\",\r\n              required: true,\r\n              oninput: (e) => {\r\n                this.fields.siteName(e.target.value);\r\n                this.removeRedStyle();\r\n              },\r\n            },\r\n            )\r\n          ),\r\n          Button.component(\r\n            {\r\n              className: \"Button Button--primary\",\r\n              onclick: () => this.addReference(),\r\n            },\r\n            \"Adaugare\"\r\n          ),\r\n        )\r\n      )\r\n    ];\r\n  }\r\n  \r\n  removeRedStyle() {\r\n    const requiredFields = this.$('input');\r\n\r\n    for (let k = 0; k < requiredFields.length; k++) {\r\n      if (requiredFields[k].validity.valid) {\r\n        requiredFields[k].removeAttribute(\"style\");\r\n      }\r\n    }\r\n  }\r\n\r\n  areSetRequiredFields() {\r\n    const requiredFields = this.$('input');\r\n    let i = 0;\r\n    \r\n    for (let k = 0; k < requiredFields.length; k++) {\r\n      if (!requiredFields[k].validity.valid) {\r\n        requiredFields[k].style.setProperty('border-color', 'red', 'important');\r\n        i++;\r\n      }\r\n    }\r\n\r\n    if (i == 0) return true;\r\n\r\n    return false;\r\n  }\r\n\r\n  addReference() {\r\n    if (!this.areSetRequiredFields()) return;\r\n\r\n    let date = new Date();\r\n\r\n    if (flarum.extensions['askvortsov-rich-text']) { // implements for askvortsov-rich-text editor\r\n      app.composer.editor.insertAtCursor(\"[ref id=ref\" + ++this.referenceId + \"]\" + this.referenceId + \"[/ref]\");\r\n\r\n      const position = app.composer.editor.getSelectionRange();\r\n      \r\n      if (this.referenceId == 1) {\r\n        app.composer.editor.moveCursorTo(app.composer.editor.attrs.menuState.editorView.dom.outerText.length + 1);\r\n        app.composer.editor.setEnter();\r\n        app.composer.editor.insertAtCursor(\"Referinte:\");\r\n        app.composer.editor.setEnter();\r\n      } else {\r\n        app.composer.editor.moveCursorTo(app.composer.editor.attrs.menuState.editorView.dom.outerText.length + 1);\r\n        app.composer.editor.setEnter();\r\n      }\r\n\r\n      app.composer.editor.insertAtCursor(\r\n        this.referenceId +\r\n        \". [reference id=ref\" + this.referenceId + \" type=site] \" +\r\n        this.fields.author() +\r\n        ((this.fields.author().length === 0) ? \"\" : \". \") +\r\n        this.fields.title() +\r\n        \". \" +\r\n        this.fields.siteName() +\r\n        ((this.fields.createAt().length === 0) ? \". \" : \", \") +\r\n        this.fields.createAt() +\r\n        ((this.fields.createAt().length === 0) ? \"\" : \". \") +\r\n        \"[citat la \" +\r\n        date.getDate() + \r\n        \".\" + (date.getMonth() + 1) +\r\n        \".\" + date.getFullYear() +\r\n        \"] \" +\r\n        this.fields.link() +\r\n        \" [/reference]\"\r\n      );\r\n\r\n      app.composer.editor.setSelectionRange(position[0], position[1]);\r\n      app.composer.editor.setEnter();\r\n      app.composer.editor.delete();\r\n\r\n    } else { // implements for flarum-markdown editor\r\n      console.log(app.composer.editor.el.value);\r\n      console.log(app.composer.fields.content());\r\n      app.composer.editor.insertAtCursor(\"[ref id=ref\" + ++this.referenceId + \"]\" + this.referenceId + \"[/ref]\");\r\n\r\n      const position = app.composer.editor.getSelectionRange();\r\n\r\n      if (this.referenceId == 1) {\r\n        app.composer.editor.moveCursorTo(app.composer.editor.el.value.length + 1);\r\n        // app.composer.editor.setEnter();\r\n        app.composer.editor.insertAtCursor(\"\\n\\nReferinte:\\n\");\r\n        // app.composer.editor.setEnter();\r\n      } else {\r\n        app.composer.editor.moveCursorTo(app.composer.editor.el.value.length + 1);\r\n        app.composer.editor.insertAtCursor(\"\\n\");\r\n        // app.composer.editor.setEnter();\r\n      }\r\n\r\n      app.composer.editor.insertAtCursor(\r\n        \"\\n\" +\r\n        this.referenceId +\r\n        \"\\\\. [reference id=ref\" + this.referenceId + \" type=site] \" +\r\n        this.fields.author() +\r\n        ((this.fields.author().length === 0) ? \"\" : \". \") +\r\n        this.fields.title() +\r\n        \". \" +\r\n        this.fields.siteName() +\r\n        ((this.fields.createAt().length === 0) ? \". \" : \", \") +\r\n        this.fields.createAt() +\r\n        ((this.fields.createAt().length === 0) ? \"\" : \". \") +\r\n        \"[citat la \" +\r\n        date.getDate() + \r\n        \".\" + (date.getMonth() + 1) +\r\n        \".\" + date.getFullYear() +\r\n        \"] \" +\r\n        this.fields.link() +\r\n        \" [/reference]\"\r\n      );\r\n\r\n      app.composer.editor.setSelectionRange(position[0], position[1]);\r\n    }\r\n\r\n    app.modal.close();\r\n  }\r\n}","import Modal from \"flarum/components/Modal\";\r\nimport Button from 'flarum/components/Button';\r\nimport Stream from 'flarum/common/utils/Stream';\r\n\r\nexport default class BookRefModal extends Modal {\r\n  oninit(vnode) {\r\n    super.oninit(vnode);\r\n\r\n    this.value = app.composer.fields.content() || '';\r\n    // this.allReferences = this.value.match(/\\[reference\\ id=[\\w]*\\][\\w\\ \\(\\)\\[\\]\\.\\,\\/\\\\\\-_\\+;:\"'?&]*\\[\\/reference\\]/gm);\r\n    this.allReferences = this.value.match(/\\[reference\\ id=[\\w]* type=[\\w]*\\].*\\[\\/reference\\]/gm);\r\n    this.referenceId = this.allReferences?.length || 0;\r\n\r\n    this.fields = {\r\n      title: Stream(''),\r\n      link: Stream(''),\r\n      author: Stream(''),\r\n      year: Stream(''),\r\n      editura: Stream(''),\r\n    };\r\n  }\r\n\r\n  className() {\r\n    return \"\";\r\n  }\r\n\r\n  title() {\r\n    return app.translator.trans('flarum-references.forum.modal.ref_book_modal');\r\n  }\r\n\r\n  content() {\r\n    return [\r\n      m('.Modal-body',\r\n        m('Form.Form--left',\r\n        m('span.description', app.translator.trans('flarum-references.forum.modal.ref_book_description')),\r\n        m('.Form-group',\r\n          m('label', app.translator.trans('flarum-references.forum.modal.ref_link_label')),\r\n          m('input.FormControl', {\r\n            type: \"url\",\r\n            value: this.fields.link(),\r\n            placeholder: \"ex. http://example.com\",\r\n            oninput: (e) => {\r\n              this.fields.link(e.target.value);\r\n              this.removeRedStyle();\r\n            },\r\n          },\r\n          )\r\n        ),\r\n        m('.Form-group',\r\n          m('label', app.translator.trans('flarum-references.forum.modal.ref_author_label')),\r\n          m('input.FormControl', {\r\n            type: \"text\",\r\n            placeholder: \"ex. Shakespeare\",\r\n            value: this.fields.author(),\r\n            required: true,\r\n            oninput: (e) => {\r\n              this.fields.author(e.target.value);\r\n              this.removeRedStyle();\r\n            },\r\n          },\r\n          )\r\n        ),\r\n        m('.Form-group',\r\n          m('label', app.translator.trans('flarum-references.forum.modal.ref_title_label')),\r\n          m('input.FormControl', {\r\n            type: \"text\",\r\n            value: this.fields.title(),\r\n            placeholder: \"ex. Cultura în Evul Mediu\",\r\n            required: true,\r\n            oninput: (e) => {\r\n              this.fields.title(e.target.value);\r\n              this.removeRedStyle();\r\n            },\r\n          },\r\n          )\r\n        ),\r\n        m('.Form-group',\r\n          m('label', app.translator.trans('flarum-references.forum.modal.ref_year_label')),\r\n          m('input.FormControl', {\r\n            type: \"text\",\r\n            placeholder: \"ex. 2015\",\r\n            pattern: \"^(?:(?:1[6-9]|[2-9]\\\\d)\\\\d{2})$\",\r\n            value: this.fields.year(),\r\n            oninput: (e) => {\r\n              this.fields.year(e.target.value);\r\n              this.removeRedStyle();\r\n            }\r\n          },\r\n          )\r\n        ),\r\n        m('.Form-group',\r\n          m('label', app.translator.trans('flarum-references.forum.modal.ref_edit_label')),\r\n          m('input.FormControl', {\r\n            type: \"text\",\r\n            value: this.fields.editura(),\r\n            placeholder: \"ex. Lumina\",\r\n            oninput: (e) => {\r\n              this.fields.editura(e.target.value);\r\n              this.removeRedStyle();\r\n            }\r\n          },\r\n          )\r\n        ),\r\n          Button.component(\r\n            {\r\n              className: \"Button Button--primary\",\r\n              onclick: () => this.addReference(),\r\n            },\r\n            \"Adaugare\"\r\n          ),\r\n        )\r\n      )\r\n    ];\r\n  }\r\n\r\n  removeRedStyle() {\r\n    const requiredFields = this.$('input');\r\n\r\n    for (let k = 0; k < requiredFields.length; k++) {\r\n      if (requiredFields[k].validity.valid) {\r\n        requiredFields[k].removeAttribute(\"style\");\r\n      }\r\n    }\r\n  }\r\n\r\n  areSetRequiredFields() {\r\n    const requiredFields = this.$('input');\r\n    let i = 0;\r\n    \r\n    for (let k = 0; k < requiredFields.length; k++) {\r\n      if (!requiredFields[k].validity.valid) {\r\n        requiredFields[k].style.setProperty('border-color', 'red', 'important');\r\n        i++;\r\n      }\r\n    }\r\n\r\n    if (i == 0) return true;\r\n\r\n    return false;\r\n  }\r\n\r\n  addReference() {\r\n    if (!this.areSetRequiredFields()) return;\r\n\r\n    let date = new Date();\r\n\r\n    if (flarum.extensions['askvortsov-rich-text']) { // implements for askvortsov-rich-text editor\r\n      app.composer.editor.insertAtCursor(\"[ref id=ref\" + ++this.referenceId + \"]\" + this.referenceId + \"[/ref]\");\r\n\r\n      const position = app.composer.editor.getSelectionRange();\r\n      \r\n      if (this.referenceId == 1) {\r\n        app.composer.editor.moveCursorTo(app.composer.editor.attrs.menuState.editorView.dom.outerText.length + 1);\r\n        app.composer.editor.setEnter();\r\n        app.composer.editor.insertAtCursor(\"Referinte:\");\r\n        app.composer.editor.setEnter();\r\n      } else {\r\n        app.composer.editor.moveCursorTo(app.composer.editor.attrs.menuState.editorView.dom.outerText.length + 1);\r\n        app.composer.editor.setEnter();\r\n      }\r\n\r\n      app.composer.editor.insertAtCursor(\r\n        this.referenceId +\r\n        \". [reference id=ref\" + this.referenceId + \" type=book] \" +\r\n        this.fields.author() +\r\n        \". \" +\r\n        this.fields.title() +\r\n        \". \" +\r\n        this.fields.editura() +\r\n        ((this.fields.editura().length === 0) ? \"\" : (this.fields.year().length === 0) ? \"\" : \", \") +\r\n        this.fields.year() +\r\n        ((this.fields.year().length === 0) ? \" \" : \". \") +\r\n        \"[citat la \" +\r\n        date.getDate() + \r\n        \".\" + (date.getMonth() + 1) +\r\n        \".\" + date.getFullYear() +\r\n        \"] \" +\r\n        this.fields.link() +\r\n        ((this.fields.link().length === 0) ? \"[/reference]\" : \" [/reference]\")\r\n      );\r\n\r\n      app.composer.editor.setSelectionRange(position[0], position[1]);\r\n      app.composer.editor.setEnter();\r\n      app.composer.editor.delete();\r\n\r\n    } else { // implements for flarum-markdown editor\r\n      console.log(app.composer.editor.el.value);\r\n      console.log(app.composer.fields.content());\r\n      app.composer.editor.insertAtCursor(\"[ref id=ref\" + ++this.referenceId + \"]\" + this.referenceId + \"[/ref]\");\r\n\r\n      const position = app.composer.editor.getSelectionRange();\r\n\r\n      if (this.referenceId == 1) {\r\n        app.composer.editor.moveCursorTo(app.composer.editor.el.value.length + 1);\r\n        // app.composer.editor.setEnter();\r\n        app.composer.editor.insertAtCursor(\"\\n\\nReferinte:\\n\");\r\n        // app.composer.editor.setEnter();\r\n      } else {\r\n        app.composer.editor.moveCursorTo(app.composer.editor.el.value.length + 1);\r\n        app.composer.editor.insertAtCursor(\"\\n\");\r\n        // app.composer.editor.setEnter();\r\n      }\r\n\r\n      app.composer.editor.insertAtCursor(\r\n        \"\\n\" +\r\n        this.referenceId +\r\n        \"\\\\. [reference id=ref\" + this.referenceId + \" type=book] \" +\r\n        this.fields.author() +\r\n        \". \" +\r\n        this.fields.title() +\r\n        \". \" +\r\n        this.fields.editura() +\r\n        ((this.fields.editura().length === 0) ? \"\" : (this.fields.year().length === 0) ? \"\" : \", \") +\r\n        this.fields.year() +\r\n        ((this.fields.year().length === 0) ? \" \" : \". \") +\r\n        \"[citat la \" +\r\n        date.getDate() + \r\n        \".\" + (date.getMonth() + 1) +\r\n        \".\" + date.getFullYear() +\r\n        \"] \" +\r\n        this.fields.link() +\r\n        ((this.fields.link().length === 0) ? \"[/reference]\" : \" [/reference]\")\r\n      );\r\n\r\n      app.composer.editor.setSelectionRange(position[0], position[1]);\r\n\r\n    }\r\n\r\n    app.modal.close();\r\n  }\r\n}","import Modal from \"flarum/components/Modal\";\r\nimport Button from 'flarum/components/Button';\r\nimport Stream from 'flarum/common/utils/Stream';\r\n\r\nexport default class NewsRefModal extends Modal {\r\n  oninit(vnode) {\r\n    super.oninit(vnode);\r\n\r\n    this.value = app.composer.fields.content() || '';\r\n    // this.allReferences = this.value.match(/\\[reference\\ id=[\\w]*\\][\\w\\ \\(\\)\\[\\]\\.\\,\\/\\\\\\-_\\+;:\"'?&]*\\[\\/reference\\]/gm);\r\n    this.allReferences = this.value.match(/\\[reference\\ id=[\\w]* type=[\\w]*\\].*\\[\\/reference\\]/gm);\r\n    this.referenceId = this.allReferences?.length || 0;\r\n\r\n    this.fields = {\r\n      title: Stream(''),\r\n      link: Stream(''),\r\n      author: Stream(''),\r\n      createAt: Stream(''),\r\n      siteName: Stream(''),\r\n    };\r\n  }\r\n\r\n  className() {\r\n    return \"\";\r\n  }\r\n\r\n  title() {\r\n    return app.translator.trans('flarum-references.forum.modal.ref_news_modal');\r\n  }\r\n\r\n  content() {\r\n    return [\r\n      m('.Modal-body',\r\n        m('Form.Form--left',\r\n        m('span.description', app.translator.trans('flarum-references.forum.modal.ref_news_description')),\r\n        m('.Form-group',\r\n          m('label', app.translator.trans('flarum-references.forum.modal.ref_title_label')),\r\n          m('input.FormControl', {\r\n            type: \"text\",\r\n            value: this.fields.title(),\r\n            placeholder: \"ex. Cultura în Evul Mediu\",\r\n            required: true,\r\n            oninput: (e) => {\r\n              this.fields.title(e.target.value);\r\n              this.removeRedStyle();\r\n            },\r\n          },\r\n          )\r\n        ),\r\n        m('.Form-group',\r\n          m('label', app.translator.trans('flarum-references.forum.modal.ref_author_label')),\r\n          m('input.FormControl', {\r\n            type: \"text\",\r\n            placeholder: \"ex. Shakespeare\",\r\n            bidi: this.fields.author,\r\n          },\r\n          )\r\n        ),\r\n        m('.Form-group',\r\n          m('label', app.translator.trans('flarum-references.forum.modal.ref_link_label')),\r\n          m('input.FormControl', {\r\n            type: \"url\",\r\n            value: this.fields.link(),\r\n            placeholder: \"ex. http://example.com\",\r\n            required: true,\r\n            oninput: (e) => {\r\n              this.fields.link(e.target.value);\r\n              this.fields.siteName(e.target.value?.split('//')[1]?.split('/')[0] || \"\");\r\n              this.removeRedStyle();\r\n            },\r\n          },\r\n          )\r\n        ),\r\n        m('.Form-group',\r\n          m('label', app.translator.trans('flarum-references.forum.modal.ref_sourcename_label')),\r\n          m('input.FormControl', {\r\n            type: \"text\",\r\n            value: this.fields.siteName(),\r\n            placeholder: \"ex. example.com\",\r\n            required: true,\r\n            oninput: (e) => {\r\n              this.fields.siteName(e.target.value);\r\n              this.removeRedStyle();\r\n            },\r\n          },\r\n          )\r\n        ),\r\n        m('.Form-group',\r\n          m('label', app.translator.trans('flarum-references.forum.modal.ref_createat_label')),\r\n          m('input.FormControl', {\r\n            type: \"text\",\r\n            placeholder: \"ex. 01.01.1970\",\r\n            pattern: \"^(?:(?:31(\\\\.)(?:0?[13578]|1[02]))\\\\1|(?:(?:29|30)(\\\\.)(?:0?[1,3-9]|1[0-2])\\\\2))(?:(?:1[6-9]|[2-9]\\\\d)?\\\\d{2})$|^(?:29(\\\\.)0?2\\\\3(?:(?:(?:1[6-9]|[2-9]\\\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:0?[1-9]|1\\\\d|2[0-8])(\\\\.)(?:(?:0?[1-9])|(?:1[0-2]))\\\\4(?:(?:1[6-9]|[2-9]\\\\d)?\\\\d{2})$\",\r\n            value: this.fields.createAt(),\r\n            oninput: (e) => {\r\n              this.fields.createAt(e.target.value);\r\n              this.removeRedStyle();\r\n            }\r\n          },\r\n          )\r\n        ),\r\n          Button.component(\r\n            {\r\n              className: \"Button Button--primary\",\r\n              onclick: () => this.addReference(),\r\n            },\r\n            \"Adaugare\"\r\n          ),\r\n        )\r\n      )\r\n    ];\r\n  }\r\n\r\n  removeRedStyle() {\r\n    const requiredFields = this.$('input');\r\n\r\n    for (let k = 0; k < requiredFields.length; k++) {\r\n      if (requiredFields[k].validity.valid) {\r\n        requiredFields[k].removeAttribute(\"style\");\r\n      }\r\n    }\r\n  }\r\n\r\n  areSetRequiredFields() {\r\n    const requiredFields = this.$('input');\r\n    let i = 0;\r\n    \r\n    for (let k = 0; k < requiredFields.length; k++) {\r\n      if (!requiredFields[k].validity.valid) {\r\n        requiredFields[k].style.setProperty('border-color', 'red', 'important');\r\n        i++;\r\n      }\r\n    }\r\n\r\n    if (i == 0) return true;\r\n\r\n    return false;\r\n  }\r\n\r\n  addReference() {\r\n    if (!this.areSetRequiredFields()) return;\r\n    \r\n    let date = new Date();\r\n    \r\n    if (flarum.extensions['askvortsov-rich-text']) { // implements for askvortsov-rich-text editor\r\n      app.composer.editor.insertAtCursor(\"[ref id=ref\" + ++this.referenceId + \"]\" + this.referenceId + \"[/ref]\");\r\n\r\n      const position = app.composer.editor.getSelectionRange();\r\n      \r\n      if (this.referenceId == 1) {\r\n        app.composer.editor.moveCursorTo(app.composer.editor.attrs.menuState.editorView.dom.outerText.length + 1);\r\n        app.composer.editor.setEnter();\r\n        app.composer.editor.insertAtCursor(\"Referinte:\");\r\n        app.composer.editor.setEnter();\r\n      } else {\r\n        app.composer.editor.moveCursorTo(app.composer.editor.attrs.menuState.editorView.dom.outerText.length + 1);\r\n        app.composer.editor.setEnter();\r\n      }\r\n\r\n      app.composer.editor.insertAtCursor(\r\n        this.referenceId +\r\n        \". [reference id=ref\" + this.referenceId + \" type=news] \" +\r\n        this.fields.author() +\r\n        ((this.fields.author().length === 0) ? \"\" : \". \") +\r\n        this.fields.title() +\r\n        \". \" +\r\n        this.fields.siteName() +\r\n        ((this.fields.createAt().length === 0) ? \". \" : \", \") +\r\n        this.fields.createAt() +\r\n        ((this.fields.createAt().length === 0) ? \"\" : \". \") +\r\n        \"[citat la \" +\r\n        date.getDate() + \r\n        \".\" + (date.getMonth() + 1) +\r\n        \".\" + date.getFullYear() +\r\n        \"] \" +\r\n        this.fields.link() +\r\n        \" [/reference]\"\r\n      );\r\n\r\n      app.composer.editor.setSelectionRange(position[0], position[1]);\r\n      app.composer.editor.setEnter();\r\n      app.composer.editor.delete();\r\n\r\n    } else { // implements for flarum-markdown editor\r\n      console.log(app.composer.editor.el.value);\r\n      console.log(app.composer.fields.content());\r\n      app.composer.editor.insertAtCursor(\"[ref id=ref\" + ++this.referenceId + \"]\" + this.referenceId + \"[/ref]\");\r\n\r\n      const position = app.composer.editor.getSelectionRange();\r\n\r\n      if (this.referenceId == 1) {\r\n        app.composer.editor.moveCursorTo(app.composer.editor.el.value.length + 1);\r\n        // app.composer.editor.setEnter();\r\n        app.composer.editor.insertAtCursor(\"\\n\\nReferinte:\\n\");\r\n        // app.composer.editor.setEnter();\r\n      } else {\r\n        app.composer.editor.moveCursorTo(app.composer.editor.el.value.length + 1);\r\n        app.composer.editor.insertAtCursor(\"\\n\");\r\n        // app.composer.editor.setEnter();\r\n      }\r\n\r\n      app.composer.editor.insertAtCursor(\r\n        \"\\n\" +\r\n        this.referenceId +\r\n        \"\\\\. [reference id=ref\" + this.referenceId + \" type=news] \" +\r\n        this.fields.author() +\r\n        ((this.fields.author().length === 0) ? \"\" : \". \") +\r\n        this.fields.title() +\r\n        \". \" +\r\n        this.fields.siteName() +\r\n        ((this.fields.createAt().length === 0) ? \". \" : \", \") +\r\n        this.fields.createAt() +\r\n        ((this.fields.createAt().length === 0) ? \"\" : \". \") +\r\n        \"[citat la \" +\r\n        date.getDate() + \r\n        \".\" + (date.getMonth() + 1) +\r\n        \".\" + date.getFullYear() +\r\n        \"] \" +\r\n        this.fields.link() +\r\n        \" [/reference]\"\r\n      );\r\n\r\n      app.composer.editor.setSelectionRange(position[0], position[1]);\r\n    }\r\n\r\n    app.modal.close();\r\n  }\r\n}","import Modal from \"flarum/components/Modal\";\r\nimport Button from 'flarum/components/Button';\r\nimport Stream from 'flarum/common/utils/Stream';\r\n\r\nexport default class JournalRefModal extends Modal {\r\n  oninit(vnode) {\r\n    super.oninit(vnode);\r\n\r\n    this.value = app.composer.fields.content() || '';\r\n    // this.allReferences = this.value.match(/\\[reference\\ id=[\\w]*\\][\\w\\ \\(\\)\\[\\]\\.\\,\\/\\\\\\-_\\+;:\"'?&]*\\[\\/reference\\]/gm);\r\n    this.allReferences = this.value.match(/\\[reference\\ id=[\\w]* type=[\\w]*\\].*\\[\\/reference\\]/gm);\r\n    this.referenceId = this.allReferences?.length || 0;\r\n\r\n    this.fields = {\r\n      title: Stream(''),\r\n      author: Stream(''),\r\n    };\r\n  }\r\n\r\n  className() {\r\n    return \"\";\r\n  }\r\n\r\n  title() {\r\n    return app.translator.trans('flarum-references.forum.modal.ref_journal_modal');\r\n  }\r\n\r\n  content() {\r\n    return [\r\n      m('.Modal-body',\r\n        m('Form.Form--left',\r\n        m('.Form-group',\r\n          m('label', app.translator.trans('flarum-references.forum.modal.ref_title_label')),\r\n          m('input.FormControl', {\r\n            type: \"text\",\r\n            value: this.fields.title(),\r\n            placeholder: \"ex. Cultura în Evul Mediu\",\r\n            required: true,\r\n            oninput: (e) => {\r\n              this.fields.title(e.target.value);\r\n              this.removeRedStyle();\r\n            },\r\n          },\r\n          )\r\n        ),\r\n        m('.Form-group',\r\n          m('label', app.translator.trans('flarum-references.forum.modal.ref_author_label')),\r\n          m('input.FormControl', {\r\n            type: \"text\",\r\n            placeholder: \"ex. Shakespeare\",\r\n            bidi: this.fields.author,\r\n          },\r\n          )\r\n        ),\r\n          Button.component(\r\n            {\r\n              className: \"Button Button--primary\",\r\n              onclick: () => this.addReference(),\r\n            },\r\n            \"Adaugare\"\r\n          ),\r\n        )\r\n      )\r\n    ];\r\n  }\r\n\r\n  removeRedStyle() {\r\n    const requiredFields = this.$('input');\r\n\r\n    for (let k = 0; k < requiredFields.length; k++) {\r\n      if (requiredFields[k].validity.valid) {\r\n        requiredFields[k].removeAttribute(\"style\");\r\n      }\r\n    }\r\n  }\r\n\r\n  areSetRequiredFields() {\r\n    const requiredFields = this.$('input');\r\n    let i = 0;\r\n    \r\n    for (let k = 0; k < requiredFields.length; k++) {\r\n      if (!requiredFields[k].validity.valid) {\r\n        requiredFields[k].style.setProperty('border-color', 'red', 'important');\r\n        i++;\r\n      }\r\n    }\r\n\r\n    if (i == 0) return true;\r\n\r\n    return false;\r\n  }\r\n\r\n  addReference() {\r\n    if (!this.areSetRequiredFields()) return;\r\n\r\n    let date = new Date();\r\n    \r\n    if (flarum.extensions['askvortsov-rich-text']) { // implements for askvortsov-rich-text editor\r\n      app.composer.editor.insertAtCursor(\"[ref id=ref\" + ++this.referenceId + \"]\" + this.referenceId + \"[/ref]\");\r\n\r\n      const position = app.composer.editor.getSelectionRange();\r\n      \r\n      if (this.referenceId == 1) {\r\n        app.composer.editor.moveCursorTo(app.composer.editor.attrs.menuState.editorView.dom.outerText.length + 1);\r\n        app.composer.editor.setEnter();\r\n        app.composer.editor.insertAtCursor(\"Referinte:\");\r\n        app.composer.editor.setEnter();\r\n      } else {\r\n        app.composer.editor.moveCursorTo(app.composer.editor.attrs.menuState.editorView.dom.outerText.length + 1);\r\n        app.composer.editor.setEnter();\r\n      }\r\n\r\n      app.composer.editor.insertAtCursor(\r\n        this.referenceId +\r\n        \". [reference id=ref\" + this.referenceId + \" type=journal] \" +\r\n        this.fields.author() +\r\n        ((this.fields.author().length === 0) ? \"\" : \". \") +\r\n        this.fields.title() +\r\n        \". \" +\r\n        \"[citat la \" +\r\n        date.getDate() + \r\n        \".\" + (date.getMonth() + 1) +\r\n        \".\" + date.getFullYear() +\r\n        \"] \" +\r\n        \"[/reference]\"\r\n      );\r\n\r\n      app.composer.editor.setSelectionRange(position[0], position[1]);\r\n      app.composer.editor.setEnter();\r\n      app.composer.editor.delete();\r\n\r\n    } else { // implements for flarum-markdown editor\r\n      console.log(app.composer.editor.el.value);\r\n      console.log(app.composer.fields.content());\r\n      app.composer.editor.insertAtCursor(\"[ref id=ref\" + ++this.referenceId + \"]\" + this.referenceId + \"[/ref]\");\r\n\r\n      const position = app.composer.editor.getSelectionRange();\r\n\r\n      if (this.referenceId == 1) {\r\n        app.composer.editor.moveCursorTo(app.composer.editor.el.value.length + 1);\r\n        // app.composer.editor.setEnter();\r\n        app.composer.editor.insertAtCursor(\"\\n\\nReferinte:\\n\");\r\n        // app.composer.editor.setEnter();\r\n      } else {\r\n        app.composer.editor.moveCursorTo(app.composer.editor.el.value.length + 1);\r\n        app.composer.editor.insertAtCursor(\"\\n\");\r\n        // app.composer.editor.setEnter();\r\n      }\r\n\r\n      app.composer.editor.insertAtCursor(\r\n        \"\\n\" +\r\n        this.referenceId +\r\n        \"\\\\. [reference id=ref\" + this.referenceId + \" type=journal] \" +\r\n        this.fields.author() +\r\n        ((this.fields.author().length === 0) ? \"\" : \". \") +\r\n        this.fields.title() +\r\n        \". \" +\r\n        \"[citat la \" +\r\n        date.getDate() + \r\n        \".\" + (date.getMonth() + 1) +\r\n        \".\" + date.getFullYear() +\r\n        \"] \" +\r\n        \"[/reference]\"\r\n      );\r\n\r\n      app.composer.editor.setSelectionRange(position[0], position[1]);\r\n    }\r\n\r\n    app.modal.close();\r\n  }\r\n}","import Modal from \"flarum/components/Modal\";\r\n\r\nimport DefaultRefModal from './DefaultRefModal';\r\nimport SiteRefModal from './SiteRefModal';\r\nimport BookRefModal from './BookRefModal';\r\nimport NewsRefModal from './NewsRefModal';\r\nimport JournalRefModal from './JournalRefModal';\r\n\r\nexport default class ReferencesModal extends Modal {\r\n  oninit(vnode) {\r\n    super.oninit(vnode);\r\n  }\r\n\r\n  className() {\r\n    return \"DiscussionType\";\r\n  }\r\n\r\n  title() {\r\n    return app.translator.trans('flarum-references.forum.modal.ref_type_modal');\r\n  }\r\n\r\n  content() {\r\n    return [\r\n      m('.Modal-body',\r\n        m('.Form.Form--centered div_referinta',\r\n          m('.Form-group',\r\n            m('.choiceBox', {\r\n              onclick: () => app.modal.show(SiteRefModal),\r\n            },\r\n              (<i class=\"icon fas fa-window-maximize Button-icon\"></i>),\r\n              m('span', app.translator.trans('flarum-references.forum.modal.ref_site_modal')),\r\n            )\r\n          ),\r\n          m('.Form-group',\r\n            m('.choiceBox', {\r\n              onclick: () => app.modal.show(BookRefModal),\r\n            },\r\n              (<i class=\"icon fas fa-book Button-icon\"></i>),\r\n              m('span', app.translator.trans('flarum-references.forum.modal.ref_book_modal')),\r\n            )\r\n          ),\r\n          m('.Form-group',\r\n            m('.choiceBox', {\r\n              onclick: () => app.modal.show(NewsRefModal),\r\n            },\r\n              (<i class=\"icon fas fa-newspaper Button-icon\"></i>),\r\n              m('span', app.translator.trans('flarum-references.forum.modal.ref_news_modal')),\r\n            )\r\n          ),\r\n          m('.Form-group',\r\n            m('.choiceBox', {\r\n              onclick: () => app.modal.show(JournalRefModal),\r\n            },\r\n              (<i class=\"icon fas fa-book-open Button-icon\"></i>),\r\n              m('span', app.translator.trans('flarum-references.forum.modal.ref_journal_modal')),\r\n            )\r\n          ),\r\n          m('.Form-group',\r\n            m('.choiceBox', {\r\n              onclick: () => app.modal.show(DefaultRefModal),\r\n            },\r\n              (<i class=\"icon fas fa-bookmark Button-icon\"></i>),\r\n              m('span', app.translator.trans('flarum-references.forum.modal.ref_default_modal')),\r\n            )\r\n          ),\r\n        )\r\n      )\r\n    ];\r\n  }\r\n}","import { extend } from 'flarum/common/extend';\r\nimport { baseKeymap } from 'tiptap-commands';\r\nimport app from 'flarum/app';\r\nimport TextEditor from 'flarum/common/components/TextEditor';\r\nimport CommentPost from 'flarum/forum/components/CommentPost';\r\nimport ComposerBody from 'flarum/components/ComposerBody';\r\nimport Button from 'flarum/components/Button';\r\nimport Tooltip from 'flarum/common/components/Tooltip';\r\nimport ItemList from 'flarum/common/utils/ItemList';\r\nimport listItems from 'flarum/common/helpers/listItems';\r\nimport Alert from 'flarum/common/components/Alert';\r\n\r\nimport ReferencesModal from './components/ReferencesModal';\r\n\r\napp.initializers.add('aradeid/flarum-references', () => {\r\n  // adaugarea metodei pentru simularea tastei enter in rich-text\r\n  if (flarum.extensions['askvortsov-rich-text']) {\r\n    const {\r\n      ProseMirrorEditorDriver\r\n    } = flarum.extensions['askvortsov-rich-text'].proseMirror;\r\n\r\n    ProseMirrorEditorDriver.prototype.setEnter = function() {\r\n      // console.log(this.view.state);\r\n      baseKeymap['Enter'](this.view.state, this.view.dispatch);\r\n    }\r\n    ProseMirrorEditorDriver.prototype.delete = function() {\r\n      // console.log(\"sters\");\r\n      baseKeymap['Backspace'](this.view.state, this.view.dispatch);\r\n    }\r\n  }\r\n\r\n  // adaugarea butonului pentru referinte in Editor la optiuni\r\n  extend(TextEditor.prototype, 'toolbarItems', function (items) {\r\n    // by BlockCat\r\n    items.add(\r\n      'references',\r\n      Tooltip.component(\r\n        {\r\n          text: app.translator.trans('flarum-references.forum.composer.ref_button'),\r\n        },\r\n        Button.component(\r\n          {\r\n            className: 'Button Button--icon Button--link',\r\n            icon: 'fas fa-link',\r\n            onclick: () => app.modal.show(ReferencesModal),\r\n          },\r\n        ),\r\n      ),\r\n    );\r\n    return items;\r\n  });\r\n\r\n  // adaugarea butonului pentru referinte in Editor in partea dreapta (portlet-ui)\r\n  ComposerBody.prototype.sidebarMenu = function () {\r\n    const items = new ItemList();\r\n\r\n    items.add(\r\n      'reference_button',\r\n      Button.component(\r\n          {\r\n              // icon: 'fas fa-pencil-alt',\r\n              className: 'Button Button--secondary',\r\n              onclick: () => app.modal.show(ReferencesModal),\r\n          },\r\n          app.translator.trans('flarum-references.forum.composer.ref_button')),\r\n    );\r\n\r\n    items.add(\r\n      'reference_ctrl_button',\r\n      Button.component(\r\n        {\r\n          className: 'Button Button--secondary',\r\n          loading: this.loadingButton,\r\n          onclick: () => this.linkControl(),\r\n        },\r\n        app.translator.trans('flarum-references.forum.composer.ref_ctrl_button')\r\n      ),\r\n    );\r\n\r\n    return items;\r\n  }\r\n\r\n  extend(ComposerBody.prototype, 'oninit', function () {\r\n    this.loadingButton = false;\r\n  });\r\n\r\n  ComposerBody.prototype.linkControl = async function () {\r\n    this.loadingButton = true;\r\n    const value = this.composer.fields.content();\r\n\r\n    if (value == '') {\r\n      this.loadingButton = false;\r\n      return;\r\n    }\r\n\r\n    const allReferences = value.match(/\\[reference\\ id=[\\w]* type=[\\w]*\\].*\\[\\/reference\\]/gm);\r\n    \r\n    for (let i = 0; i < allReferences.length; i++) {\r\n      let tmp = allReferences[i].match(/(https?:\\/\\/)(\\w+\\.){1,}\\w+[(\\/(\\w\\-\\_\\+\\%\\.\\?)+)]*/);\r\n\r\n      if (tmp !== null) {\r\n        allReferences[i] = tmp[0];\r\n\r\n        let response = await fetch('https://tools.emoldova.org/tools/validate-source', {\r\n          method: 'POST',\r\n          body: JSON.stringify({\r\n            url: allReferences[i]\r\n          }),\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n          },\r\n        });\r\n  \r\n        const result = await response.json();\r\n        allReferences[i] = result.success;\r\n      } else {\r\n        allReferences[i] = true;\r\n      }\r\n    }\r\n\r\n    if (allReferences.every((ref) => {\r\n      return ref ? true : false;\r\n    })) {\r\n      app.alerts.show(\r\n        Alert,\r\n        {\r\n          type: 'success',\r\n        },\r\n        app.translator.trans('flarum-references.forum.composer.alert.success_alert')\r\n      );\r\n      this.loadingButton = false;\r\n    } else {\r\n      const unaccesibleIndexes = allReferences\r\n        .map((ref, index) => {\r\n          if (ref == false) return index;\r\n        })\r\n        .filter(index => index >= 0)\r\n        .map(index => index + 1);\r\n      let indexes = unaccesibleIndexes.join(', ');\r\n      app.alerts.show(\r\n        Alert,\r\n        {\r\n          type: 'warning',\r\n        },\r\n        (unaccesibleIndexes.length == 1) ?\r\n          app.translator.trans('flarum-references.forum.composer.alert.warning_alert_one', {indexes}) :\r\n          app.translator.trans('flarum-references.forum.composer.alert.warning_alert_more', {indexes})\r\n      );\r\n      this.loadingButton = false;\r\n    }\r\n  }\r\n\r\n  extend(ComposerBody.prototype, 'view', function (view) {\r\n    view.children[0].children[1].children.push(<ul className=\"sidebarMenu\">{listItems(this.sidebarMenu().toArray())}</ul>);\r\n  });\r\n\r\n  // Implementarea accesarii link-urilor interne in articole si comentarii\r\n  // by BlockCat\r\n  extend(CommentPost.prototype, ['oncreate', 'onupdate'], function () {\r\n    const baseUrl = app.forum.attribute('baseUrl');\r\n    const postBody = this.element.querySelector('.Post-body');\r\n    const elements = postBody.querySelectorAll('a');\r\n\r\n    for (const link of elements) {\r\n      if (link.classList.contains('PostMention')) {\r\n          continue;\r\n      }\r\n\r\n      const href = link.href;\r\n      \r\n      if (!href.startsWith(baseUrl)) {\r\n        continue;\r\n      }\r\n      \r\n      const path = href.replace(baseUrl, '');\r\n      const elements = path.split('/');\r\n      const isFile = elements[elements.length-1].match(/(.*)\\.(.*)/i);\r\n      \r\n      if (isFile) {\r\n        continue;\r\n      }\r\n      \r\n      const separateId = elements[elements.length-1].split('#');\r\n      const referenceId = separateId[separateId.length - 1];\r\n\r\n      link.addEventListener('click', function (e) {\r\n          e.preventDefault();\r\n\r\n          var reference = document.getElementById(referenceId);\r\n          reference?.scrollIntoView({behavior: 'smooth'});\r\n      });\r\n    }\r\n  });\r\n}, -21);"],"sourceRoot":""}