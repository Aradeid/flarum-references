{"version":3,"sources":["webpack://@aradeid/flarum-references/webpack/bootstrap","webpack://@aradeid/flarum-references/./forum.js","webpack://@aradeid/flarum-references/./node_modules/@babel/runtime/helpers/esm/extends.js","webpack://@aradeid/flarum-references/./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","webpack://@aradeid/flarum-references/./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","webpack://@aradeid/flarum-references/./node_modules/orderedmap/index.es.js","webpack://@aradeid/flarum-references/../src/commands.js","webpack://@aradeid/flarum-references/../src/inputrules.js","webpack://@aradeid/flarum-references/../src/rules.js","webpack://@aradeid/flarum-references/../src/rulebuilders.js","webpack://@aradeid/flarum-references/../src/diff.js","webpack://@aradeid/flarum-references/../src/fragment.js","webpack://@aradeid/flarum-references/../src/comparedeep.js","webpack://@aradeid/flarum-references/../src/mark.js","webpack://@aradeid/flarum-references/../src/replace.js","webpack://@aradeid/flarum-references/../src/resolvedpos.js","webpack://@aradeid/flarum-references/../src/node.js","webpack://@aradeid/flarum-references/../src/content.js","webpack://@aradeid/flarum-references/../src/schema.js","webpack://@aradeid/flarum-references/../src/from_dom.js","webpack://@aradeid/flarum-references/../src/to_dom.js","webpack://@aradeid/flarum-references/../src/schema-list.js","webpack://@aradeid/flarum-references/../src/selection.js","webpack://@aradeid/flarum-references/../src/transaction.js","webpack://@aradeid/flarum-references/../src/state.js","webpack://@aradeid/flarum-references/../src/plugin.js","webpack://@aradeid/flarum-references/../src/map.js","webpack://@aradeid/flarum-references/../src/transform.js","webpack://@aradeid/flarum-references/../src/step.js","webpack://@aradeid/flarum-references/../src/replace_step.js","webpack://@aradeid/flarum-references/../src/structure.js","webpack://@aradeid/flarum-references/../src/mark_step.js","webpack://@aradeid/flarum-references/./node_modules/tiptap-commands/dist/commands.esm.js","webpack://@aradeid/flarum-references/./node_modules/tiptap-utils/dist/utils.esm.js","webpack://@aradeid/flarum-references/./src/forum/InsertReferenceDropdown.js","webpack://@aradeid/flarum-references/./src/forum/index.js","webpack://@aradeid/flarum-references/external \"flarum.core.compat['app']\"","webpack://@aradeid/flarum-references/external \"flarum.core.compat['common/components/Button']\"","webpack://@aradeid/flarum-references/external \"flarum.core.compat['common/components/Dropdown']\"","webpack://@aradeid/flarum-references/external \"flarum.core.compat['common/components/TextEditor']\"","webpack://@aradeid/flarum-references/external \"flarum.core.compat['common/components/Tooltip']\"","webpack://@aradeid/flarum-references/external \"flarum.core.compat['common/extend']\"","webpack://@aradeid/flarum-references/external \"flarum.core.compat['common/helpers/icon']\"","webpack://@aradeid/flarum-references/external \"flarum.core.compat['common/utils/ItemList']\"","webpack://@aradeid/flarum-references/external \"flarum.core.compat['common/utils/Stream']\"","webpack://@aradeid/flarum-references/external \"flarum.core.compat['common/utils/extractText']\"","webpack://@aradeid/flarum-references/external \"flarum.core.compat['common/utils/styleSelectedText']\"","webpack://@aradeid/flarum-references/external \"flarum.core.compat['components/TextEditorButton']\"","webpack://@aradeid/flarum-references/external \"flarum.core.compat['forum/components/CommentPost']\""],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","_inheritsLoose","subClass","superClass","create","constructor","setPrototypeOf","_setPrototypeOf","o","p","__proto__","OrderedMap","content","find","get","found","undefined","update","value","newKey","self","remove","slice","push","splice","addToStart","concat","addToEnd","addBefore","place","without","forEach","f","prepend","map","from","size","subtract","append","result","prop","orderedmap","deleteSelection","state","dispatch","selection","empty","tr","scrollIntoView","joinBackward","view","$cursor","endOfTextblock","parentOffset","let","$cut","findCutBefore","range","blockRange","liftTarget","lift","before","nodeBefore","type","spec","isolating","deleteBarrier","parent","textblockAt","NodeSelection","isSelectable","delStep","replaceStep","doc","after","Slice","to","step","setSelection","Selection","findFrom","resolve","mapping","pos","nodeSize","isAtom","depth","node","side","only","firstChild","lastChild","isTextblock","childCount","selectNodeBackward","$head","$pos","index","joinForward","findCutAfter","nodeAfter","selectNodeForward","joinUp","sel","nodeSel","point","canJoin","joinPoint","join","joinDown","$from","$to","newlineInCode","code","sameParent","$anchor","insertText","defaultBlockAt","match","edgeCount","edge","hasRequiredAttrs","exitCode","above","indexAfter","contentMatchAt","canReplaceWith","replaceWith","createAndFill","near","createParagraphNear","AllSelection","inlineContent","insert","TextSelection","liftEmptyBlock","end","canSplit","split","splitBlock","isBlock","atEnd","deflt","types","can","first","$first","setNodeMarkup","splitBlockKeepMarks","marks","storedMarks","ensureMarks","selectParentNode","same","sharedDepth","selectAll","joinMaybeClear","compatibleContent","canReplace","clearIncompatible","conn","canDelAfter","findWrapping","matchType","validEnd","wrap","Fragment","copy","ReplaceAroundStep","joinAt","selAfter","at","afterText","afterDepth","selectTextblockSide","isInline","start","selectTextblockStart","selectTextblockEnd","wrapIn","nodeType","attrs","wrapping","setBlockType","applicable","nodesBetween","hasMarkup","markApplies","ranges","allowsMarkType","v","toggleMark","markType","isInSet","removeStoredMark","addStoredMark","has","rangeHasMark","removeMark","spaceStart","isText","exec","text","spaceEnd","addMark","wrapDispatchForJoin","isJoinable","isGeneric","maps","j","_s","_e","joinable","maybeChild","indexOf","child","sort","a","b","autoJoin","command","Array","isArray","name","chainCommands","commands","backspace","del","pcBaseKeymap","macBaseKeymap","Home","End","const","mac","navigator","test","platform","os","baseKeymap","InputRule","handler","stringHandler","string","offset","lastIndexOf","cutOff","MAX_MATCH","inputRules","ref","plugin","Plugin","init","prev","stored","getMeta","selectionSet","docChanged","props","handleTextInput","run","rules","handleDOMEvents","compositionend","setTimeout","isInputRules","composing","textBefore","textBetween","Math","max","setMeta","transform","undoInputRule","plugins","undoable","getState","toUndo","steps","invert","docs","schema","emDash","ellipsis","openDoubleQuote","closeDoubleQuote","openSingleQuote","closeSingleQuote","smartQuotes","wrappingInputRule","regexp","getAttrs","joinPredicate","Function","$start","textblockTypeInputRule","findDiffStart","childA","childB","sameMarkup","inner","findDiffEnd","posA","posB","iA","iB","minSize","min","nodeStart","descendants","blockSeparator","leafText","separated","isLeaf","other","last","withText","cut","cutByIndex","replaceChild","current","eq","prototypeAccessors","RangeError","otherPos","findIndex","round","retIndex","curPos","cur","toString","toStringInner","toJSON","n","fromJSON","nodeFromJSON","fromArray","array","joined","nodes","compareDeep","Mark","addToSet","set","placed","excludes","rank","removeFromSet","obj","_","json","sameSet","setFrom","none","ReplaceError","message","err","Error","openStart","openEnd","insertAt","fragment","insertInto","removeBetween","removeRange","maxOpen","openIsolating","offsetTo","indexTo","dist","replace","replaceOuter","close","replaceTwoWay","prepareSliceForReplace","replaceThreeWay","checkJoin","main","sub","$before","$after","addNode","addRange","$end","startIndex","endIndex","textOffset","validContent","$along","extra","resolveNoCache","ResolvedPos","path","resolveDepth","val","dOff","posAtIndex","tmp","inclusive","marksAcross","next","pred","d","NodeRange","str","rem","resolveCached","resolveCache","cached","resolveCachePos","resolveCacheSize","prototypeAccessors$1","emptyAttrs","Node","startPos","textContent","defaultAttrs","mark","includeParents","nodeAt","childAfter","childBefore","toDebugString","wrapMarks","contentMatch","matchFragment","replacement","one","two","allowsMarks","canAppend","check","m","markFromJSON","TextNode","super","JSON","stringify","base","ContentMatch","wrapCache","parse","nodeTypes","stream","TokenStream","expr","parseExpr","dfa","nfa","checkForDeadEnds","frag","defaultType","compatible","fillBefore","toEnd","seen","search","finished","tp","computed","computeWrapping","active","via","shift","reverse","scan","out","inline","tokens","pop","eat","tok","SyntaxError","exprs","parseExprSeq","parseExprSubscript","parseExprAtom","parseExprRange","parseNum","Number","resolveName","typeName","groups","connect","compile","term","edges","reduce","loop","cmp","nullFrom","labeled","explore","states","known","work","dead","defaults","attrName","attr","hasDefault","computeAttrs","built","given","initAttrs","Attribute","NodeType","group","markSet","atom","whitespace","isRequired","createChecked","allowedMarks","topType","topNode","options","MarkType","excluded","instance","Schema","contentExprCache","contentExpr","markExpr","gatherMarks","excl","bind","topNodeType","wrappings","ok","DOMParser","tags","styles","rule","tag","this","style","normalizeLists","some","r","dom","context","ParseContext","addAll","finish","parseSlice","matchTag","matches","namespace","namespaceURI","matchesContext","matchStyle","charCodeAt","schemaRules","priority","nextPriority","parseDOM","loop$1","fromSchema","domParser","blockTags","address","article","aside","blockquote","canvas","dd","div","dl","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","hr","li","noscript","ol","output","pre","section","table","tfoot","ul","ignoreTags","head","object","script","title","listTags","OPT_PRESERVE_WS","OPT_PRESERVE_WS_FULL","OPT_OPEN_LEFT","wsOptionsFor","preserveWhitespace","NodeContext","pendingMarks","solid","activeMarks","stashMarks","fill","popFromStashMark","applyPending","nextType","pending","markMayApply","inlineContext","parentNode","nodeName","toLowerCase","parser","open","isOpen","topContext","topOptions","topMatch","findPositions","needsBlock","top","addDOM","addTextNode","getAttribute","readStyles","parseStyles","addPendingMark","addElement","removePendingMark","nodeValue","domNodeBefore","previousSibling","insertNode","findInText","findInside","matchAfter","ruleID","normalizeList","ruleFromNode","ignore","ignoreFallback","skip","closeParent","sync","oldNeedsBlock","leafFallback","addElementByRule","consuming","ownerDocument","createTextNode","findPlace","continueAfter","enter","startIn","getContent","contentDOM","contentElement","querySelector","findAround","childNodes","nextSibling","findAtPoint","route","cx","enterInner","block","textblockFromContext","closeExtra","preserveWS","topOpen","currentPos","contains","compareDocumentPosition","textNode","parts","option","useRoot","minDepth","part","$context","findSameMarkInSet","upto","level","stashMark","prevItem","appendChild","selector","msMatchesSelector","webkitMatchesSelector","mozMatchesSelector","re","trim","DOMSerializer","serializeFragment","createDocumentFragment","keep","rendered","spanning","add","markDOM","serializeMark","serializeNodeInner","renderSpec","onContent","serializeNode","toDOM","structure","xmlNS","tagName","space","createElementNS","createElement","setAttributeNS","setAttribute","innerContent","domSerializer","nodesFromSchema","marksFromSchema","gatherToDOM","document","window","olDOM","ulDOM","liDOM","orderedList","order","hasAttribute","bulletList","listItem","defining","addListNodes","itemContent","listGroup","ordered_list","bullet_list","list_item","wrapInList","listType","doJoin","outerRange","$insert","doWrapInList","wrappers","joinBefore","splitDepth","splitPos","e","splitListItem","itemType","grandParent","depthBefore","depthAfter","liftListItem","liftToOuterList","liftOutOfList","endOfList","list","item","atStart","indexBefore","sinkListItem","nestedBefore","classesById","SelectionRange","anchor","lastNode","lastParent","mapFrom","replaceRange","selectionToInsertionEnd","deleteRange","replaceRangeWith","dir","textOnly","findSelectionIn","bias","cls","jsonID","id","selectionClass","getBookmark","between","visible","TextBookmark","dPos","mapResult","deleted","NodeBookmark","selectable","AllBookmark","startLen","ReplaceStep","_from","_to","_newFrom","newTo","UPDATED_SEL","UPDATED_MARKS","UPDATED_SCROLL","Transaction","time","Date","now","curSelection","curSelectionFor","updated","meta","setStoredMarks","storedMarksSet","addStep","setTime","replaceSelection","replaceSelectionWith","inheritMarks","scrolledIntoView","Transform","FieldDesc","desc","baseFields","config","_marks","_old","Configuration","fields","pluginsByKey","EditorState","applyTransaction","filterTransaction","rootTr","transactions","trs","newState","applyInner","haveNew","appendTransaction","oldState","newInstance","field","applyListeners","$config","reconfigure","pluginFields","addApplyListener","removeApplyListener","bindProps","createKey","keys","PluginKey","lower16","factor16","pow","makeRecover","recoverIndex","recoverOffset","MapResult","recover","StepMap","inverted","diff","assoc","_map","simple","oldIndex","newIndex","oldSize","newSize","touches","oldStart","newStart","Mapping","mirror","appendMap","mirrors","setMirror","appendMapping","startSize","mirr","getMirror","appendMappingInverted","totalSize","inverse","corr","TransformError","maybeStep","failed","getMap","mustOverride","stepsByID","Step","_doc","_mapping","merge","_other","stepType","stepClass","StepResult","fail","fromReplace","contentBetween","gapFrom","gapTo","gap","inserted","canCut","gapStart","gapEnd","splitting","innerRange","around","findWrappingOutside","findWrappingInside","withAttrs","outer","inside","lastType","innerMatch","canChangeType","startM","endM","newNode","typesAfter","innerType","rest","baseType","typeAfter","insertPoint","dropPoint","pass","insertPos","fits","mapFragment","mapped","AddMarkStep","oldSlice","RemoveMarkStep","removed","added","removing","adding","newSet","s","matched","toRemove","parentType","delSteps","allowed","fitsTrivially","Fitter","fit","unplaced","frontier","findFittable","placeNodes","openMore","dropNode","moveInline","mustMoveInline","placedSize","sliceDepth","contentAt","frontierDepth","inject","openAtEnd","dropFromFragment","closeFrontierNode","openFrontierNode","taken","openEndCount","closeNodeStart","addToFragment","contentAfterFits","findCloseLevel","dropInner","move","count","invalidMarks","targetDepths","coveredDepths","preferredTarget","unshift","preferredTargetIndex","leftNodes","preferredDepth","openDepth","targetDepth","expand","closeFragment","startSteps","oldOpen","newOpen","covered","getMarksBetween","markInputRule","markEnd","markStart","matchStart","matchEnd","textStart","textEnd","excludedMarks","filter","nodeInputRule","pasteRule","transformPasted","markPasteRule","isLink","x","getMarkRange","replaceText","setInlineBlockType","splitToDefaultListItem","keepItem","toggleBlockType","toggletype","isActive","nodeIsActive","isList","todo_list","toggleList","parentList","findParentNode","toggleWrap","updateMark","ref$1","createCell","cellType","cellContent","getTableNodeTypes","tableNodeTypes","roles","tableRole","createTable","rowsCount","colsCount","withHeaderRow","headerCells","cells","cell","headerCell","header_cell","rows","row","equalNodeType","flatten","descend","findChildren","predicate","findBlockNodes","findParentNodeClosestToPos","isNodeSelection","findSelectedNodeOfType","getMarkAttrs","markItem","link","endPos","getNodeAttrs","nodeItem","markIsActive","nodeEqualsType","includes","InsertReferenceDropdown","buttonClassName","oninit","vnode","Stream","href","selectionEmpty","oncreate","$","on","is","app","modal","show","SafariModalHack","tooltip","vnodeContent","toArray","onsubmit","stopPropagation","focus","select","getButtonContent","children","icon","getMenu","items","preventDefault","trigger","composer","editor","ItemList","translator","trans","extractText","linkAttrs","styleSelectedText","el","prefix","suffix","onEditorUpdate","markActive","toggleClass","markAttrs","Dropdown","initializers","extend","TextEditor","component","CommentPost","baseUrl","forum","attribute","postBody","element","elements","querySelectorAll","classList","startsWith","isFile","separateId","referenceId","addEventListener","reference","getElementById","behavior","addReference"],"mappings":"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Ab,EAAgBA,CAAC,GAAG8V,GAAG,CAAC5V,MAAxB,EAAgCF,CAAC,EAAjC,EAAmC;AAAE,QAAI8V,GAAG,CAAC9V,CAAD,CAAH,CAAOuE,IAAP,IAAe,IAAnB,EAAyB;AAC5DuR,SAAG,GAAGA,GAAG,CAAChU,KAAJ,CAAU,CAAV,EAAa9B,CAAb,EAAgBkC,MAAhB,CAAuB4T,GAAG,CAAChU,KAAJ,CAAU9B,CAAC,GAAG,CAAd,CAAvB,CAAN;AACAA,OAAC;AACP;AAAK;;AACD,SAAO8V,GAAP;AACF,E,CAEA;AACA;;;mBACArJ,2BAAQqJ,GAAR,EAAa;AACX,OAAKhS,IAAI9D,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8V,GAAG,CAAC5V,MAAxB,EAAgCF,CAAC,EAAjC,EACJ;AAAM,QAAI8V,GAAG,CAAC9V,CAAD,CAAH,CAAOuE,IAAP,IAAe,IAAnB,EAAuB;AAAE,aAAOuR,GAAG,CAAC9V,CAAD,CAAV;AAAY;AAAC;AAC1C,E,CAEA;AACA;AACA;;;mBACAgW,6BAAS/B,KAAT,EAAgB;AACd,SAAO,KAAK4M,QAAL,CAAc/S,OAAd,CAAsBmG,KAAtB,IAA+B,CAAC,CAAvC;AACF,E,CAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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A;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;IACakgB,SAAS,GAIpB,mBAAYzP,MAAZ,EAAoBpB,KAApB,EAA2B;oBAAA,CAC7B;AACA;;AACI,OAAKoB,MAAL,GAAcA,MAAd,CAHyB,CAI7B;AACA;AACA;;AACI,OAAKpB,KAAL,GAAaA,KAAb;AACA,OAAK8Q,IAAL,GAAY,EAAZ;AACA,OAAKC,MAAL,GAAc,EAAd;AAEA/Q,OAAK,CAACrO,OAAN,CAAa,UAACqf,IAAD,EAAS;AACpB,QAAIA,IAAI,CAACC,GAAT,EAAY;AAAEC,YAAI,CAACJ,IAALI,CAAU/f,IAAV+f,CAAeF,IAAfE;AAAoB,KAAlC,MACK,IAAIF,IAAI,CAACG,KAAT,EAAc;AAAED,YAAI,CAACH,MAALG,CAAY/f,IAAZ+f,CAAiBF,IAAjBE;AAAsB;AAC5C,GAHD,EAXyB,CAgB7B;;AACI,OAAKE,cAAL,GAAsB,CAAC,KAAKN,IAAL,CAAUO,IAAV,CAAc,UAACC,CAAD,EAAM;AACzC,QAAI,CAAC,aAAa/S,IA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","file":"forum.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./forum.js\");\n","export * from './src/forum';\n","export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  setPrototypeOf(subClass, superClass);\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","// ::- Persistent data structure representing an ordered mapping from\n// strings to values, with some convenient update methods.\nfunction OrderedMap(content) {\n  this.content = content;\n}\n\nOrderedMap.prototype = {\n  constructor: OrderedMap,\n\n  find: function(key) {\n    for (var i = 0; i < this.content.length; i += 2)\n      if (this.content[i] === key) return i\n    return -1\n  },\n\n  // :: (string)  ?any\n  // Retrieve the value stored under `key`, or return undefined when\n  // no such key exists.\n  get: function(key) {\n    var found = this.find(key);\n    return found == -1 ? undefined : this.content[found + 1]\n  },\n\n  // :: (string, any, ?string)  OrderedMap\n  // Create a new map by replacing the value of `key` with a new\n  // value, or adding a binding to the end of the map. If `newKey` is\n  // given, the key of the binding will be replaced with that key.\n  update: function(key, value, newKey) {\n    var self = newKey && newKey != key ? this.remove(newKey) : this;\n    var found = self.find(key), content = self.content.slice();\n    if (found == -1) {\n      content.push(newKey || key, value);\n    } else {\n      content[found + 1] = value;\n      if (newKey) content[found] = newKey;\n    }\n    return new OrderedMap(content)\n  },\n\n  // :: (string)  OrderedMap\n  // Return a map with the given key removed, if it existed.\n  remove: function(key) {\n    var found = this.find(key);\n    if (found == -1) return this\n    var content = this.content.slice();\n    content.splice(found, 2);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, any)  OrderedMap\n  // Add a new key to the start of the map.\n  addToStart: function(key, value) {\n    return new OrderedMap([key, value].concat(this.remove(key).content))\n  },\n\n  // :: (string, any)  OrderedMap\n  // Add a new key to the end of the map.\n  addToEnd: function(key, value) {\n    var content = this.remove(key).content.slice();\n    content.push(key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, string, any)  OrderedMap\n  // Add a key after the given key. If `place` is not found, the new\n  // key is added to the end.\n  addBefore: function(place, key, value) {\n    var without = this.remove(key), content = without.content.slice();\n    var found = without.find(place);\n    content.splice(found == -1 ? content.length : found, 0, key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: ((key: string, value: any))\n  // Call the given function for each key/value pair in the map, in\n  // order.\n  forEach: function(f) {\n    for (var i = 0; i < this.content.length; i += 2)\n      f(this.content[i], this.content[i + 1]);\n  },\n\n  // :: (union<Object, OrderedMap>)  OrderedMap\n  // Create a new map by prepending the keys in this map that don't\n  // appear in `map` before the keys in `map`.\n  prepend: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(map.content.concat(this.subtract(map).content))\n  },\n\n  // :: (union<Object, OrderedMap>)  OrderedMap\n  // Create a new map by appending the keys in this map that don't\n  // appear in `map` after the keys in `map`.\n  append: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(this.subtract(map).content.concat(map.content))\n  },\n\n  // :: (union<Object, OrderedMap>)  OrderedMap\n  // Create a map containing all the keys in this map that don't\n  // appear in `map`.\n  subtract: function(map) {\n    var result = this;\n    map = OrderedMap.from(map);\n    for (var i = 0; i < map.content.length; i += 2)\n      result = result.remove(map.content[i]);\n    return result\n  },\n\n  // :: number\n  // The amount of keys in this map.\n  get size() {\n    return this.content.length >> 1\n  }\n};\n\n// :: (?union<Object, OrderedMap>)  OrderedMap\n// Return a map with the given content. If null, create an empty\n// map. If given an ordered map, return that map itself. If given an\n// object, create a map from the object's properties.\nOrderedMap.from = function(value) {\n  if (value instanceof OrderedMap) return value\n  var content = [];\n  if (value) for (var prop in value) content.push(prop, value[prop]);\n  return new OrderedMap(content)\n};\n\nvar orderedmap = OrderedMap;\n\nexport default orderedmap;\n","import {joinPoint, canJoin, findWrapping, liftTarget, canSplit, ReplaceAroundStep, replaceStep} from \"prosemirror-transform\"\nimport {Slice, Fragment} from \"prosemirror-model\"\nimport {Selection, TextSelection, NodeSelection, AllSelection} from \"prosemirror-state\"\n\n// :: (EditorState, ?(tr: Transaction))  bool\n// Delete the selection, if there is one.\nexport function deleteSelection(state, dispatch) {\n  if (state.selection.empty) return false\n  if (dispatch) dispatch(state.tr.deleteSelection().scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView)  bool\n// If the selection is empty and at the start of a textblock, try to\n// reduce the distance between that block and the one before itif\n// there's a block directly before it that can be joined, join them.\n// If not, try to move the selected block closer to the next one in\n// the document structure by lifting it out of its parent or moving it\n// into a parent of the previous block. Will use the view for accurate\n// (bidi-aware) start-of-textblock detection if given.\nexport function joinBackward(state, dispatch, view) {\n  let {$cursor} = state.selection\n  if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state)\n                        : $cursor.parentOffset > 0))\n    return false\n\n  let $cut = findCutBefore($cursor)\n\n  // If there is no node before this, try to lift\n  if (!$cut) {\n    let range = $cursor.blockRange(), target = range && liftTarget(range)\n    if (target == null) return false\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n    return true\n  }\n\n  let before = $cut.nodeBefore\n  // Apply the joining algorithm\n  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))\n    return true\n\n  // If the node below has no content and the node above is\n  // selectable, delete the node below and select the one above.\n  if ($cursor.parent.content.size == 0 &&\n      (textblockAt(before, \"end\") || NodeSelection.isSelectable(before))) {\n    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty)\n    if (delStep.slice.size < delStep.to - delStep.from) {\n      if (dispatch) {\n        let tr = state.tr.step(delStep)\n        tr.setSelection(textblockAt(before, \"end\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1)\n                        : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize))\n        dispatch(tr.scrollIntoView())\n      }\n      return true\n    }\n  }\n\n  // If the node before is an atom, delete it\n  if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView())\n    return true\n  }\n\n  return false\n}\n\nfunction textblockAt(node, side, only) {\n  for (; node; node = (side == \"start\" ? node.firstChild : node.lastChild)) {\n    if (node.isTextblock) return true\n    if (only && node.childCount != 1) return false\n  }\n  return false\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView)  bool\n// When the selection is empty and at the start of a textblock, select\n// the node before that textblock, if possible. This is intended to be\n// bound to keys like backspace, after\n// [`joinBackward`](#commands.joinBackward) or other deleting\n// commands, as a fall-back behavior when the schema doesn't allow\n// deletion at the selected point.\nexport function selectNodeBackward(state, dispatch, view) {\n  let {$head, empty} = state.selection, $cut = $head\n  if (!empty) return false\n\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0) return false\n    $cut = findCutBefore($head)\n  }\n  let node = $cut && $cut.nodeBefore\n  if (!node || !NodeSelection.isSelectable(node)) return false\n  if (dispatch)\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView())\n  return true\n}\n\nfunction findCutBefore($pos) {\n  if (!$pos.parent.type.spec.isolating) for (let i = $pos.depth - 1; i >= 0; i--) {\n    if ($pos.index(i) > 0) return $pos.doc.resolve($pos.before(i + 1))\n    if ($pos.node(i).type.spec.isolating) break\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView)  bool\n// If the selection is empty and the cursor is at the end of a\n// textblock, try to reduce or remove the boundary between that block\n// and the one after it, either by joining them or by moving the other\n// block closer to this one in the tree structure. Will use the view\n// for accurate start-of-textblock detection if given.\nexport function joinForward(state, dispatch, view) {\n  let {$cursor} = state.selection\n  if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state)\n                        : $cursor.parentOffset < $cursor.parent.content.size))\n    return false\n\n  let $cut = findCutAfter($cursor)\n\n  // If there is no node after this, there's nothing to do\n  if (!$cut) return false\n\n  let after = $cut.nodeAfter\n  // Try the joining algorithm\n  if (deleteBarrier(state, $cut, dispatch)) return true\n\n  // If the node above has no content and the node below is\n  // selectable, delete the node above and select the one below.\n  if ($cursor.parent.content.size == 0 &&\n      (textblockAt(after, \"start\") || NodeSelection.isSelectable(after))) {\n    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty)\n    if (delStep.slice.size < delStep.to - delStep.from) {\n      if (dispatch) {\n        let tr = state.tr.step(delStep)\n        tr.setSelection(textblockAt(after, \"start\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1)\n                        : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)))\n        dispatch(tr.scrollIntoView())\n      }\n      return true\n    }\n  }\n\n  // If the next node is an atom, delete it\n  if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView())\n    return true\n  }\n\n  return false\n}\n\n// :: (EditorState, ?(tr: Transaction), ?EditorView)  bool\n// When the selection is empty and at the end of a textblock, select\n// the node coming after that textblock, if possible. This is intended\n// to be bound to keys like delete, after\n// [`joinForward`](#commands.joinForward) and similar deleting\n// commands, to provide a fall-back behavior when the schema doesn't\n// allow deletion at the selected point.\nexport function selectNodeForward(state, dispatch, view) {\n  let {$head, empty} = state.selection, $cut = $head\n  if (!empty) return false\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size)\n      return false\n    $cut = findCutAfter($head)\n  }\n  let node = $cut && $cut.nodeAfter\n  if (!node || !NodeSelection.isSelectable(node)) return false\n  if (dispatch)\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView())\n  return true\n}\n\nfunction findCutAfter($pos) {\n  if (!$pos.parent.type.spec.isolating) for (let i = $pos.depth - 1; i >= 0; i--) {\n    let parent = $pos.node(i)\n    if ($pos.index(i) + 1 < parent.childCount) return $pos.doc.resolve($pos.after(i + 1))\n    if (parent.type.spec.isolating) break\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction))  bool\n// Join the selected block or, if there is a text selection, the\n// closest ancestor block of the selection that can be joined, with\n// the sibling above it.\nexport function joinUp(state, dispatch) {\n  let sel = state.selection, nodeSel = sel instanceof NodeSelection, point\n  if (nodeSel) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.from)) return false\n    point = sel.from\n  } else {\n    point = joinPoint(state.doc, sel.from, -1)\n    if (point == null) return false\n  }\n  if (dispatch) {\n    let tr = state.tr.join(point)\n    if (nodeSel) tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction))  bool\n// Join the selected block, or the closest ancestor of the selection\n// that can be joined, with the sibling after it.\nexport function joinDown(state, dispatch) {\n  let sel = state.selection, point\n  if (sel instanceof NodeSelection) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.to)) return false\n    point = sel.to\n  } else {\n    point = joinPoint(state.doc, sel.to, 1)\n    if (point == null) return false\n  }\n  if (dispatch)\n    dispatch(state.tr.join(point).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction))  bool\n// Lift the selected block, or the closest ancestor block of the\n// selection that can be lifted, out of its parent node.\nexport function lift(state, dispatch) {\n  let {$from, $to} = state.selection\n  let range = $from.blockRange($to), target = range && liftTarget(range)\n  if (target == null) return false\n  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction))  bool\n// If the selection is in a node whose type has a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, replace the\n// selection with a newline character.\nexport function newlineInCode(state, dispatch) {\n  let {$head, $anchor} = state.selection\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false\n  if (dispatch) dispatch(state.tr.insertText(\"\\n\").scrollIntoView())\n  return true\n}\n\nfunction defaultBlockAt(match) {\n  for (let i = 0; i < match.edgeCount; i++) {\n    let {type} = match.edge(i)\n    if (type.isTextblock && !type.hasRequiredAttrs()) return type\n  }\n  return null\n}\n\n// :: (EditorState, ?(tr: Transaction))  bool\n// When the selection is in a node with a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, create a\n// default block after the code block, and move the cursor there.\nexport function exitCode(state, dispatch) {\n  let {$head, $anchor} = state.selection\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false\n  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after))\n  if (!above.canReplaceWith(after, after, type)) return false\n  if (dispatch) {\n    let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill())\n    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction))  bool\n// If a block node is selected, create an empty paragraph before (if\n// it is its parent's first child) or after it.\nexport function createParagraphNear(state, dispatch) {\n  let sel = state.selection, {$from, $to} = sel\n  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) return false\n  let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()))\n  if (!type || !type.isTextblock) return false\n  if (dispatch) {\n    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos\n    let tr = state.tr.insert(side, type.createAndFill())\n    tr.setSelection(TextSelection.create(tr.doc, side + 1))\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction))  bool\n// If the cursor is in an empty textblock that can be lifted, lift the\n// block.\nexport function liftEmptyBlock(state, dispatch) {\n  let {$cursor} = state.selection\n  if (!$cursor || $cursor.parent.content.size) return false\n  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n    let before = $cursor.before()\n    if (canSplit(state.doc, before)) {\n      if (dispatch) dispatch(state.tr.split(before).scrollIntoView())\n      return true\n    }\n  }\n  let range = $cursor.blockRange(), target = range && liftTarget(range)\n  if (target == null) return false\n  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction))  bool\n// Split the parent block of the selection. If the selection is a text\n// selection, also delete its content.\nexport function splitBlock(state, dispatch) {\n  let {$from, $to} = state.selection\n  if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(state.doc, $from.pos)) return false\n    if (dispatch) dispatch(state.tr.split($from.pos).scrollIntoView())\n    return true\n  }\n\n  if (!$from.parent.isBlock) return false\n\n  if (dispatch) {\n    let atEnd = $to.parentOffset == $to.parent.content.size\n    let tr = state.tr\n    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection) tr.deleteSelection()\n    let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)))\n    let types = atEnd && deflt ? [{type: deflt}] : null\n    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types)\n    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{type: deflt}])) {\n      types = [{type: deflt}]\n      can = true\n    }\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types)\n      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {\n        let first = tr.mapping.map($from.before()), $first = tr.doc.resolve(first)\n        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt))\n          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt)\n      }\n    }\n    dispatch(tr.scrollIntoView())\n  }\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction))  bool\n// Acts like [`splitBlock`](#commands.splitBlock), but without\n// resetting the set of active marks at the cursor.\nexport function splitBlockKeepMarks(state, dispatch) {\n  return splitBlock(state, dispatch && (tr => {\n    let marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks())\n    if (marks) tr.ensureMarks(marks)\n    dispatch(tr)\n  }))\n}\n\n// :: (EditorState, ?(tr: Transaction))  bool\n// Move the selection to the node wrapping the current selection, if\n// any. (Will not select the document node.)\nexport function selectParentNode(state, dispatch) {\n  let {$from, to} = state.selection, pos\n  let same = $from.sharedDepth(to)\n  if (same == 0) return false\n  pos = $from.before(same)\n  if (dispatch) dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)))\n  return true\n}\n\n// :: (EditorState, ?(tr: Transaction))  bool\n// Select the whole document.\nexport function selectAll(state, dispatch) {\n  if (dispatch) dispatch(state.tr.setSelection(new AllSelection(state.doc)))\n  return true\n}\n\nfunction joinMaybeClear(state, $pos, dispatch) {\n  let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index()\n  if (!before || !after || !before.type.compatibleContent(after.type)) return false\n  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n    if (dispatch) dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView())\n    return true\n  }\n  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))\n    return false\n  if (dispatch)\n    dispatch(state.tr\n             .clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount))\n             .join($pos.pos)\n             .scrollIntoView())\n  return true\n}\n\nfunction deleteBarrier(state, $cut, dispatch) {\n  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match\n  if (before.type.spec.isolating || after.type.spec.isolating) return false\n  if (joinMaybeClear(state, $cut, dispatch)) return true\n\n  let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1)\n  if (canDelAfter &&\n      (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) &&\n      match.matchType(conn[0] || after.type).validEnd) {\n    if (dispatch) {\n      let end = $cut.pos + after.nodeSize, wrap = Fragment.empty\n      for (let i = conn.length - 1; i >= 0; i--)\n        wrap = Fragment.from(conn[i].create(null, wrap))\n      wrap = Fragment.from(before.copy(wrap))\n      let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap, 1, 0), conn.length, true))\n      let joinAt = end + 2 * conn.length\n      if (canJoin(tr.doc, joinAt)) tr.join(joinAt)\n      dispatch(tr.scrollIntoView())\n    }\n    return true\n  }\n\n  let selAfter = Selection.findFrom($cut, 1)\n  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range)\n  if (target != null && target >= $cut.depth) {\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView())\n    return true\n  }\n\n  if (canDelAfter && textblockAt(after, \"start\", true) && textblockAt(before, \"end\")) {\n    let at = before, wrap = []\n    for (;;) {\n      wrap.push(at)\n      if (at.isTextblock) break\n      at = at.lastChild\n    }\n    let afterText = after, afterDepth = 1\n    for (; !afterText.isTextblock; afterText = afterText.firstChild) afterDepth++\n    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {\n      if (dispatch) {\n        let end = Fragment.empty\n        for (let i = wrap.length - 1; i >= 0; i--) end = Fragment.from(wrap[i].copy(end))\n        let tr = state.tr.step(new ReplaceAroundStep($cut.pos - wrap.length, $cut.pos + after.nodeSize,\n                                                     $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth,\n                                                     new Slice(end, wrap.length, 0), 0, true))\n        dispatch(tr.scrollIntoView())\n      }\n      return true\n    }\n  }\n\n  return false\n}\n\nfunction selectTextblockSide(side) {\n  return function(state, dispatch) {\n    let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to\n    let depth = $pos.depth\n    while ($pos.node(depth).isInline) {\n      if (!depth) return false\n      depth--\n    }\n    if (!$pos.node(depth).isTextblock) return false\n    if (dispatch)\n      dispatch(state.tr.setSelection(TextSelection.create(\n        state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))))\n    return true\n  }\n}\n\n// :: (EditorState, ?(tr: Transaction))  bool\n// Moves the cursor to the start of current text block.\nexport const selectTextblockStart = selectTextblockSide(-1)\n\n// :: (EditorState, ?(tr: Transaction))  bool\n// Moves the cursor to the end of current text block.\nexport const selectTextblockEnd = selectTextblockSide(1)\n\n// Parameterized commands\n\n// :: (NodeType, ?Object)  (state: EditorState, dispatch: ?(tr: Transaction))  bool\n// Wrap the selection in a node of the given type with the given\n// attributes.\nexport function wrapIn(nodeType, attrs) {\n  return function(state, dispatch) {\n    let {$from, $to} = state.selection\n    let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs)\n    if (!wrapping) return false\n    if (dispatch) dispatch(state.tr.wrap(range, wrapping).scrollIntoView())\n    return true\n  }\n}\n\n// :: (NodeType, ?Object)  (state: EditorState, dispatch: ?(tr: Transaction))  bool\n// Returns a command that tries to set the selected textblocks to the\n// given node type with the given attributes.\nexport function setBlockType(nodeType, attrs) {\n  return function(state, dispatch) {\n    let {from, to} = state.selection\n    let applicable = false\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (applicable) return false\n      if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) return\n      if (node.type == nodeType) {\n        applicable = true\n      } else {\n        let $pos = state.doc.resolve(pos), index = $pos.index()\n        applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType)\n      }\n    })\n    if (!applicable) return false\n    if (dispatch) dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView())\n    return true\n  }\n}\n\nfunction markApplies(doc, ranges, type) {\n  for (let i = 0; i < ranges.length; i++) {\n    let {$from, $to} = ranges[i]\n    let can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false\n    doc.nodesBetween($from.pos, $to.pos, node => {\n      if (can) return false\n      can = node.inlineContent && node.type.allowsMarkType(type)\n    })\n    if (can) return true\n  }\n  return false\n}\n\n// :: (MarkType, ?Object)  (state: EditorState, dispatch: ?(tr: Transaction))  bool\n// Create a command function that toggles the given mark with the\n// given attributes. Will return `false` when the current selection\n// doesn't support that mark. This will remove the mark if any marks\n// of that type exist in the selection, or add it otherwise. If the\n// selection is empty, this applies to the [stored\n// marks](#state.EditorState.storedMarks) instead of a range of the\n// document.\nexport function toggleMark(markType, attrs) {\n  return function(state, dispatch) {\n    let {empty, $cursor, ranges} = state.selection\n    if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType)) return false\n    if (dispatch) {\n      if ($cursor) {\n        if (markType.isInSet(state.storedMarks || $cursor.marks()))\n          dispatch(state.tr.removeStoredMark(markType))\n        else\n          dispatch(state.tr.addStoredMark(markType.create(attrs)))\n      } else {\n        let has = false, tr = state.tr\n        for (let i = 0; !has && i < ranges.length; i++) {\n          let {$from, $to} = ranges[i]\n          has = state.doc.rangeHasMark($from.pos, $to.pos, markType)\n        }\n        for (let i = 0; i < ranges.length; i++) {\n          let {$from, $to} = ranges[i]\n          if (has) {\n            tr.removeMark($from.pos, $to.pos, markType)\n          } else {\n            let from = $from.pos, to = $to.pos, start = $from.nodeAfter, end = $to.nodeBefore\n            let spaceStart = start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0\n            let spaceEnd = end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0\n            if (from + spaceStart < to) { from += spaceStart; to -= spaceEnd }\n            tr.addMark(from, to, markType.create(attrs))\n          }\n        }\n        dispatch(tr.scrollIntoView())\n      }\n    }\n    return true\n  }\n}\n\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n  return tr => {\n    if (!tr.isGeneric) return dispatch(tr)\n\n    let ranges = []\n    for (let i = 0; i < tr.mapping.maps.length; i++) {\n      let map = tr.mapping.maps[i]\n      for (let j = 0; j < ranges.length; j++)\n        ranges[j] = map.map(ranges[j])\n      map.forEach((_s, _e, from, to) => ranges.push(from, to))\n    }\n\n    // Figure out which joinable points exist inside those ranges,\n    // by checking all node boundaries in their parent nodes.\n    let joinable = []\n    for (let i = 0; i < ranges.length; i += 2) {\n      let from = ranges[i], to = ranges[i + 1]\n      let $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth)\n      for (let index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n        let after = parent.maybeChild(index)\n        if (!after) break\n        if (index && joinable.indexOf(pos) == -1) {\n          let before = parent.child(index - 1)\n          if (before.type == after.type && isJoinable(before, after))\n            joinable.push(pos)\n        }\n        pos += after.nodeSize\n      }\n    }\n    // Join the joinable points\n    joinable.sort((a, b) => a - b)\n    for (let i = joinable.length - 1; i >= 0; i--) {\n      if (canJoin(tr.doc, joinable[i])) tr.join(joinable[i])\n    }\n    dispatch(tr)\n  }\n}\n\n// :: ((state: EditorState, ?(tr: Transaction))  bool, union<(before: Node, after: Node)  bool, [string]>)  (state: EditorState, ?(tr: Transaction))  bool\n// Wrap a command so that, when it produces a transform that causes\n// two joinable nodes to end up next to each other, those are joined.\n// Nodes are considered joinable when they are of the same type and\n// when the `isJoinable` predicate returns true for them or, if an\n// array of strings was passed, if their node type name is in that\n// array.\nexport function autoJoin(command, isJoinable) {\n  if (Array.isArray(isJoinable)) {\n    let types = isJoinable\n    isJoinable = node => types.indexOf(node.type.name) > -1\n  }\n  return (state, dispatch, view) => command(state, dispatch && wrapDispatchForJoin(dispatch, isJoinable), view)\n}\n\n// :: (...[(EditorState, ?(tr: Transaction), ?EditorView)  bool])  (EditorState, ?(tr: Transaction), ?EditorView)  bool\n// Combine a number of command functions into a single function (which\n// calls them one by one until one returns true).\nexport function chainCommands(...commands) {\n  return function(state, dispatch, view) {\n    for (let i = 0; i < commands.length; i++)\n      if (commands[i](state, dispatch, view)) return true\n    return false\n  }\n}\n\nlet backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward)\nlet del = chainCommands(deleteSelection, joinForward, selectNodeForward)\n\n// :: Object\n// A basic keymap containing bindings not specific to any schema.\n// Binds the following keys (when multiple commands are listed, they\n// are chained with [`chainCommands`](#commands.chainCommands)):\n//\n// * **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n// * **Mod-Enter** to `exitCode`\n// * **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n// * **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-a** to `selectAll`\nexport let pcBaseKeymap = {\n  \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n  \"Mod-Enter\": exitCode,\n  \"Backspace\": backspace,\n  \"Mod-Backspace\": backspace,\n  \"Shift-Backspace\": backspace,\n  \"Delete\": del,\n  \"Mod-Delete\": del,\n  \"Mod-a\": selectAll\n}\n\n// :: Object\n// A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n// **Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n// **Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\n// Ctrl-Delete.\nexport let macBaseKeymap = {\n  \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n  \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n  \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n  \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Ctrl-a\": selectTextblockStart,\n  \"Ctrl-e\": selectTextblockEnd\n}\nfor (let key in pcBaseKeymap) macBaseKeymap[key] = pcBaseKeymap[key]\n\npcBaseKeymap.Home = selectTextblockStart\npcBaseKeymap.End = selectTextblockEnd\n\n// declare global: os, navigator\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)\n          : typeof os != \"undefined\" ? os.platform() == \"darwin\" : false\n\n// :: Object\n// Depending on the detected platform, this will hold\n// [`pcBasekeymap`](#commands.pcBaseKeymap) or\n// [`macBaseKeymap`](#commands.macBaseKeymap).\nexport let baseKeymap = mac ? macBaseKeymap : pcBaseKeymap\n","import {Plugin} from \"prosemirror-state\"\n\n// ::- Input rules are regular expressions describing a piece of text\n// that, when typed, causes something to happen. This might be\n// changing two dashes into an emdash, wrapping a paragraph starting\n// with `\"> \"` into a blockquote, or something entirely different.\nexport class InputRule {\n  // :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number)  ?Transaction>)\n  // Create an input rule. The rule applies when the user typed\n  // something and the text directly in front of the cursor matches\n  // `match`, which should end with `$`.\n  //\n  // The `handler` can be a string, in which case the matched text, or\n  // the first matched group in the regexp, is replaced by that\n  // string.\n  //\n  // Or a it can be a function, which will be called with the match\n  // array produced by\n  // [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),\n  // as well as the start and end of the matched range, and which can\n  // return a [transaction](#state.Transaction) that describes the\n  // rule's effect, or null to indicate the input was not handled.\n  constructor(match, handler) {\n    this.match = match\n    this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler\n  }\n}\n\nfunction stringHandler(string) {\n  return function(state, match, start, end) {\n    let insert = string\n    if (match[1]) {\n      let offset = match[0].lastIndexOf(match[1])\n      insert += match[0].slice(offset + match[1].length)\n      start += offset\n      let cutOff = start - end\n      if (cutOff > 0) {\n        insert = match[0].slice(offset - cutOff, offset) + insert\n        start = end\n      }\n    }\n    return state.tr.insertText(insert, start, end)\n  }\n}\n\nconst MAX_MATCH = 500\n\n// :: (config: {rules: [InputRule]})  Plugin\n// Create an input rules plugin. When enabled, it will cause text\n// input that matches any of the given rules to trigger the rule's\n// action.\nexport function inputRules({rules}) {\n  let plugin = new Plugin({\n    state: {\n      init() { return null },\n      apply(tr, prev) {\n        let stored = tr.getMeta(this)\n        if (stored) return stored\n        return tr.selectionSet || tr.docChanged ? null : prev\n      }\n    },\n\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run(view, from, to, text, rules, plugin)\n      },\n      handleDOMEvents: {\n        compositionend: (view) => {\n          setTimeout(() => {\n            let {$cursor} = view.state.selection\n            if ($cursor) run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin)\n          })\n        }\n      }\n    },\n\n    isInputRules: true\n  })\n  return plugin\n}\n\nfunction run(view, from, to, text, rules, plugin) {\n  if (view.composing) return false\n  let state = view.state, $from = state.doc.resolve(from)\n  if ($from.parent.type.spec.code) return false\n  let textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset,\n                                            null, \"\\ufffc\") + text\n  for (let i = 0; i < rules.length; i++) {\n    let match = rules[i].match.exec(textBefore)\n    let tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to)\n    if (!tr) continue\n    view.dispatch(tr.setMeta(plugin, {transform: tr, from, to, text}))\n    return true\n  }\n  return false\n}\n\n// :: (EditorState, ?(Transaction))  bool\n// This is a command that will undo an input rule, if applying such a\n// rule was the last thing that the user did.\nexport function undoInputRule(state, dispatch) {\n  let plugins = state.plugins\n  for (let i = 0; i < plugins.length; i++) {\n    let plugin = plugins[i], undoable\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        let tr = state.tr, toUndo = undoable.transform\n        for (let j = toUndo.steps.length - 1; j >= 0; j--)\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]))\n        if (undoable.text) {\n          let marks = tr.doc.resolve(undoable.from).marks()\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks))\n        } else {\n          tr.delete(undoable.from, undoable.to)\n        }\n        dispatch(tr)\n      }\n      return true\n    }\n  }\n  return false\n}\n","import {InputRule} from \"./inputrules\"\n\n// :: InputRule Converts double dashes to an emdash.\nexport const emDash = new InputRule(/--$/, \"\")\n// :: InputRule Converts three dots to an ellipsis character.\nexport const ellipsis = new InputRule(/\\.\\.\\.$/, \"\")\n// :: InputRule Smart opening double quotes.\nexport const openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"\")\n// :: InputRule Smart closing double quotes.\nexport const closeDoubleQuote = new InputRule(/\"$/, \"\")\n// :: InputRule Smart opening single quotes.\nexport const openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"\")\n// :: InputRule Smart closing single quotes.\nexport const closeSingleQuote = new InputRule(/'$/, \"\")\n\n// :: [InputRule] Smart-quote related input rules.\nexport const smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote]\n","import {InputRule} from \"./inputrules\"\nimport {findWrapping, canJoin} from \"prosemirror-transform\"\n\n// :: (RegExp, NodeType, ?union<Object, ([string])  ?Object>, ?([string], Node)  bool)  InputRule\n// Build an input rule for automatically wrapping a textblock when a\n// given string is typed. The `regexp` argument is\n// directly passed through to the `InputRule` constructor. You'll\n// probably want the regexp to start with `^`, so that the pattern can\n// only occur at the start of a textblock.\n//\n// `nodeType` is the type of node to wrap in. If it needs attributes,\n// you can either pass them directly, or pass a function that will\n// compute them from the regular expression match.\n//\n// By default, if there's a node with the same type above the newly\n// wrapped node, the rule will try to [join](#transform.Transform.join) those\n// two nodes. You can pass a join predicate, which takes a regular\n// expression match and the node before the wrapped node, and can\n// return a boolean to indicate whether a join should happen.\nexport function wrappingInputRule(regexp, nodeType, getAttrs, joinPredicate) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs\n    let tr = state.tr.delete(start, end)\n    let $start = tr.doc.resolve(start), range = $start.blockRange(), wrapping = range && findWrapping(range, nodeType, attrs)\n    if (!wrapping) return null\n    tr.wrap(range, wrapping)\n    let before = tr.doc.resolve(start - 1).nodeBefore\n    if (before && before.type == nodeType && canJoin(tr.doc, start - 1) &&\n        (!joinPredicate || joinPredicate(match, before)))\n      tr.join(start - 1)\n    return tr\n  })\n}\n\n// :: (RegExp, NodeType, ?union<Object, ([string])  ?Object>)  InputRule\n// Build an input rule that changes the type of a textblock when the\n// matched text is typed into it. You'll usually want to start your\n// regexp with `^` to that it is only matched at the start of a\n// textblock. The optional `getAttrs` parameter can be used to compute\n// the new node's attributes, and works the same as in the\n// `wrappingInputRule` function.\nexport function textblockTypeInputRule(regexp, nodeType, getAttrs) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    let $start = state.doc.resolve(start)\n    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs\n    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) return null\n    return state.tr\n      .delete(start, end)\n      .setBlockType(start, start, nodeType, attrs)\n  })\n}\n","export function findDiffStart(a, b, pos) {\n  for (let i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount)\n      return a.childCount == b.childCount ? null : pos\n\n    let childA = a.child(i), childB = b.child(i)\n    if (childA == childB) { pos += childA.nodeSize; continue }\n\n    if (!childA.sameMarkup(childB)) return pos\n\n    if (childA.isText && childA.text != childB.text) {\n      for (let j = 0; childA.text[j] == childB.text[j]; j++)\n        pos++\n      return pos\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffStart(childA.content, childB.content, pos + 1)\n      if (inner != null) return inner\n    }\n    pos += childA.nodeSize\n  }\n}\n\nexport function findDiffEnd(a, b, posA, posB) {\n  for (let iA = a.childCount, iB = b.childCount;;) {\n    if (iA == 0 || iB == 0)\n      return iA == iB ? null : {a: posA, b: posB}\n\n    let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize\n    if (childA == childB) {\n      posA -= size; posB -= size\n      continue\n    }\n\n    if (!childA.sameMarkup(childB)) return {a: posA, b: posB}\n\n    if (childA.isText && childA.text != childB.text) {\n      let same = 0, minSize = Math.min(childA.text.length, childB.text.length)\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++; posA--; posB--\n      }\n      return {a: posA, b: posB}\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1)\n      if (inner) return inner\n    }\n    posA -= size; posB -= size\n  }\n}\n","import {findDiffStart, findDiffEnd} from \"./diff\"\n\n// ::- A fragment represents a node's collection of child nodes.\n//\n// Like nodes, fragments are persistent data structures, and you\n// should not mutate them or their content. Rather, you create new\n// instances whenever needed. The API tries to make this easy.\nexport class Fragment {\n  constructor(content, size) {\n    this.content = content\n    // :: number\n    // The size of the fragment, which is the total of the size of its\n    // content nodes.\n    this.size = size || 0\n    if (size == null) for (let i = 0; i < content.length; i++)\n      this.size += content[i].nodeSize\n  }\n\n  // :: (number, number, (node: Node, start: number, parent: Node, index: number)  ?bool, ?number)\n  // Invoke a callback for all descendant nodes between the given two\n  // positions (relative to start of this fragment). Doesn't descend\n  // into a node when the callback returns `false`.\n  nodesBetween(from, to, f, nodeStart = 0, parent) {\n    for (let i = 0, pos = 0; pos < to; i++) {\n      let child = this.content[i], end = pos + child.nodeSize\n      if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {\n        let start = pos + 1\n        child.nodesBetween(Math.max(0, from - start),\n                           Math.min(child.content.size, to - start),\n                           f, nodeStart + start)\n      }\n      pos = end\n    }\n  }\n\n  // :: ((node: Node, pos: number, parent: Node)  ?bool)\n  // Call the given callback for every descendant node. The callback\n  // may return `false` to prevent traversal of a given node's children.\n  descendants(f) {\n    this.nodesBetween(0, this.size, f)\n  }\n\n  // :: (number, number, ?string, ?union<string, (leafNode: Node)  string>)  string\n  // Extract the text between `from` and `to`. See the same method on\n  // [`Node`](#model.Node.textBetween).\n  textBetween(from, to, blockSeparator, leafText) {\n    let text = \"\", separated = true\n    this.nodesBetween(from, to, (node, pos) => {\n      if (node.isText) {\n        text += node.text.slice(Math.max(from, pos) - pos, to - pos)\n        separated = !blockSeparator\n      } else if (node.isLeaf && leafText) {\n        text += typeof leafText === 'function' ? leafText(node): leafText\n        separated = !blockSeparator\n      } else if (!separated && node.isBlock) {\n        text += blockSeparator\n        separated = true\n      }\n    }, 0)\n    return text\n  }\n\n  // :: (Fragment)  Fragment\n  // Create a new fragment containing the combined content of this\n  // fragment and the other.\n  append(other) {\n    if (!other.size) return this\n    if (!this.size) return other\n    let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0\n    if (last.isText && last.sameMarkup(first)) {\n      content[content.length - 1] = last.withText(last.text + first.text)\n      i = 1\n    }\n    for (; i < other.content.length; i++) content.push(other.content[i])\n    return new Fragment(content, this.size + other.size)\n  }\n\n  // :: (number, ?number)  Fragment\n  // Cut out the sub-fragment between the two given positions.\n  cut(from, to) {\n    if (to == null) to = this.size\n    if (from == 0 && to == this.size) return this\n    let result = [], size = 0\n    if (to > from) for (let i = 0, pos = 0; pos < to; i++) {\n      let child = this.content[i], end = pos + child.nodeSize\n      if (end > from) {\n        if (pos < from || end > to) {\n          if (child.isText)\n            child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos))\n          else\n            child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1))\n        }\n        result.push(child)\n        size += child.nodeSize\n      }\n      pos = end\n    }\n    return new Fragment(result, size)\n  }\n\n  cutByIndex(from, to) {\n    if (from == to) return Fragment.empty\n    if (from == 0 && to == this.content.length) return this\n    return new Fragment(this.content.slice(from, to))\n  }\n\n  // :: (number, Node)  Fragment\n  // Create a new fragment in which the node at the given index is\n  // replaced by the given node.\n  replaceChild(index, node) {\n    let current = this.content[index]\n    if (current == node) return this\n    let copy = this.content.slice()\n    let size = this.size + node.nodeSize - current.nodeSize\n    copy[index] = node\n    return new Fragment(copy, size)\n  }\n\n  // : (Node)  Fragment\n  // Create a new fragment by prepending the given node to this\n  // fragment.\n  addToStart(node) {\n    return new Fragment([node].concat(this.content), this.size + node.nodeSize)\n  }\n\n  // : (Node)  Fragment\n  // Create a new fragment by appending the given node to this\n  // fragment.\n  addToEnd(node) {\n    return new Fragment(this.content.concat(node), this.size + node.nodeSize)\n  }\n\n  // :: (Fragment)  bool\n  // Compare this fragment to another one.\n  eq(other) {\n    if (this.content.length != other.content.length) return false\n    for (let i = 0; i < this.content.length; i++)\n      if (!this.content[i].eq(other.content[i])) return false\n    return true\n  }\n\n  // :: ?Node\n  // The first child of the fragment, or `null` if it is empty.\n  get firstChild() { return this.content.length ? this.content[0] : null }\n\n  // :: ?Node\n  // The last child of the fragment, or `null` if it is empty.\n  get lastChild() { return this.content.length ? this.content[this.content.length - 1] : null }\n\n  // :: number\n  // The number of child nodes in this fragment.\n  get childCount() { return this.content.length }\n\n  // :: (number)  Node\n  // Get the child node at the given index. Raise an error when the\n  // index is out of range.\n  child(index) {\n    let found = this.content[index]\n    if (!found) throw new RangeError(\"Index \" + index + \" out of range for \" + this)\n    return found\n  }\n\n  // :: (number)  ?Node\n  // Get the child node at the given index, if it exists.\n  maybeChild(index) {\n    return this.content[index]\n  }\n\n  // :: ((node: Node, offset: number, index: number))\n  // Call `f` for every child node, passing the node, its offset\n  // into this parent node, and its index.\n  forEach(f) {\n    for (let i = 0, p = 0; i < this.content.length; i++) {\n      let child = this.content[i]\n      f(child, p, i)\n      p += child.nodeSize\n    }\n  }\n\n  // :: (Fragment)  ?number\n  // Find the first position at which this fragment and another\n  // fragment differ, or `null` if they are the same.\n  findDiffStart(other, pos = 0) {\n    return findDiffStart(this, other, pos)\n  }\n\n  // :: (Fragment)  ?{a: number, b: number}\n  // Find the first position, searching from the end, at which this\n  // fragment and the given fragment differ, or `null` if they are the\n  // same. Since this position will not be the same in both nodes, an\n  // object with two separate positions is returned.\n  findDiffEnd(other, pos = this.size, otherPos = other.size) {\n    return findDiffEnd(this, other, pos, otherPos)\n  }\n\n  // : (number, ?number)  {index: number, offset: number}\n  // Find the index and inner offset corresponding to a given relative\n  // position in this fragment. The result object will be reused\n  // (overwritten) the next time the function is called. (Not public.)\n  findIndex(pos, round = -1) {\n    if (pos == 0) return retIndex(0, pos)\n    if (pos == this.size) return retIndex(this.content.length, pos)\n    if (pos > this.size || pos < 0) throw new RangeError(`Position ${pos} outside of fragment (${this})`)\n    for (let i = 0, curPos = 0;; i++) {\n      let cur = this.child(i), end = curPos + cur.nodeSize\n      if (end >= pos) {\n        if (end == pos || round > 0) return retIndex(i + 1, end)\n        return retIndex(i, curPos)\n      }\n      curPos = end\n    }\n  }\n\n  // :: ()  string\n  // Return a debugging string that describes this fragment.\n  toString() { return \"<\" + this.toStringInner() + \">\" }\n\n  toStringInner() { return this.content.join(\", \") }\n\n  // :: ()  ?Object\n  // Create a JSON-serializeable representation of this fragment.\n  toJSON() {\n    return this.content.length ? this.content.map(n => n.toJSON()) : null\n  }\n\n  // :: (Schema, ?Object)  Fragment\n  // Deserialize a fragment from its JSON representation.\n  static fromJSON(schema, value) {\n    if (!value) return Fragment.empty\n    if (!Array.isArray(value)) throw new RangeError(\"Invalid input for Fragment.fromJSON\")\n    return new Fragment(value.map(schema.nodeFromJSON))\n  }\n\n  // :: ([Node])  Fragment\n  // Build a fragment from an array of nodes. Ensures that adjacent\n  // text nodes with the same marks are joined together.\n  static fromArray(array) {\n    if (!array.length) return Fragment.empty\n    let joined, size = 0\n    for (let i = 0; i < array.length; i++) {\n      let node = array[i]\n      size += node.nodeSize\n      if (i && node.isText && array[i - 1].sameMarkup(node)) {\n        if (!joined) joined = array.slice(0, i)\n        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text)\n      } else if (joined) {\n        joined.push(node)\n      }\n    }\n    return new Fragment(joined || array, size)\n  }\n\n  // :: (?union<Fragment, Node, [Node]>)  Fragment\n  // Create a fragment from something that can be interpreted as a set\n  // of nodes. For `null`, it returns the empty fragment. For a\n  // fragment, the fragment itself. For a node or array of nodes, a\n  // fragment containing those nodes.\n  static from(nodes) {\n    if (!nodes) return Fragment.empty\n    if (nodes instanceof Fragment) return nodes\n    if (Array.isArray(nodes)) return this.fromArray(nodes)\n    if (nodes.attrs) return new Fragment([nodes], nodes.nodeSize)\n    throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" +\n                         (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"))\n  }\n}\n\nconst found = {index: 0, offset: 0}\nfunction retIndex(index, offset) {\n  found.index = index\n  found.offset = offset\n  return found\n}\n\n// :: Fragment\n// An empty fragment. Intended to be reused whenever a node doesn't\n// contain anything (rather than allocating a new empty fragment for\n// each leaf node).\nFragment.empty = new Fragment([], 0)\n","export function compareDeep(a, b) {\n  if (a === b) return true\n  if (!(a && typeof a == \"object\") ||\n      !(b && typeof b == \"object\")) return false\n  let array = Array.isArray(a)\n  if (Array.isArray(b) != array) return false\n  if (array) {\n    if (a.length != b.length) return false\n    for (let i = 0; i < a.length; i++) if (!compareDeep(a[i], b[i])) return false\n  } else {\n    for (let p in a) if (!(p in b) || !compareDeep(a[p], b[p])) return false\n    for (let p in b) if (!(p in a)) return false\n  }\n  return true\n}\n","import {MarkType, Slice, Fragment} from \"prosemirror-model\"\n\nimport {Transform} from \"./transform\"\nimport {AddMarkStep, RemoveMarkStep} from \"./mark_step\"\nimport {ReplaceStep} from \"./replace_step\"\n\n// :: (number, number, Mark)  this\n// Add the given mark to the inline content between `from` and `to`.\nTransform.prototype.addMark = function(from, to, mark) {\n  let removed = [], added = [], removing = null, adding = null\n  this.doc.nodesBetween(from, to, (node, pos, parent) => {\n    if (!node.isInline) return\n    let marks = node.marks\n    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n      let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to)\n      let newSet = mark.addToSet(marks)\n\n      for (let i = 0; i < marks.length; i++) {\n        if (!marks[i].isInSet(newSet)) {\n          if (removing && removing.to == start && removing.mark.eq(marks[i]))\n            removing.to = end\n          else\n            removed.push(removing = new RemoveMarkStep(start, end, marks[i]))\n        }\n      }\n\n      if (adding && adding.to == start)\n        adding.to = end\n      else\n        added.push(adding = new AddMarkStep(start, end, mark))\n    }\n  })\n\n  removed.forEach(s => this.step(s))\n  added.forEach(s => this.step(s))\n  return this\n}\n\n// :: (number, number, ?union<Mark, MarkType>)  this\n// Remove marks from inline nodes between `from` and `to`. When `mark`\n// is a single mark, remove precisely that mark. When it is a mark type,\n// remove all marks of that type. When it is null, remove all marks of\n// any type.\nTransform.prototype.removeMark = function(from, to, mark = null) {\n  let matched = [], step = 0\n  this.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isInline) return\n    step++\n    let toRemove = null\n    if (mark instanceof MarkType) {\n      let set = node.marks, found\n      while (found = mark.isInSet(set)) {\n        ;(toRemove || (toRemove = [])).push(found)\n        set = found.removeFromSet(set)\n      }\n    } else if (mark) {\n      if (mark.isInSet(node.marks)) toRemove = [mark]\n    } else {\n      toRemove = node.marks\n    }\n    if (toRemove && toRemove.length) {\n      let end = Math.min(pos + node.nodeSize, to)\n      for (let i = 0; i < toRemove.length; i++) {\n        let style = toRemove[i], found\n        for (let j = 0; j < matched.length; j++) {\n          let m = matched[j]\n          if (m.step == step - 1 && style.eq(matched[j].style)) found = m\n        }\n        if (found) {\n          found.to = end\n          found.step = step\n        } else {\n          matched.push({style, from: Math.max(pos, from), to: end, step})\n        }\n      }\n    }\n  })\n  matched.forEach(m => this.step(new RemoveMarkStep(m.from, m.to, m.style)))\n  return this\n}\n\n// :: (number, NodeType, ?ContentMatch)  this\n// Removes all marks and nodes from the content of the node at `pos`\n// that don't match the given new parent node type. Accepts an\n// optional starting [content match](#model.ContentMatch) as third\n// argument.\nTransform.prototype.clearIncompatible = function(pos, parentType, match = parentType.contentMatch) {\n  let node = this.doc.nodeAt(pos)\n  let delSteps = [], cur = pos + 1\n  for (let i = 0; i < node.childCount; i++) {\n    let child = node.child(i), end = cur + child.nodeSize\n    let allowed = match.matchType(child.type, child.attrs)\n    if (!allowed) {\n      delSteps.push(new ReplaceStep(cur, end, Slice.empty))\n    } else {\n      match = allowed\n      for (let j = 0; j < child.marks.length; j++) if (!parentType.allowsMarkType(child.marks[j].type))\n        this.step(new RemoveMarkStep(cur, end, child.marks[j]))\n    }\n    cur = end\n  }\n  if (!match.validEnd) {\n    let fill = match.fillBefore(Fragment.empty, true)\n    this.replace(cur, cur, new Slice(fill, 0, 0))\n  }\n  for (let i = delSteps.length - 1; i >= 0; i--) this.step(delSteps[i])\n  return this\n}\n","import {Fragment, Slice} from \"prosemirror-model\"\n\nimport {ReplaceStep, ReplaceAroundStep} from \"./replace_step\"\nimport {Transform} from \"./transform\"\nimport {insertPoint} from \"./structure\"\n\n// :: (Node, number, ?number, ?Slice)  ?Step\n// Fit a slice into a given position in the document, producing a\n// [step](#transform.Step) that inserts it. Will return null if\n// there's no meaningful way to insert the slice here, or inserting it\n// would be a no-op (an empty slice over an empty range).\nexport function replaceStep(doc, from, to = from, slice = Slice.empty) {\n  if (from == to && !slice.size) return null\n\n  let $from = doc.resolve(from), $to = doc.resolve(to)\n  // Optimization -- avoid work if it's obvious that it's not needed.\n  if (fitsTrivially($from, $to, slice)) return new ReplaceStep(from, to, slice)\n  return new Fitter($from, $to, slice).fit()\n}\n\n// :: (number, ?number, ?Slice)  this\n// Replace the part of the document between `from` and `to` with the\n// given `slice`.\nTransform.prototype.replace = function(from, to = from, slice = Slice.empty) {\n  let step = replaceStep(this.doc, from, to, slice)\n  if (step) this.step(step)\n  return this\n}\n\n// :: (number, number, union<Fragment, Node, [Node]>)  this\n// Replace the given range with the given content, which may be a\n// fragment, node, or array of nodes.\nTransform.prototype.replaceWith = function(from, to, content) {\n  return this.replace(from, to, new Slice(Fragment.from(content), 0, 0))\n}\n\n// :: (number, number)  this\n// Delete the content between the given positions.\nTransform.prototype.delete = function(from, to) {\n  return this.replace(from, to, Slice.empty)\n}\n\n// :: (number, union<Fragment, Node, [Node]>)  this\n// Insert the given content at the given position.\nTransform.prototype.insert = function(pos, content) {\n  return this.replaceWith(pos, pos, content)\n}\n\nfunction fitsTrivially($from, $to, slice) {\n  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&\n    $from.parent.canReplace($from.index(), $to.index(), slice.content)\n}\n\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn't\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\nclass Fitter {\n  constructor($from, $to, slice) {\n    this.$to = $to\n    this.$from = $from\n    this.unplaced = slice\n\n    this.frontier = []\n    for (let i = 0; i <= $from.depth; i++) {\n      let node = $from.node(i)\n      this.frontier.push({\n        type: node.type,\n        match: node.contentMatchAt($from.indexAfter(i))\n      })\n    }\n\n    this.placed = Fragment.empty\n    for (let i = $from.depth; i > 0; i--)\n      this.placed = Fragment.from($from.node(i).copy(this.placed))\n  }\n\n  get depth() { return this.frontier.length - 1 }\n\n  fit() {\n    // As long as there's unplaced content, try to place some of it.\n    // If that fails, either increase the open score of the unplaced\n    // slice, or drop nodes from it, and then try again.\n    while (this.unplaced.size) {\n      let fit = this.findFittable()\n      if (fit) this.placeNodes(fit)\n      else this.openMore() || this.dropNode()\n    }\n    // When there's inline content directly after the frontier _and_\n    // directly after `this.$to`, we must generate a `ReplaceAround`\n    // step that pulls that content into the node after the frontier.\n    // That means the fitting must be done to the end of the textblock\n    // node after `this.$to`, not `this.$to` itself.\n    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth\n    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline))\n    if (!$to) return null\n\n    // If closing to `$to` succeeded, create a step\n    let content = this.placed, openStart = $from.depth, openEnd = $to.depth\n    while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes\n      content = content.firstChild.content\n      openStart--; openEnd--\n    }\n    let slice = new Slice(content, openStart, openEnd)\n    if (moveInline > -1)\n      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize)\n    if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps\n      return new ReplaceStep($from.pos, $to.pos, slice)\n  }\n\n  // Find a position on the start spine of `this.unplaced` that has\n  // content that can be moved somewhere on the frontier. Returns two\n  // depths, one for the slice and one for the frontier.\n  findFittable() {\n    // Only try wrapping nodes (pass 2) after finding a place without\n    // wrapping failed.\n    for (let pass = 1; pass <= 2; pass++) {\n      for (let sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n        let fragment, parent\n        if (sliceDepth) {\n          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild\n          fragment = parent.content\n        } else {\n          fragment = this.unplaced.content\n        }\n        let first = fragment.firstChild\n        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n          let {type, match} = this.frontier[frontierDepth], wrap, inject\n          // In pass 1, if the next node matches, or there is no next\n          // node but the parents look compatible, we've found a\n          // place.\n          if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false))\n                            : type.compatibleContent(parent.type)))\n            return {sliceDepth, frontierDepth, parent, inject}\n          // In pass 2, look for a set of wrapping nodes that make\n          // `first` fit here.\n          else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))\n            return {sliceDepth, frontierDepth, parent, wrap}\n          // Don't continue looking further up if the parent node\n          // would fit here.\n          if (parent && match.matchType(parent.type)) break\n        }\n      }\n    }\n  }\n\n  openMore() {\n    let {content, openStart, openEnd} = this.unplaced\n    let inner = contentAt(content, openStart)\n    if (!inner.childCount || inner.firstChild.isLeaf) return false\n    this.unplaced = new Slice(content, openStart + 1,\n                              Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0))\n    return true\n  }\n\n  dropNode() {\n    let {content, openStart, openEnd} = this.unplaced\n    let inner = contentAt(content, openStart)\n    if (inner.childCount <= 1 && openStart > 0) {\n      let openAtEnd = content.size - openStart <= openStart + inner.size\n      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1,\n                                openAtEnd ? openStart - 1 : openEnd)\n    } else {\n      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd)\n    }\n  }\n\n  // : ({sliceDepth: number, frontierDepth: number, parent: ?Node, wrap: ?[NodeType], inject: ?Fragment})\n  // Move content from the unplaced slice at `sliceDepth` to the\n  // frontier node at `frontierDepth`. Close that frontier node when\n  // applicable.\n  placeNodes({sliceDepth, frontierDepth, parent, inject, wrap}) {\n    while (this.depth > frontierDepth) this.closeFrontierNode()\n    if (wrap) for (let i = 0; i < wrap.length; i++) this.openFrontierNode(wrap[i])\n\n    let slice = this.unplaced, fragment = parent ? parent.content : slice.content\n    let openStart = slice.openStart - sliceDepth\n    let taken = 0, add = []\n    let {match, type} = this.frontier[frontierDepth]\n    if (inject) {\n      for (let i = 0; i < inject.childCount; i++) add.push(inject.child(i))\n      match = match.matchFragment(inject)\n    }\n    // Computes the amount of (end) open nodes at the end of the\n    // fragment. When 0, the parent is open, but no more. When\n    // negative, nothing is open.\n    let openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd)\n    // Scan over the fragment, fitting as many child nodes as\n    // possible.\n    while (taken < fragment.childCount) {\n      let next = fragment.child(taken), matches = match.matchType(next.type)\n      if (!matches) break\n      taken++\n      if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes\n        match = matches\n        add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0,\n                                taken == fragment.childCount ? openEndCount : -1))\n      }\n    }\n    let toEnd = taken == fragment.childCount\n    if (!toEnd) openEndCount = -1\n\n    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add))\n    this.frontier[frontierDepth].match = match\n\n    // If the parent types match, and the entire node was moved, and\n    // it's not open, close this frontier node right away.\n    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)\n      this.closeFrontierNode()\n\n    // Add new frontier nodes for any open nodes at the end.\n    for (let i = 0, cur = fragment; i < openEndCount; i++) {\n      let node = cur.lastChild\n      this.frontier.push({type: node.type, match: node.contentMatchAt(node.childCount)})\n      cur = node.content\n    }\n\n    // Update `this.unplaced`. Drop the entire node from which we\n    // placed it we got to its end, otherwise just drop the placed\n    // nodes.\n    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)\n      : sliceDepth == 0 ? Slice.empty\n      : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1),\n                  sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1)\n  }\n\n  mustMoveInline() {\n    if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) return -1\n    let top = this.frontier[this.depth], level\n    if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||\n        (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)) return -1\n\n    let {depth} = this.$to, after = this.$to.after(depth)\n    while (depth > 1 && after == this.$to.end(--depth)) ++after\n    return after\n  }\n\n  findCloseLevel($to) {\n    scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n      let {match, type} = this.frontier[i]\n      let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1))\n      let fit = contentAfterFits($to, i, type, match, dropInner)\n      if (!fit) continue\n      for (let d = i - 1; d >= 0; d--) {\n        let {match, type} = this.frontier[d]\n        let matches = contentAfterFits($to, d, type, match, true)\n        if (!matches || matches.childCount) continue scan\n      }\n      return {depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to}\n    }\n  }\n\n  close($to) {\n    let close = this.findCloseLevel($to)\n    if (!close) return null\n\n    while (this.depth > close.depth) this.closeFrontierNode()\n    if (close.fit.childCount) this.placed = addToFragment(this.placed, close.depth, close.fit)\n    $to = close.move\n    for (let d = close.depth + 1; d <= $to.depth; d++) {\n      let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d))\n      this.openFrontierNode(node.type, node.attrs, add)\n    }\n    return $to\n  }\n\n  openFrontierNode(type, attrs, content) {\n    let top = this.frontier[this.depth]\n    top.match = top.match.matchType(type)\n    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)))\n    this.frontier.push({type, match: type.contentMatch})\n  }\n\n  closeFrontierNode() {\n    let open = this.frontier.pop()\n    let add = open.match.fillBefore(Fragment.empty, true)\n    if (add.childCount) this.placed = addToFragment(this.placed, this.frontier.length, add)\n  }\n}\n\nfunction dropFromFragment(fragment, depth, count) {\n  if (depth == 0) return fragment.cutByIndex(count)\n  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)))\n}\n\nfunction addToFragment(fragment, depth, content) {\n  if (depth == 0) return fragment.append(content)\n  return fragment.replaceChild(fragment.childCount - 1,\n                               fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)))\n}\n\nfunction contentAt(fragment, depth) {\n  for (let i = 0; i < depth; i++) fragment = fragment.firstChild.content\n  return fragment\n}\n\nfunction closeNodeStart(node, openStart, openEnd) {\n  if (openStart <= 0) return node\n  let frag = node.content\n  if (openStart > 1)\n    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0))\n  if (openStart > 0) {\n    frag = node.type.contentMatch.fillBefore(frag).append(frag)\n    if (openEnd <= 0) frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true))\n  }\n  return node.copy(frag)\n}\n\nfunction contentAfterFits($to, depth, type, match, open) {\n  let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth)\n  if (index == node.childCount && !type.compatibleContent(node.type)) return null\n  let fit = match.fillBefore(node.content, true, index)\n  return fit && !invalidMarks(type, node.content, index) ? fit : null\n}\n\nfunction invalidMarks(type, fragment, start) {\n  for (let i = start; i < fragment.childCount; i++)\n    if (!type.allowsMarks(fragment.child(i).marks)) return true\n  return false\n}\n\n// :: (number, number, Slice)  this\n// Replace a range of the document with a given slice, using `from`,\n// `to`, and the slice's [`openStart`](#model.Slice.openStart) property\n// as hints, rather than fixed start and end points. This method may\n// grow the replaced area or close open nodes in the slice in order to\n// get a fit that is more in line with WYSIWYG expectations, by\n// dropping fully covered parent nodes of the replaced region when\n// they are marked [non-defining](#model.NodeSpec.defining), or\n// including an open parent node from the slice that _is_ marked as\n// [defining](#model.NodeSpec.defining).\n//\n// This is the method, for example, to handle paste. The similar\n// [`replace`](#transform.Transform.replace) method is a more\n// primitive tool which will _not_ move the start and end of its given\n// range, and is useful in situations where you need more precise\n// control over what happens.\nTransform.prototype.replaceRange = function(from, to, slice) {\n  if (!slice.size) return this.deleteRange(from, to)\n\n  let $from = this.doc.resolve(from), $to = this.doc.resolve(to)\n  if (fitsTrivially($from, $to, slice))\n    return this.step(new ReplaceStep(from, to, slice))\n\n  let targetDepths = coveredDepths($from, this.doc.resolve(to))\n  // Can't replace the whole document, so remove 0 if it's present\n  if (targetDepths[targetDepths.length - 1] == 0) targetDepths.pop()\n  // Negative numbers represent not expansion over the whole node at\n  // that depth, but replacing from $from.before(-D) to $to.pos.\n  let preferredTarget = -($from.depth + 1)\n  targetDepths.unshift(preferredTarget)\n  // This loop picks a preferred target depth, if one of the covering\n  // depths is not outside of a defining node, and adds negative\n  // depths for any depth that has $from at its start and does not\n  // cross a defining node.\n  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n    let spec = $from.node(d).type.spec\n    if (spec.defining || spec.isolating) break\n    if (targetDepths.indexOf(d) > -1) preferredTarget = d\n    else if ($from.before(d) == pos) targetDepths.splice(1, 0, -d)\n  }\n  // Try to fit each possible depth of the slice into each possible\n  // target depth, starting with the preferred depths.\n  let preferredTargetIndex = targetDepths.indexOf(preferredTarget)\n\n  let leftNodes = [], preferredDepth = slice.openStart\n  for (let content = slice.content, i = 0;; i++) {\n    let node = content.firstChild\n    leftNodes.push(node)\n    if (i == slice.openStart) break\n    content = node.content\n  }\n  // Back up if the node directly above openStart, or the node above\n  // that separated only by a non-defining textblock node, is defining.\n  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining &&\n      $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type)\n    preferredDepth -= 1\n  else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining &&\n           $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type)\n    preferredDepth -= 2\n\n  for (let j = slice.openStart; j >= 0; j--) {\n    let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1)\n    let insert = leftNodes[openDepth]\n    if (!insert) continue\n    for (let i = 0; i < targetDepths.length; i++) {\n      // Loop over possible expansion levels, starting with the\n      // preferred one\n      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true\n      if (targetDepth < 0) { expand = false; targetDepth = -targetDepth }\n      let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1)\n      if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n        return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to,\n                            new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth),\n                                      openDepth, slice.openEnd))\n    }\n  }\n\n  let startSteps = this.steps.length\n  for (let i = targetDepths.length - 1; i >= 0; i--) {\n    this.replace(from, to, slice)\n    if (this.steps.length > startSteps) break\n    let depth = targetDepths[i]\n    if (depth < 0) continue\n    from = $from.before(depth); to = $to.after(depth)\n  }\n  return this\n}\n\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n  if (depth < oldOpen) {\n    let first = fragment.firstChild\n    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)))\n  }\n  if (depth > newOpen) {\n    let match = parent.contentMatchAt(0)\n    let start = match.fillBefore(fragment).append(fragment)\n    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true))\n  }\n  return fragment\n}\n\n// :: (number, number, Node)  this\n// Replace the given range with a node, but use `from` and `to` as\n// hints, rather than precise positions. When from and to are the same\n// and are at the start or end of a parent node in which the given\n// node doesn't fit, this method may _move_ them out towards a parent\n// that does allow the given node to be placed. When the given range\n// completely covers a parent node, this method may completely replace\n// that parent node.\nTransform.prototype.replaceRangeWith = function(from, to, node) {\n  if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {\n    let point = insertPoint(this.doc, from, node.type)\n    if (point != null) from = to = point\n  }\n  return this.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0))\n}\n\n// :: (number, number)  this\n// Delete the given range, expanding it to cover fully covered\n// parent nodes until a valid replace is found.\nTransform.prototype.deleteRange = function(from, to) {\n  let $from = this.doc.resolve(from), $to = this.doc.resolve(to)\n  let covered = coveredDepths($from, $to)\n  for (let i = 0; i < covered.length; i++) {\n    let depth = covered[i], last = i == covered.length - 1\n    if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)\n      return this.delete($from.start(depth), $to.end(depth))\n    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n      return this.delete($from.before(depth), $to.after(depth))\n  }\n  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {\n    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)\n      return this.delete($from.before(d), to)\n  }\n  return this.delete(from, to)\n}\n\n// : (ResolvedPos, ResolvedPos)  [number]\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\nfunction coveredDepths($from, $to) {\n  let result = [], minDepth = Math.min($from.depth, $to.depth)\n  for (let d = minDepth; d >= 0; d--) {\n    let start = $from.start(d)\n    if (start < $from.pos - ($from.depth - d) ||\n        $to.end(d) > $to.pos + ($to.depth - d) ||\n        $from.node(d).type.spec.isolating ||\n        $to.node(d).type.spec.isolating) break\n    if (start == $to.start(d) ||\n        (d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent &&\n         d && $to.start(d - 1) == start - 1))\n      result.push(d)\n  }\n  return result\n}\n","import {Mark} from \"./mark\"\n\n// ::- You can [_resolve_](#model.Node.resolve) a position to get more\n// information about it. Objects of this class represent such a\n// resolved position, providing various pieces of context information,\n// and some helper methods.\n//\n// Throughout this interface, methods that take an optional `depth`\n// parameter will interpret undefined as `this.depth` and negative\n// numbers as `this.depth + value`.\nexport class ResolvedPos {\n  constructor(pos, path, parentOffset) {\n    // :: number The position that was resolved.\n    this.pos = pos\n    this.path = path\n    // :: number\n    // The number of levels the parent node is from the root. If this\n    // position points directly into the root node, it is 0. If it\n    // points into a top-level paragraph, 1, and so on.\n    this.depth = path.length / 3 - 1\n    // :: number The offset this position has into its parent node.\n    this.parentOffset = parentOffset\n  }\n\n  resolveDepth(val) {\n    if (val == null) return this.depth\n    if (val < 0) return this.depth + val\n    return val\n  }\n\n  // :: Node\n  // The parent node that the position points into. Note that even if\n  // a position points into a text node, that node is not considered\n  // the parenttext nodes are flat in this model, and have no content.\n  get parent() { return this.node(this.depth) }\n\n  // :: Node\n  // The root node in which the position was resolved.\n  get doc() { return this.node(0) }\n\n  // :: (?number)  Node\n  // The ancestor node at the given level. `p.node(p.depth)` is the\n  // same as `p.parent`.\n  node(depth) { return this.path[this.resolveDepth(depth) * 3] }\n\n  // :: (?number)  number\n  // The index into the ancestor at the given level. If this points at\n  // the 3rd node in the 2nd paragraph on the top level, for example,\n  // `p.index(0)` is 1 and `p.index(1)` is 2.\n  index(depth) { return this.path[this.resolveDepth(depth) * 3 + 1] }\n\n  // :: (?number)  number\n  // The index pointing after this position into the ancestor at the\n  // given level.\n  indexAfter(depth) {\n    depth = this.resolveDepth(depth)\n    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1)\n  }\n\n  // :: (?number)  number\n  // The (absolute) position at the start of the node at the given\n  // level.\n  start(depth) {\n    depth = this.resolveDepth(depth)\n    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n  }\n\n  // :: (?number)  number\n  // The (absolute) position at the end of the node at the given\n  // level.\n  end(depth) {\n    depth = this.resolveDepth(depth)\n    return this.start(depth) + this.node(depth).content.size\n  }\n\n  // :: (?number)  number\n  // The (absolute) position directly before the wrapping node at the\n  // given level, or, when `depth` is `this.depth + 1`, the original\n  // position.\n  before(depth) {\n    depth = this.resolveDepth(depth)\n    if (!depth) throw new RangeError(\"There is no position before the top-level node\")\n    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1]\n  }\n\n  // :: (?number)  number\n  // The (absolute) position directly after the wrapping node at the\n  // given level, or the original position when `depth` is `this.depth + 1`.\n  after(depth) {\n    depth = this.resolveDepth(depth)\n    if (!depth) throw new RangeError(\"There is no position after the top-level node\")\n    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize\n  }\n\n  // :: number\n  // When this position points into a text node, this returns the\n  // distance between the position and the start of the text node.\n  // Will be zero for positions that point between nodes.\n  get textOffset() { return this.pos - this.path[this.path.length - 1] }\n\n  // :: ?Node\n  // Get the node directly after the position, if any. If the position\n  // points into a text node, only the part of that node after the\n  // position is returned.\n  get nodeAfter() {\n    let parent = this.parent, index = this.index(this.depth)\n    if (index == parent.childCount) return null\n    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index)\n    return dOff ? parent.child(index).cut(dOff) : child\n  }\n\n  // :: ?Node\n  // Get the node directly before the position, if any. If the\n  // position points into a text node, only the part of that node\n  // before the position is returned.\n  get nodeBefore() {\n    let index = this.index(this.depth)\n    let dOff = this.pos - this.path[this.path.length - 1]\n    if (dOff) return this.parent.child(index).cut(0, dOff)\n    return index == 0 ? null : this.parent.child(index - 1)\n  }\n\n  // :: (number, ?number)  number\n  // Get the position at the given index in the parent node at the\n  // given depth (which defaults to `this.depth`).\n  posAtIndex(index, depth) {\n    depth = this.resolveDepth(depth)\n    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1\n    for (let i = 0; i < index; i++) pos += node.child(i).nodeSize\n    return pos\n  }\n\n  // :: ()  [Mark]\n  // Get the marks at this position, factoring in the surrounding\n  // marks' [`inclusive`](#model.MarkSpec.inclusive) property. If the\n  // position is at the start of a non-empty node, the marks of the\n  // node after it (if any) are returned.\n  marks() {\n    let parent = this.parent, index = this.index()\n\n    // In an empty parent, return the empty array\n    if (parent.content.size == 0) return Mark.none\n\n    // When inside a text node, just return the text node's marks\n    if (this.textOffset) return parent.child(index).marks\n\n    let main = parent.maybeChild(index - 1), other = parent.maybeChild(index)\n    // If the `after` flag is true of there is no node before, make\n    // the node after this position the main reference.\n    if (!main) { let tmp = main; main = other; other = tmp }\n\n    // Use all marks in the main node, except those that have\n    // `inclusive` set to false and are not present in the other node.\n    let marks = main.marks\n    for (var i = 0; i < marks.length; i++)\n      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))\n        marks = marks[i--].removeFromSet(marks)\n\n    return marks\n  }\n\n  // :: (ResolvedPos)  ?[Mark]\n  // Get the marks after the current position, if any, except those\n  // that are non-inclusive and not present at position `$end`. This\n  // is mostly useful for getting the set of marks to preserve after a\n  // deletion. Will return `null` if this position is at the end of\n  // its parent node or its parent node isn't a textblock (in which\n  // case no marks should be preserved).\n  marksAcross($end) {\n    let after = this.parent.maybeChild(this.index())\n    if (!after || !after.isInline) return null\n\n    let marks = after.marks, next = $end.parent.maybeChild($end.index())\n    for (var i = 0; i < marks.length; i++)\n      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))\n        marks = marks[i--].removeFromSet(marks)\n    return marks\n  }\n\n  // :: (number)  number\n  // The depth up to which this position and the given (non-resolved)\n  // position share the same parent nodes.\n  sharedDepth(pos) {\n    for (let depth = this.depth; depth > 0; depth--)\n      if (this.start(depth) <= pos && this.end(depth) >= pos) return depth\n    return 0\n  }\n\n  // :: (?ResolvedPos, ?(Node)  bool)  ?NodeRange\n  // Returns a range based on the place where this position and the\n  // given position diverge around block content. If both point into\n  // the same textblock, for example, a range around that textblock\n  // will be returned. If they point into different blocks, the range\n  // around those blocks in their shared ancestor is returned. You can\n  // pass in an optional predicate that will be called with a parent\n  // node to see if a range into that parent is acceptable.\n  blockRange(other = this, pred) {\n    if (other.pos < this.pos) return other.blockRange(this)\n    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)\n      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))\n        return new NodeRange(this, other, d)\n  }\n\n  // :: (ResolvedPos)  bool\n  // Query whether the given position shares the same parent node.\n  sameParent(other) {\n    return this.pos - this.parentOffset == other.pos - other.parentOffset\n  }\n\n  // :: (ResolvedPos)  ResolvedPos\n  // Return the greater of this and the given position.\n  max(other) {\n    return other.pos > this.pos ? other : this\n  }\n\n  // :: (ResolvedPos)  ResolvedPos\n  // Return the smaller of this and the given position.\n  min(other) {\n    return other.pos < this.pos ? other : this\n  }\n\n  toString() {\n    let str = \"\"\n    for (let i = 1; i <= this.depth; i++)\n      str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1)\n    return str + \":\" + this.parentOffset\n  }\n\n  static resolve(doc, pos) {\n    if (!(pos >= 0 && pos <= doc.content.size)) throw new RangeError(\"Position \" + pos + \" out of range\")\n    let path = []\n    let start = 0, parentOffset = pos\n    for (let node = doc;;) {\n      let {index, offset} = node.content.findIndex(parentOffset)\n      let rem = parentOffset - offset\n      path.push(node, index, start + offset)\n      if (!rem) break\n      node = node.child(index)\n      if (node.isText) break\n      parentOffset = rem - 1\n      start += offset + 1\n    }\n    return new ResolvedPos(pos, path, parentOffset)\n  }\n\n  static resolveCached(doc, pos) {\n    for (let i = 0; i < resolveCache.length; i++) {\n      let cached = resolveCache[i]\n      if (cached.pos == pos && cached.doc == doc) return cached\n    }\n    let result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos)\n    resolveCachePos = (resolveCachePos + 1) % resolveCacheSize\n    return result\n  }\n}\n\nlet resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12\n\n// ::- Represents a flat range of content, i.e. one that starts and\n// ends in the same node.\nexport class NodeRange {\n  // :: (ResolvedPos, ResolvedPos, number)\n  // Construct a node range. `$from` and `$to` should point into the\n  // same node until at least the given `depth`, since a node range\n  // denotes an adjacent set of nodes in a single parent node.\n  constructor($from, $to, depth) {\n    // :: ResolvedPos A resolved position along the start of the\n    // content. May have a `depth` greater than this object's `depth`\n    // property, since these are the positions that were used to\n    // compute the range, not re-resolved positions directly at its\n    // boundaries.\n    this.$from = $from\n    // :: ResolvedPos A position along the end of the content. See\n    // caveat for [`$from`](#model.NodeRange.$from).\n    this.$to = $to\n    // :: number The depth of the node that this range points into.\n    this.depth = depth\n  }\n\n  // :: number The position at the start of the range.\n  get start() { return this.$from.before(this.depth + 1) }\n  // :: number The position at the end of the range.\n  get end() { return this.$to.after(this.depth + 1) }\n\n  // :: Node The parent node that the range points into.\n  get parent() { return this.$from.node(this.depth) }\n  // :: number The start index of the range in the parent node.\n  get startIndex() { return this.$from.index(this.depth) }\n  // :: number The end index of the range in the parent node.\n  get endIndex() { return this.$to.indexAfter(this.depth) }\n}\n","import {Fragment} from \"./fragment\"\nimport {Mark} from \"./mark\"\nimport {Slice, replace} from \"./replace\"\nimport {ResolvedPos} from \"./resolvedpos\"\nimport {compareDeep} from \"./comparedeep\"\n\nconst emptyAttrs = Object.create(null)\n\n// ::- This class represents a node in the tree that makes up a\n// ProseMirror document. So a document is an instance of `Node`, with\n// children that are also instances of `Node`.\n//\n// Nodes are persistent data structures. Instead of changing them, you\n// create new ones with the content you want. Old ones keep pointing\n// at the old document shape. This is made cheaper by sharing\n// structure between the old and new data as much as possible, which a\n// tree shape like this (without back pointers) makes easy.\n//\n// **Do not** directly mutate the properties of a `Node` object. See\n// [the guide](/docs/guide/#doc) for more information.\nexport class Node {\n  constructor(type, attrs, content, marks) {\n    // :: NodeType\n    // The type of node that this is.\n    this.type = type\n\n    // :: Object\n    // An object mapping attribute names to values. The kind of\n    // attributes allowed and required are\n    // [determined](#model.NodeSpec.attrs) by the node type.\n    this.attrs = attrs\n\n    // :: Fragment\n    // A container holding the node's children.\n    this.content = content || Fragment.empty\n\n    // :: [Mark]\n    // The marks (things like whether it is emphasized or part of a\n    // link) applied to this node.\n    this.marks = marks || Mark.none\n  }\n\n  // text:: ?string\n  // For text nodes, this contains the node's text content.\n\n  // :: number\n  // The size of this node, as defined by the integer-based [indexing\n  // scheme](/docs/guide/#doc.indexing). For text nodes, this is the\n  // amount of characters. For other leaf nodes, it is one. For\n  // non-leaf nodes, it is the size of the content plus two (the start\n  // and end token).\n  get nodeSize() { return this.isLeaf ? 1 : 2 + this.content.size }\n\n  // :: number\n  // The number of children that the node has.\n  get childCount() { return this.content.childCount }\n\n  // :: (number)  Node\n  // Get the child node at the given index. Raises an error when the\n  // index is out of range.\n  child(index) { return this.content.child(index) }\n\n  // :: (number)  ?Node\n  // Get the child node at the given index, if it exists.\n  maybeChild(index) { return this.content.maybeChild(index) }\n\n  // :: ((node: Node, offset: number, index: number))\n  // Call `f` for every child node, passing the node, its offset\n  // into this parent node, and its index.\n  forEach(f) { this.content.forEach(f) }\n\n  // :: (number, number, (node: Node, pos: number, parent: Node, index: number)  ?bool, ?number)\n  // Invoke a callback for all descendant nodes recursively between\n  // the given two positions that are relative to start of this node's\n  // content. The callback is invoked with the node, its\n  // parent-relative position, its parent node, and its child index.\n  // When the callback returns false for a given node, that node's\n  // children will not be recursed over. The last parameter can be\n  // used to specify a starting position to count from.\n  nodesBetween(from, to, f, startPos = 0) {\n    this.content.nodesBetween(from, to, f, startPos, this)\n  }\n\n  // :: ((node: Node, pos: number, parent: Node, index: number)  ?bool)\n  // Call the given callback for every descendant node. Doesn't\n  // descend into a node when the callback returns `false`.\n  descendants(f) {\n    this.nodesBetween(0, this.content.size, f)\n  }\n\n  // :: string\n  // Concatenates all the text nodes found in this fragment and its\n  // children.\n  get textContent() { return this.textBetween(0, this.content.size, \"\") }\n\n  // :: (number, number, ?string, ?union<string, ?(leafNode: Node) -> string>)  string\n  // Get all text between positions `from` and `to`. When\n  // `blockSeparator` is given, it will be inserted to separate text\n  // from different block nodes. When `leafText` is given, it'll be\n  // inserted for every non-text leaf node encountered.\n  textBetween(from, to, blockSeparator, leafText) {\n    return this.content.textBetween(from, to, blockSeparator, leafText)\n  }\n\n  // :: ?Node\n  // Returns this node's first child, or `null` if there are no\n  // children.\n  get firstChild() { return this.content.firstChild }\n\n  // :: ?Node\n  // Returns this node's last child, or `null` if there are no\n  // children.\n  get lastChild() { return this.content.lastChild }\n\n  // :: (Node)  bool\n  // Test whether two nodes represent the same piece of document.\n  eq(other) {\n    return this == other || (this.sameMarkup(other) && this.content.eq(other.content))\n  }\n\n  // :: (Node)  bool\n  // Compare the markup (type, attributes, and marks) of this node to\n  // those of another. Returns `true` if both have the same markup.\n  sameMarkup(other) {\n    return this.hasMarkup(other.type, other.attrs, other.marks)\n  }\n\n  // :: (NodeType, ?Object, ?[Mark])  bool\n  // Check whether this node's markup correspond to the given type,\n  // attributes, and marks.\n  hasMarkup(type, attrs, marks) {\n    return this.type == type &&\n      compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&\n      Mark.sameSet(this.marks, marks || Mark.none)\n  }\n\n  // :: (?Fragment)  Node\n  // Create a new node with the same markup as this node, containing\n  // the given content (or empty, if no content is given).\n  copy(content = null) {\n    if (content == this.content) return this\n    return new this.constructor(this.type, this.attrs, content, this.marks)\n  }\n\n  // :: ([Mark])  Node\n  // Create a copy of this node, with the given set of marks instead\n  // of the node's own marks.\n  mark(marks) {\n    return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks)\n  }\n\n  // :: (number, ?number)  Node\n  // Create a copy of this node with only the content between the\n  // given positions. If `to` is not given, it defaults to the end of\n  // the node.\n  cut(from, to) {\n    if (from == 0 && to == this.content.size) return this\n    return this.copy(this.content.cut(from, to))\n  }\n\n  // :: (number, ?number)  Slice\n  // Cut out the part of the document between the given positions, and\n  // return it as a `Slice` object.\n  slice(from, to = this.content.size, includeParents = false) {\n    if (from == to) return Slice.empty\n\n    let $from = this.resolve(from), $to = this.resolve(to)\n    let depth = includeParents ? 0 : $from.sharedDepth(to)\n    let start = $from.start(depth), node = $from.node(depth)\n    let content = node.content.cut($from.pos - start, $to.pos - start)\n    return new Slice(content, $from.depth - depth, $to.depth - depth)\n  }\n\n  // :: (number, number, Slice)  Node\n  // Replace the part of the document between the given positions with\n  // the given slice. The slice must 'fit', meaning its open sides\n  // must be able to connect to the surrounding content, and its\n  // content nodes must be valid children for the node they are placed\n  // into. If any of this is violated, an error of type\n  // [`ReplaceError`](#model.ReplaceError) is thrown.\n  replace(from, to, slice) {\n    return replace(this.resolve(from), this.resolve(to), slice)\n  }\n\n  // :: (number)  ?Node\n  // Find the node directly after the given position.\n  nodeAt(pos) {\n    for (let node = this;;) {\n      let {index, offset} = node.content.findIndex(pos)\n      node = node.maybeChild(index)\n      if (!node) return null\n      if (offset == pos || node.isText) return node\n      pos -= offset + 1\n    }\n  }\n\n  // :: (number)  {node: ?Node, index: number, offset: number}\n  // Find the (direct) child node after the given offset, if any,\n  // and return it along with its index and offset relative to this\n  // node.\n  childAfter(pos) {\n    let {index, offset} = this.content.findIndex(pos)\n    return {node: this.content.maybeChild(index), index, offset}\n  }\n\n  // :: (number)  {node: ?Node, index: number, offset: number}\n  // Find the (direct) child node before the given offset, if any,\n  // and return it along with its index and offset relative to this\n  // node.\n  childBefore(pos) {\n    if (pos == 0) return {node: null, index: 0, offset: 0}\n    let {index, offset} = this.content.findIndex(pos)\n    if (offset < pos) return {node: this.content.child(index), index, offset}\n    let node = this.content.child(index - 1)\n    return {node, index: index - 1, offset: offset - node.nodeSize}\n  }\n\n  // :: (number)  ResolvedPos\n  // Resolve the given position in the document, returning an\n  // [object](#model.ResolvedPos) with information about its context.\n  resolve(pos) { return ResolvedPos.resolveCached(this, pos) }\n\n  resolveNoCache(pos) { return ResolvedPos.resolve(this, pos) }\n\n  // :: (number, number, union<Mark, MarkType>)  bool\n  // Test whether a given mark or mark type occurs in this document\n  // between the two given positions.\n  rangeHasMark(from, to, type) {\n    let found = false\n    if (to > from) this.nodesBetween(from, to, node => {\n      if (type.isInSet(node.marks)) found = true\n      return !found\n    })\n    return found\n  }\n\n  // :: bool\n  // True when this is a block (non-inline node)\n  get isBlock() { return this.type.isBlock }\n\n  // :: bool\n  // True when this is a textblock node, a block node with inline\n  // content.\n  get isTextblock() { return this.type.isTextblock }\n\n  // :: bool\n  // True when this node allows inline content.\n  get inlineContent() { return this.type.inlineContent }\n\n  // :: bool\n  // True when this is an inline node (a text node or a node that can\n  // appear among text).\n  get isInline() { return this.type.isInline }\n\n  // :: bool\n  // True when this is a text node.\n  get isText() { return this.type.isText }\n\n  // :: bool\n  // True when this is a leaf node.\n  get isLeaf() { return this.type.isLeaf }\n\n  // :: bool\n  // True when this is an atom, i.e. when it does not have directly\n  // editable content. This is usually the same as `isLeaf`, but can\n  // be configured with the [`atom` property](#model.NodeSpec.atom) on\n  // a node's spec (typically used when the node is displayed as an\n  // uneditable [node view](#view.NodeView)).\n  get isAtom() { return this.type.isAtom }\n\n  // :: ()  string\n  // Return a string representation of this node for debugging\n  // purposes.\n  toString() {\n    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)\n    let name = this.type.name\n    if (this.content.size)\n      name += \"(\" + this.content.toStringInner() + \")\"\n    return wrapMarks(this.marks, name)\n  }\n\n  // :: (number)  ContentMatch\n  // Get the content match in this node at the given index.\n  contentMatchAt(index) {\n    let match = this.type.contentMatch.matchFragment(this.content, 0, index)\n    if (!match) throw new Error(\"Called contentMatchAt on a node with invalid content\")\n    return match\n  }\n\n  // :: (number, number, ?Fragment, ?number, ?number)  bool\n  // Test whether replacing the range between `from` and `to` (by\n  // child index) with the given replacement fragment (which defaults\n  // to the empty fragment) would leave the node's content valid. You\n  // can optionally pass `start` and `end` indices into the\n  // replacement fragment.\n  canReplace(from, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {\n    let one = this.contentMatchAt(from).matchFragment(replacement, start, end)\n    let two = one && one.matchFragment(this.content, to)\n    if (!two || !two.validEnd) return false\n    for (let i = start; i < end; i++) if (!this.type.allowsMarks(replacement.child(i).marks)) return false\n    return true\n  }\n\n  // :: (number, number, NodeType, ?[Mark])  bool\n  // Test whether replacing the range `from` to `to` (by index) with a\n  // node of the given type would leave the node's content valid.\n  canReplaceWith(from, to, type, marks) {\n    if (marks && !this.type.allowsMarks(marks)) return false\n    let start = this.contentMatchAt(from).matchType(type)\n    let end = start && start.matchFragment(this.content, to)\n    return end ? end.validEnd : false\n  }\n\n  // :: (Node)  bool\n  // Test whether the given node's content could be appended to this\n  // node. If that node is empty, this will only return true if there\n  // is at least one node type that can appear in both nodes (to avoid\n  // merging completely incompatible nodes).\n  canAppend(other) {\n    if (other.content.size) return this.canReplace(this.childCount, this.childCount, other.content)\n    else return this.type.compatibleContent(other.type)\n  }\n\n  // :: ()\n  // Check whether this node and its descendants conform to the\n  // schema, and raise error when they do not.\n  check() {\n    if (!this.type.validContent(this.content))\n      throw new RangeError(`Invalid content for node ${this.type.name}: ${this.content.toString().slice(0, 50)}`)\n    let copy = Mark.none\n    for (let i = 0; i < this.marks.length; i++) copy = this.marks[i].addToSet(copy)\n    if (!Mark.sameSet(copy, this.marks))\n      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map(m => m.type.name)}`)\n    this.content.forEach(node => node.check())\n  }\n\n  // :: ()  Object\n  // Return a JSON-serializeable representation of this node.\n  toJSON() {\n    let obj = {type: this.type.name}\n    for (let _ in this.attrs) {\n      obj.attrs = this.attrs\n      break\n    }\n    if (this.content.size)\n      obj.content = this.content.toJSON()\n    if (this.marks.length)\n      obj.marks = this.marks.map(n => n.toJSON())\n    return obj\n  }\n\n  // :: (Schema, Object)  Node\n  // Deserialize a node from its JSON representation.\n  static fromJSON(schema, json) {\n    if (!json) throw new RangeError(\"Invalid input for Node.fromJSON\")\n    let marks = null\n    if (json.marks) {\n      if (!Array.isArray(json.marks)) throw new RangeError(\"Invalid mark data for Node.fromJSON\")\n      marks = json.marks.map(schema.markFromJSON)\n    }\n    if (json.type == \"text\") {\n      if (typeof json.text != \"string\") throw new RangeError(\"Invalid text node in JSON\")\n      return schema.text(json.text, marks)\n    }\n    let content = Fragment.fromJSON(schema, json.content)\n    return schema.nodeType(json.type).create(json.attrs, content, marks)\n  }\n}\n\nexport class TextNode extends Node {\n  constructor(type, attrs, content, marks) {\n    super(type, attrs, null, marks)\n\n    if (!content) throw new RangeError(\"Empty text nodes are not allowed\")\n\n    this.text = content\n  }\n\n  toString() {\n    if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this)\n    return wrapMarks(this.marks, JSON.stringify(this.text))\n  }\n\n  get textContent() { return this.text }\n\n  textBetween(from, to) { return this.text.slice(from, to) }\n\n  get nodeSize() { return this.text.length }\n\n  mark(marks) {\n    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks)\n  }\n\n  withText(text) {\n    if (text == this.text) return this\n    return new TextNode(this.type, this.attrs, text, this.marks)\n  }\n\n  cut(from = 0, to = this.text.length) {\n    if (from == 0 && to == this.text.length) return this\n    return this.withText(this.text.slice(from, to))\n  }\n\n  eq(other) {\n    return this.sameMarkup(other) && this.text == other.text\n  }\n\n  toJSON() {\n    let base = super.toJSON()\n    base.text = this.text\n    return base\n  }\n}\n\nfunction wrapMarks(marks, str) {\n  for (let i = marks.length - 1; i >= 0; i--)\n    str = marks[i].type.name + \"(\" + str + \")\"\n  return str\n}\n","import {Fragment} from \"./fragment\"\n\n// ::- Instances of this class represent a match state of a node\n// type's [content expression](#model.NodeSpec.content), and can be\n// used to find out whether further content matches here, and whether\n// a given position is a valid end of the node.\nexport class ContentMatch {\n  constructor(validEnd) {\n    // :: bool\n    // True when this match state represents a valid end of the node.\n    this.validEnd = validEnd\n    this.next = []\n    this.wrapCache = []\n  }\n\n  static parse(string, nodeTypes) {\n    let stream = new TokenStream(string, nodeTypes)\n    if (stream.next == null) return ContentMatch.empty\n    let expr = parseExpr(stream)\n    if (stream.next) stream.err(\"Unexpected trailing text\")\n    let match = dfa(nfa(expr))\n    checkForDeadEnds(match, stream)\n    return match\n  }\n\n  // :: (NodeType)  ?ContentMatch\n  // Match a node type, returning a match after that node if\n  // successful.\n  matchType(type) {\n    for (let i = 0; i < this.next.length; i += 2)\n      if (this.next[i] == type) return this.next[i + 1]\n    return null\n  }\n\n  // :: (Fragment, ?number, ?number)  ?ContentMatch\n  // Try to match a fragment. Returns the resulting match when\n  // successful.\n  matchFragment(frag, start = 0, end = frag.childCount) {\n    let cur = this\n    for (let i = start; cur && i < end; i++)\n      cur = cur.matchType(frag.child(i).type)\n    return cur\n  }\n\n  get inlineContent() {\n    let first = this.next[0]\n    return first ? first.isInline : false\n  }\n\n  // :: ?NodeType\n  // Get the first matching node type at this match position that can\n  // be generated.\n  get defaultType() {\n    for (let i = 0; i < this.next.length; i += 2) {\n      let type = this.next[i]\n      if (!(type.isText || type.hasRequiredAttrs())) return type\n    }\n  }\n\n  compatible(other) {\n    for (let i = 0; i < this.next.length; i += 2)\n      for (let j = 0; j < other.next.length; j += 2)\n        if (this.next[i] == other.next[j]) return true\n    return false\n  }\n\n  // :: (Fragment, bool, ?number)  ?Fragment\n  // Try to match the given fragment, and if that fails, see if it can\n  // be made to match by inserting nodes in front of it. When\n  // successful, return a fragment of inserted nodes (which may be\n  // empty if nothing had to be inserted). When `toEnd` is true, only\n  // return a fragment if the resulting match goes to the end of the\n  // content expression.\n  fillBefore(after, toEnd = false, startIndex = 0) {\n    let seen = [this]\n    function search(match, types) {\n      let finished = match.matchFragment(after, startIndex)\n      if (finished && (!toEnd || finished.validEnd))\n        return Fragment.from(types.map(tp => tp.createAndFill()))\n\n      for (let i = 0; i < match.next.length; i += 2) {\n        let type = match.next[i], next = match.next[i + 1]\n        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n          seen.push(next)\n          let found = search(next, types.concat(type))\n          if (found) return found\n        }\n      }\n    }\n\n    return search(this, [])\n  }\n\n  // :: (NodeType)  ?[NodeType]\n  // Find a set of wrapping node types that would allow a node of the\n  // given type to appear at this position. The result may be empty\n  // (when it fits directly) and will be null when no such wrapping\n  // exists.\n  findWrapping(target) {\n    for (let i = 0; i < this.wrapCache.length; i += 2)\n      if (this.wrapCache[i] == target) return this.wrapCache[i + 1]\n    let computed = this.computeWrapping(target)\n    this.wrapCache.push(target, computed)\n    return computed\n  }\n\n  computeWrapping(target) {\n    let seen = Object.create(null), active = [{match: this, type: null, via: null}]\n    while (active.length) {\n      let current = active.shift(), match = current.match\n      if (match.matchType(target)) {\n        let result = []\n        for (let obj = current; obj.type; obj = obj.via)\n          result.push(obj.type)\n        return result.reverse()\n      }\n      for (let i = 0; i < match.next.length; i += 2) {\n        let type = match.next[i]\n        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {\n          active.push({match: type.contentMatch, type, via: current})\n          seen[type.name] = true\n        }\n      }\n    }\n  }\n\n  // :: number\n  // The number of outgoing edges this node has in the finite\n  // automaton that describes the content expression.\n  get edgeCount() {\n    return this.next.length >> 1\n  }\n\n  // :: (number)  {type: NodeType, next: ContentMatch}\n  // Get the _n_th outgoing edge from this node in the finite\n  // automaton that describes the content expression.\n  edge(n) {\n    let i = n << 1\n    if (i >= this.next.length) throw new RangeError(`There's no ${n}th edge in this content match`)\n    return {type: this.next[i], next: this.next[i + 1]}\n  }\n\n  toString() {\n    let seen = []\n    function scan(m) {\n      seen.push(m)\n      for (let i = 1; i < m.next.length; i += 2)\n        if (seen.indexOf(m.next[i]) == -1) scan(m.next[i])\n    }\n    scan(this)\n    return seen.map((m, i) => {\n      let out = i + (m.validEnd ? \"*\" : \" \") + \" \"\n      for (let i = 0; i < m.next.length; i += 2)\n        out += (i ? \", \" : \"\") + m.next[i].name + \"->\" + seen.indexOf(m.next[i + 1])\n      return out\n    }).join(\"\\n\")\n  }\n}\n\nContentMatch.empty = new ContentMatch(true)\n\nclass TokenStream {\n  constructor(string, nodeTypes) {\n    this.string = string\n    this.nodeTypes = nodeTypes\n    this.inline = null\n    this.pos = 0\n    this.tokens = string.split(/\\s*(?=\\b|\\W|$)/)\n    if (this.tokens[this.tokens.length - 1] == \"\") this.tokens.pop()\n    if (this.tokens[0] == \"\") this.tokens.shift()\n  }\n\n  get next() { return this.tokens[this.pos] }\n\n  eat(tok) { return this.next == tok && (this.pos++ || true) }\n\n  err(str) { throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\") }\n}\n\nfunction parseExpr(stream) {\n  let exprs = []\n  do { exprs.push(parseExprSeq(stream)) }\n  while (stream.eat(\"|\"))\n  return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs}\n}\n\nfunction parseExprSeq(stream) {\n  let exprs = []\n  do { exprs.push(parseExprSubscript(stream)) }\n  while (stream.next && stream.next != \")\" && stream.next != \"|\")\n  return exprs.length == 1 ? exprs[0] : {type: \"seq\", exprs}\n}\n\nfunction parseExprSubscript(stream) {\n  let expr = parseExprAtom(stream)\n  for (;;) {\n    if (stream.eat(\"+\"))\n      expr = {type: \"plus\", expr}\n    else if (stream.eat(\"*\"))\n      expr = {type: \"star\", expr}\n    else if (stream.eat(\"?\"))\n      expr = {type: \"opt\", expr}\n    else if (stream.eat(\"{\"))\n      expr = parseExprRange(stream, expr)\n    else break\n  }\n  return expr\n}\n\nfunction parseNum(stream) {\n  if (/\\D/.test(stream.next)) stream.err(\"Expected number, got '\" + stream.next + \"'\")\n  let result = Number(stream.next)\n  stream.pos++\n  return result\n}\n\nfunction parseExprRange(stream, expr) {\n  let min = parseNum(stream), max = min\n  if (stream.eat(\",\")) {\n    if (stream.next != \"}\") max = parseNum(stream)\n    else max = -1\n  }\n  if (!stream.eat(\"}\")) stream.err(\"Unclosed braced range\")\n  return {type: \"range\", min, max, expr}\n}\n\nfunction resolveName(stream, name) {\n  let types = stream.nodeTypes, type = types[name]\n  if (type) return [type]\n  let result = []\n  for (let typeName in types) {\n    let type = types[typeName]\n    if (type.groups.indexOf(name) > -1) result.push(type)\n  }\n  if (result.length == 0) stream.err(\"No node type or group '\" + name + \"' found\")\n  return result\n}\n\nfunction parseExprAtom(stream) {\n  if (stream.eat(\"(\")) {\n    let expr = parseExpr(stream)\n    if (!stream.eat(\")\")) stream.err(\"Missing closing paren\")\n    return expr\n  } else if (!/\\W/.test(stream.next)) {\n    let exprs = resolveName(stream, stream.next).map(type => {\n      if (stream.inline == null) stream.inline = type.isInline\n      else if (stream.inline != type.isInline) stream.err(\"Mixing inline and block content\")\n      return {type: \"name\", value: type}\n    })\n    stream.pos++\n    return exprs.length == 1 ? exprs[0] : {type: \"choice\", exprs}\n  } else {\n    stream.err(\"Unexpected token '\" + stream.next + \"'\")\n  }\n}\n\n// The code below helps compile a regular-expression-like language\n// into a deterministic finite automaton. For a good introduction to\n// these concepts, see https://swtch.com/~rsc/regexp/regexp1.html\n\n// : (Object)  [[{term: ?any, to: number}]]\n// Construct an NFA from an expression as returned by the parser. The\n// NFA is represented as an array of states, which are themselves\n// arrays of edges, which are `{term, to}` objects. The first state is\n// the entry state and the last node is the success state.\n//\n// Note that unlike typical NFAs, the edge ordering in this one is\n// significant, in that it is used to contruct filler content when\n// necessary.\nfunction nfa(expr) {\n  let nfa = [[]]\n  connect(compile(expr, 0), node())\n  return nfa\n\n  function node() { return nfa.push([]) - 1 }\n  function edge(from, to, term) {\n    let edge = {term, to}\n    nfa[from].push(edge)\n    return edge\n  }\n  function connect(edges, to) { edges.forEach(edge => edge.to = to) }\n\n  function compile(expr, from) {\n    if (expr.type == \"choice\") {\n      return expr.exprs.reduce((out, expr) => out.concat(compile(expr, from)), [])\n    } else if (expr.type == \"seq\") {\n      for (let i = 0;; i++) {\n        let next = compile(expr.exprs[i], from)\n        if (i == expr.exprs.length - 1) return next\n        connect(next, from = node())\n      }\n    } else if (expr.type == \"star\") {\n      let loop = node()\n      edge(from, loop)\n      connect(compile(expr.expr, loop), loop)\n      return [edge(loop)]\n    } else if (expr.type == \"plus\") {\n      let loop = node()\n      connect(compile(expr.expr, from), loop)\n      connect(compile(expr.expr, loop), loop)\n      return [edge(loop)]\n    } else if (expr.type == \"opt\") {\n      return [edge(from)].concat(compile(expr.expr, from))\n    } else if (expr.type == \"range\") {\n      let cur = from\n      for (let i = 0; i < expr.min; i++) {\n        let next = node()\n        connect(compile(expr.expr, cur), next)\n        cur = next\n      }\n      if (expr.max == -1) {\n        connect(compile(expr.expr, cur), cur)\n      } else {\n        for (let i = expr.min; i < expr.max; i++) {\n          let next = node()\n          edge(cur, next)\n          connect(compile(expr.expr, cur), next)\n          cur = next\n        }\n      }\n      return [edge(cur)]\n    } else if (expr.type == \"name\") {\n      return [edge(from, null, expr.value)]\n    }\n  }\n}\n\nfunction cmp(a, b) { return b - a }\n\n// Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\nfunction nullFrom(nfa, node) {\n  let result = []\n  scan(node)\n  return result.sort(cmp)\n\n  function scan(node) {\n    let edges = nfa[node]\n    if (edges.length == 1 && !edges[0].term) return scan(edges[0].to)\n    result.push(node)\n    for (let i = 0; i < edges.length; i++) {\n      let {term, to} = edges[i]\n      if (!term && result.indexOf(to) == -1) scan(to)\n    }\n  }\n}\n\n// : ([[{term: ?any, to: number}]])  ContentMatch\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\nfunction dfa(nfa) {\n  let labeled = Object.create(null)\n  return explore(nullFrom(nfa, 0))\n\n  function explore(states) {\n    let out = []\n    states.forEach(node => {\n      nfa[node].forEach(({term, to}) => {\n        if (!term) return\n        let known = out.indexOf(term), set = known > -1 && out[known + 1]\n        nullFrom(nfa, to).forEach(node => {\n          if (!set) out.push(term, set = [])\n          if (set.indexOf(node) == -1) set.push(node)\n        })\n      })\n    })\n    let state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1)\n    for (let i = 0; i < out.length; i += 2) {\n      let states = out[i + 1].sort(cmp)\n      state.next.push(out[i], labeled[states.join(\",\")] || explore(states))\n    }\n    return state\n  }\n}\n\nfunction checkForDeadEnds(match, stream) {\n  for (let i = 0, work = [match]; i < work.length; i++) {\n    let state = work[i], dead = !state.validEnd, nodes = []\n    for (let j = 0; j < state.next.length; j += 2) {\n      let node = state.next[j], next = state.next[j + 1]\n      nodes.push(node.name)\n      if (dead && !(node.isText || node.hasRequiredAttrs())) dead = false\n      if (work.indexOf(next) == -1) work.push(next)\n    }\n    if (dead) stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\")\n  }\n}\n","import OrderedMap from \"orderedmap\"\n\nimport {Node, TextNode} from \"./node\"\nimport {Fragment} from \"./fragment\"\nimport {Mark} from \"./mark\"\nimport {ContentMatch} from \"./content\"\n\n// For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\nfunction defaultAttrs(attrs) {\n  let defaults = Object.create(null)\n  for (let attrName in attrs) {\n    let attr = attrs[attrName]\n    if (!attr.hasDefault) return null\n    defaults[attrName] = attr.default\n  }\n  return defaults\n}\n\nfunction computeAttrs(attrs, value) {\n  let built = Object.create(null)\n  for (let name in attrs) {\n    let given = value && value[name]\n    if (given === undefined) {\n      let attr = attrs[name]\n      if (attr.hasDefault) given = attr.default\n      else throw new RangeError(\"No value supplied for attribute \" + name)\n    }\n    built[name] = given\n  }\n  return built\n}\n\nfunction initAttrs(attrs) {\n  let result = Object.create(null)\n  if (attrs) for (let name in attrs) result[name] = new Attribute(attrs[name])\n  return result\n}\n\n// ::- Node types are objects allocated once per `Schema` and used to\n// [tag](#model.Node.type) `Node` instances. They contain information\n// about the node type, such as its name and what kind of node it\n// represents.\nexport class NodeType {\n  constructor(name, schema, spec) {\n    // :: string\n    // The name the node type has in this schema.\n    this.name = name\n\n    // :: Schema\n    // A link back to the `Schema` the node type belongs to.\n    this.schema = schema\n\n    // :: NodeSpec\n    // The spec that this type is based on\n    this.spec = spec\n\n    this.groups = spec.group ? spec.group.split(\" \") : []\n    this.attrs = initAttrs(spec.attrs)\n\n    this.defaultAttrs = defaultAttrs(this.attrs)\n\n    // :: ContentMatch\n    // The starting match of the node type's content expression.\n    this.contentMatch = null\n\n    // : ?[MarkType]\n    // The set of marks allowed in this node. `null` means all marks\n    // are allowed.\n    this.markSet = null\n\n    // :: bool\n    // True if this node type has inline content.\n    this.inlineContent = null\n\n    // :: bool\n    // True if this is a block type\n    this.isBlock = !(spec.inline || name == \"text\")\n\n    // :: bool\n    // True if this is the text node type.\n    this.isText = name == \"text\"\n  }\n\n  // :: bool\n  // True if this is an inline type.\n  get isInline() { return !this.isBlock }\n\n  // :: bool\n  // True if this is a textblock type, a block that contains inline\n  // content.\n  get isTextblock() { return this.isBlock && this.inlineContent }\n\n  // :: bool\n  // True for node types that allow no content.\n  get isLeaf() { return this.contentMatch == ContentMatch.empty }\n\n  // :: bool\n  // True when this node is an atom, i.e. when it does not have\n  // directly editable content.\n  get isAtom() { return this.isLeaf || this.spec.atom }\n\n  // :: union<\"pre\", \"normal\">\n  // The node type's [whitespace](#view.NodeSpec.whitespace) option.\n  get whitespace() { return this.spec.whitespace || (this.spec.code ? \"pre\" : \"normal\") }\n\n  // :: ()  bool\n  // Tells you whether this node type has any required attributes.\n  hasRequiredAttrs() {\n    for (let n in this.attrs) if (this.attrs[n].isRequired) return true\n    return false\n  }\n\n  compatibleContent(other) {\n    return this == other || this.contentMatch.compatible(other.contentMatch)\n  }\n\n  computeAttrs(attrs) {\n    if (!attrs && this.defaultAttrs) return this.defaultAttrs\n    else return computeAttrs(this.attrs, attrs)\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark])  Node\n  // Create a `Node` of this type. The given attributes are\n  // checked and defaulted (you can pass `null` to use the type's\n  // defaults entirely, if no required attributes exist). `content`\n  // may be a `Fragment`, a node, an array of nodes, or\n  // `null`. Similarly `marks` may be `null` to default to the empty\n  // set of marks.\n  create(attrs, content, marks) {\n    if (this.isText) throw new Error(\"NodeType.create can't construct text nodes\")\n    return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks))\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark])  Node\n  // Like [`create`](#model.NodeType.create), but check the given content\n  // against the node type's content restrictions, and throw an error\n  // if it doesn't match.\n  createChecked(attrs, content, marks) {\n    content = Fragment.from(content)\n    if (!this.validContent(content))\n      throw new RangeError(\"Invalid content for node \" + this.name)\n    return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks))\n  }\n\n  // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark])  ?Node\n  // Like [`create`](#model.NodeType.create), but see if it is necessary to\n  // add nodes to the start or end of the given fragment to make it\n  // fit the node. If no fitting wrapping can be found, return null.\n  // Note that, due to the fact that required nodes can always be\n  // created, this will always succeed if you pass null or\n  // `Fragment.empty` as content.\n  createAndFill(attrs, content, marks) {\n    attrs = this.computeAttrs(attrs)\n    content = Fragment.from(content)\n    if (content.size) {\n      let before = this.contentMatch.fillBefore(content)\n      if (!before) return null\n      content = before.append(content)\n    }\n    let after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true)\n    if (!after) return null\n    return new Node(this, attrs, content.append(after), Mark.setFrom(marks))\n  }\n\n  // :: (Fragment)  bool\n  // Returns true if the given fragment is valid content for this node\n  // type with the given attributes.\n  validContent(content) {\n    let result = this.contentMatch.matchFragment(content)\n    if (!result || !result.validEnd) return false\n    for (let i = 0; i < content.childCount; i++)\n      if (!this.allowsMarks(content.child(i).marks)) return false\n    return true\n  }\n\n  // :: (MarkType)  bool\n  // Check whether the given mark type is allowed in this node.\n  allowsMarkType(markType) {\n    return this.markSet == null || this.markSet.indexOf(markType) > -1\n  }\n\n  // :: ([Mark])  bool\n  // Test whether the given set of marks are allowed in this node.\n  allowsMarks(marks) {\n    if (this.markSet == null) return true\n    for (let i = 0; i < marks.length; i++) if (!this.allowsMarkType(marks[i].type)) return false\n    return true\n  }\n\n  // :: ([Mark])  [Mark]\n  // Removes the marks that are not allowed in this node from the given set.\n  allowedMarks(marks) {\n    if (this.markSet == null) return marks\n    let copy\n    for (let i = 0; i < marks.length; i++) {\n      if (!this.allowsMarkType(marks[i].type)) {\n        if (!copy) copy = marks.slice(0, i)\n      } else if (copy) {\n        copy.push(marks[i])\n      }\n    }\n    return !copy ? marks : copy.length ? copy : Mark.empty\n  }\n\n  static compile(nodes, schema) {\n    let result = Object.create(null)\n    nodes.forEach((name, spec) => result[name] = new NodeType(name, schema, spec))\n\n    let topType = schema.spec.topNode || \"doc\"\n    if (!result[topType]) throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\")\n    if (!result.text) throw new RangeError(\"Every schema needs a 'text' type\")\n    for (let _ in result.text.attrs) throw new RangeError(\"The text node type should not have attributes\")\n\n    return result\n  }\n}\n\n// Attribute descriptors\n\nclass Attribute {\n  constructor(options) {\n    this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\")\n    this.default = options.default\n  }\n\n  get isRequired() {\n    return !this.hasDefault\n  }\n}\n\n// Marks\n\n// ::- Like nodes, marks (which are associated with nodes to signify\n// things like emphasis or being part of a link) are\n// [tagged](#model.Mark.type) with type objects, which are\n// instantiated once per `Schema`.\nexport class MarkType {\n  constructor(name, rank, schema, spec) {\n    // :: string\n    // The name of the mark type.\n    this.name = name\n\n    // :: Schema\n    // The schema that this mark type instance is part of.\n    this.schema = schema\n\n    // :: MarkSpec\n    // The spec on which the type is based.\n    this.spec = spec\n\n    this.attrs = initAttrs(spec.attrs)\n\n    this.rank = rank\n    this.excluded = null\n    let defaults = defaultAttrs(this.attrs)\n    this.instance = defaults && new Mark(this, defaults)\n  }\n\n  // :: (?Object)  Mark\n  // Create a mark of this type. `attrs` may be `null` or an object\n  // containing only some of the mark's attributes. The others, if\n  // they have defaults, will be added.\n  create(attrs) {\n    if (!attrs && this.instance) return this.instance\n    return new Mark(this, computeAttrs(this.attrs, attrs))\n  }\n\n  static compile(marks, schema) {\n    let result = Object.create(null), rank = 0\n    marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec))\n    return result\n  }\n\n  // :: ([Mark])  [Mark]\n  // When there is a mark of this type in the given set, a new set\n  // without it is returned. Otherwise, the input set is returned.\n  removeFromSet(set) {\n    for (var i = 0; i < set.length; i++) if (set[i].type == this) {\n      set = set.slice(0, i).concat(set.slice(i + 1))\n      i--\n    }\n    return set\n  }\n\n  // :: ([Mark])  ?Mark\n  // Tests whether there is a mark of this type in the given set.\n  isInSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (set[i].type == this) return set[i]\n  }\n\n  // :: (MarkType)  bool\n  // Queries whether a given mark type is\n  // [excluded](#model.MarkSpec.excludes) by this one.\n  excludes(other) {\n    return this.excluded.indexOf(other) > -1\n  }\n}\n\n// SchemaSpec:: interface\n// An object describing a schema, as passed to the [`Schema`](#model.Schema)\n// constructor.\n//\n//   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>\n//   The node types in this schema. Maps names to\n//   [`NodeSpec`](#model.NodeSpec) objects that describe the node type\n//   associated with that name. Their order is significantit\n//   determines which [parse rules](#model.NodeSpec.parseDOM) take\n//   precedence by default, and which nodes come first in a given\n//   [group](#model.NodeSpec.group).\n//\n//   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>\n//   The mark types that exist in this schema. The order in which they\n//   are provided determines the order in which [mark\n//   sets](#model.Mark.addToSet) are sorted and in which [parse\n//   rules](#model.MarkSpec.parseDOM) are tried.\n//\n//   topNode:: ?string\n//   The name of the default top-level node for the schema. Defaults\n//   to `\"doc\"`.\n\n// NodeSpec:: interface\n//\n//   content:: ?string\n//   The content expression for this node, as described in the [schema\n//   guide](/docs/guide/#schema.content_expressions). When not given,\n//   the node does not allow any content.\n//\n//   marks:: ?string\n//   The marks that are allowed inside of this node. May be a\n//   space-separated string referring to mark names or groups, `\"_\"`\n//   to explicitly allow all marks, or `\"\"` to disallow marks. When\n//   not given, nodes with inline content default to allowing all\n//   marks, other nodes default to not allowing marks.\n//\n//   group:: ?string\n//   The group or space-separated groups to which this node belongs,\n//   which can be referred to in the content expressions for the\n//   schema.\n//\n//   inline:: ?bool\n//   Should be set to true for inline nodes. (Implied for text nodes.)\n//\n//   atom:: ?bool\n//   Can be set to true to indicate that, though this isn't a [leaf\n//   node](#model.NodeType.isLeaf), it doesn't have directly editable\n//   content and should be treated as a single unit in the view.\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that nodes of this type get.\n//\n//   selectable:: ?bool\n//   Controls whether nodes of this type can be selected as a [node\n//   selection](#state.NodeSelection). Defaults to true for non-text\n//   nodes.\n//\n//   draggable:: ?bool\n//   Determines whether nodes of this type can be dragged without\n//   being selected. Defaults to false.\n//\n//   code:: ?bool\n//   Can be used to indicate that this node contains code, which\n//   causes some commands to behave differently.\n//\n//   whitespace:: ?union<\"pre\", \"normal\">\n//   Controls way whitespace in this a node is parsed. The default is\n//   `\"normal\"`, which causes the [DOM parser](#model.DOMParser) to\n//   collapse whitespace in normal mode, and normalize it (replacing\n//   newlines and such with spaces) otherwise. `\"pre\"` causes the\n//   parser to preserve spaces inside the node. When this option isn't\n//   given, but [`code`](#model.NodeSpec.code) is true, `whitespace`\n//   will default to `\"pre\"`. Note that this option doesn't influence\n//   the way the node is renderedthat should be handled by `toDOM`\n//   and/or styling.\n//\n//   defining:: ?bool\n//   Determines whether this node is considered an important parent\n//   node during replace operations (such as paste). Non-defining (the\n//   default) nodes get dropped when their entire content is replaced,\n//   whereas defining nodes persist and wrap the inserted content.\n//   Likewise, in _inserted_ content the defining parents of the\n//   content are preserved when possible. Typically,\n//   non-default-paragraph textblock types, and possibly list items,\n//   are marked as defining.\n//\n//   isolating:: ?bool\n//   When enabled (default is false), the sides of nodes of this type\n//   count as boundaries that regular editing operations, like\n//   backspacing or lifting, won't cross. An example of a node that\n//   should probably have this enabled is a table cell.\n//\n//   toDOM:: ?(node: Node)  DOMOutputSpec\n//   Defines the default way a node of this type should be serialized\n//   to DOM/HTML (as used by\n//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)).\n//   Should return a DOM node or an [array\n//   structure](#model.DOMOutputSpec) that describes one, with an\n//   optional number zero (hole) in it to indicate where the node's\n//   content should be inserted.\n//\n//   For text nodes, the default is to create a text DOM node. Though\n//   it is possible to create a serializer where text is rendered\n//   differently, this is not supported inside the editor, so you\n//   shouldn't override that in your text node spec.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this node, which can be\n//   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to\n//   automatically derive a parser. The `node` field in the rules is\n//   implied (the name of this node will be filled in automatically).\n//   If you supply your own parser, you do not need to also specify\n//   parsing rules in your schema.\n//\n//   toDebugString:: ?(node: Node) -> string\n//   Defines the default way a node of this type should be serialized\n//   to a string representation for debugging (e.g. in error messages).\n\n// MarkSpec:: interface\n//\n//   attrs:: ?Object<AttributeSpec>\n//   The attributes that marks of this type get.\n//\n//   inclusive:: ?bool\n//   Whether this mark should be active when the cursor is positioned\n//   at its end (or at its start when that is also the start of the\n//   parent node). Defaults to true.\n//\n//   excludes:: ?string\n//   Determines which other marks this mark can coexist with. Should\n//   be a space-separated strings naming other marks or groups of marks.\n//   When a mark is [added](#model.Mark.addToSet) to a set, all marks\n//   that it excludes are removed in the process. If the set contains\n//   any mark that excludes the new mark but is not, itself, excluded\n//   by the new mark, the mark can not be added an the set. You can\n//   use the value `\"_\"` to indicate that the mark excludes all\n//   marks in the schema.\n//\n//   Defaults to only being exclusive with marks of the same type. You\n//   can set it to an empty string (or any string not containing the\n//   mark's own name) to allow multiple marks of a given type to\n//   coexist (as long as they have different attributes).\n//\n//   group:: ?string\n//   The group or space-separated groups to which this mark belongs.\n//\n//   spanning:: ?bool\n//   Determines whether marks of this type can span multiple adjacent\n//   nodes when serialized to DOM/HTML. Defaults to true.\n//\n//   toDOM:: ?(mark: Mark, inline: bool)  DOMOutputSpec\n//   Defines the default way marks of this type should be serialized\n//   to DOM/HTML. When the resulting spec contains a hole, that is\n//   where the marked content is placed. Otherwise, it is appended to\n//   the top node.\n//\n//   parseDOM:: ?[ParseRule]\n//   Associates DOM parser information with this mark (see the\n//   corresponding [node spec field](#model.NodeSpec.parseDOM)). The\n//   `mark` field in the rules is implied.\n\n// AttributeSpec:: interface\n//\n// Used to [define](#model.NodeSpec.attrs) attributes on nodes or\n// marks.\n//\n//   default:: ?any\n//   The default value for this attribute, to use when no explicit\n//   value is provided. Attributes that have no default must be\n//   provided whenever a node or mark of a type that has them is\n//   created.\n\n// ::- A document schema. Holds [node](#model.NodeType) and [mark\n// type](#model.MarkType) objects for the nodes and marks that may\n// occur in conforming documents, and provides functionality for\n// creating and deserializing such documents.\nexport class Schema {\n  // :: (SchemaSpec)\n  // Construct a schema from a schema [specification](#model.SchemaSpec).\n  constructor(spec) {\n    // :: SchemaSpec\n    // The [spec](#model.SchemaSpec) on which the schema is based,\n    // with the added guarantee that its `nodes` and `marks`\n    // properties are\n    // [`OrderedMap`](https://github.com/marijnh/orderedmap) instances\n    // (not raw objects).\n    this.spec = {}\n    for (let prop in spec) this.spec[prop] = spec[prop]\n    this.spec.nodes = OrderedMap.from(spec.nodes)\n    this.spec.marks = OrderedMap.from(spec.marks)\n\n    // :: Object<NodeType>\n    // An object mapping the schema's node names to node type objects.\n    this.nodes = NodeType.compile(this.spec.nodes, this)\n\n    // :: Object<MarkType>\n    // A map from mark names to mark type objects.\n    this.marks = MarkType.compile(this.spec.marks, this)\n\n    let contentExprCache = Object.create(null)\n    for (let prop in this.nodes) {\n      if (prop in this.marks)\n        throw new RangeError(prop + \" can not be both a node and a mark\")\n      let type = this.nodes[prop], contentExpr = type.spec.content || \"\", markExpr = type.spec.marks\n      type.contentMatch = contentExprCache[contentExpr] ||\n        (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes))\n      type.inlineContent = type.contentMatch.inlineContent\n      type.markSet = markExpr == \"_\" ? null :\n        markExpr ? gatherMarks(this, markExpr.split(\" \")) :\n        markExpr == \"\" || !type.inlineContent ? [] : null\n    }\n    for (let prop in this.marks) {\n      let type = this.marks[prop], excl = type.spec.excludes\n      type.excluded = excl == null ? [type] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"))\n    }\n\n    this.nodeFromJSON = this.nodeFromJSON.bind(this)\n    this.markFromJSON = this.markFromJSON.bind(this)\n\n    // :: NodeType\n    // The type of the [default top node](#model.SchemaSpec.topNode)\n    // for this schema.\n    this.topNodeType = this.nodes[this.spec.topNode || \"doc\"]\n\n    // :: Object\n    // An object for storing whatever values modules may want to\n    // compute and cache per schema. (If you want to store something\n    // in it, try to use property names unlikely to clash.)\n    this.cached = Object.create(null)\n    this.cached.wrappings = Object.create(null)\n  }\n\n  // :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark])  Node\n  // Create a node in this schema. The `type` may be a string or a\n  // `NodeType` instance. Attributes will be extended\n  // with defaults, `content` may be a `Fragment`,\n  // `null`, a `Node`, or an array of nodes.\n  node(type, attrs, content, marks) {\n    if (typeof type == \"string\")\n      type = this.nodeType(type)\n    else if (!(type instanceof NodeType))\n      throw new RangeError(\"Invalid node type: \" + type)\n    else if (type.schema != this)\n      throw new RangeError(\"Node type from different schema used (\" + type.name + \")\")\n\n    return type.createChecked(attrs, content, marks)\n  }\n\n  // :: (string, ?[Mark])  Node\n  // Create a text node in the schema. Empty text nodes are not\n  // allowed.\n  text(text, marks) {\n    let type = this.nodes.text\n    return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks))\n  }\n\n  // :: (union<string, MarkType>, ?Object)  Mark\n  // Create a mark with the given type and attributes.\n  mark(type, attrs) {\n    if (typeof type == \"string\") type = this.marks[type]\n    return type.create(attrs)\n  }\n\n  // :: (Object)  Node\n  // Deserialize a node from its JSON representation. This method is\n  // bound.\n  nodeFromJSON(json) {\n    return Node.fromJSON(this, json)\n  }\n\n  // :: (Object)  Mark\n  // Deserialize a mark from its JSON representation. This method is\n  // bound.\n  markFromJSON(json) {\n    return Mark.fromJSON(this, json)\n  }\n\n  nodeType(name) {\n    let found = this.nodes[name]\n    if (!found) throw new RangeError(\"Unknown node type: \" + name)\n    return found\n  }\n}\n\nfunction gatherMarks(schema, marks) {\n  let found = []\n  for (let i = 0; i < marks.length; i++) {\n    let name = marks[i], mark = schema.marks[name], ok = mark\n    if (mark) {\n      found.push(mark)\n    } else {\n      for (let prop in schema.marks) {\n        let mark = schema.marks[prop]\n        if (name == \"_\" || (mark.spec.group && mark.spec.group.split(\" \").indexOf(name) > -1))\n          found.push(ok = mark)\n      }\n    }\n    if (!ok) throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\")\n  }\n  return found\n}\n","import {Fragment} from \"./fragment\"\nimport {Slice} from \"./replace\"\nimport {Mark} from \"./mark\"\n\n// ParseOptions:: interface\n// These are the options recognized by the\n// [`parse`](#model.DOMParser.parse) and\n// [`parseSlice`](#model.DOMParser.parseSlice) methods.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   By default, whitespace is collapsed as per HTML's rules. Pass\n//   `true` to preserve whitespace, but normalize newlines to\n//   spaces, and `\"full\"` to preserve whitespace entirely.\n//\n//   findPositions:: ?[{node: dom.Node, offset: number}]\n//   When given, the parser will, beside parsing the content,\n//   record the document positions of the given DOM positions. It\n//   will do so by writing to the objects, adding a `pos` property\n//   that holds the document position. DOM positions that are not\n//   in the parsed content will not be written to.\n//\n//   from:: ?number\n//   The child node index to start parsing from.\n//\n//   to:: ?number\n//   The child node index to stop parsing at.\n//\n//   topNode:: ?Node\n//   By default, the content is parsed into the schema's default\n//   [top node type](#model.Schema.topNodeType). You can pass this\n//   option to use the type and attributes from a different node\n//   as the top container.\n//\n//   topMatch:: ?ContentMatch\n//   Provide the starting content match that content parsed into the\n//   top node is matched against.\n//\n//   context:: ?ResolvedPos\n//   A set of additional nodes to count as\n//   [context](#model.ParseRule.context) when parsing, above the\n//   given [top node](#model.ParseOptions.topNode).\n\n// ParseRule:: interface\n// A value that describes how to parse a given DOM node or inline\n// style as a ProseMirror node or mark.\n//\n//   tag:: ?string\n//   A CSS selector describing the kind of DOM elements to match. A\n//   single rule should have _either_ a `tag` or a `style` property.\n//\n//   namespace:: ?string\n//   The namespace to match. This should be used with `tag`.\n//   Nodes are only matched when the namespace matches or this property\n//   is null.\n//\n//   style:: ?string\n//   A CSS property name to match. When given, this rule matches\n//   inline styles that list that property. May also have the form\n//   `\"property=value\"`, in which case the rule only matches if the\n//   property's value exactly matches the given value. (For more\n//   complicated filters, use [`getAttrs`](#model.ParseRule.getAttrs)\n//   and return false to indicate that the match failed.) Rules\n//   matching styles may only produce [marks](#model.ParseRule.mark),\n//   not nodes.\n//\n//   priority:: ?number\n//   Can be used to change the order in which the parse rules in a\n//   schema are tried. Those with higher priority come first. Rules\n//   without a priority are counted as having priority 50. This\n//   property is only meaningful in a schemawhen directly\n//   constructing a parser, the order of the rule array is used.\n//\n//   consuming:: ?boolean\n//   By default, when a rule matches an element or style, no further\n//   rules get a chance to match it. By setting this to `false`, you\n//   indicate that even when this rule matches, other rules that come\n//   after it should also run.\n//\n//   context:: ?string\n//   When given, restricts this rule to only match when the current\n//   contextthe parent nodes into which the content is being\n//   parsedmatches this expression. Should contain one or more node\n//   names or node group names followed by single or double slashes.\n//   For example `\"paragraph/\"` means the rule only matches when the\n//   parent node is a paragraph, `\"blockquote/paragraph/\"` restricts\n//   it to be in a paragraph that is inside a blockquote, and\n//   `\"section//\"` matches any position inside a sectiona double\n//   slash matches any sequence of ancestor nodes. To allow multiple\n//   different contexts, they can be separated by a pipe (`|`)\n//   character, as in `\"blockquote/|list_item/\"`.\n//\n//   node:: ?string\n//   The name of the node type to create when this rule matches. Only\n//   valid for rules with a `tag` property, not for style rules. Each\n//   rule should have one of a `node`, `mark`, or `ignore` property\n//   (except when it appears in a [node](#model.NodeSpec.parseDOM) or\n//   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`\n//   or `mark` property will be derived from its position).\n//\n//   mark:: ?string\n//   The name of the mark type to wrap the matched content in.\n//\n//   ignore:: ?bool\n//   When true, ignore content that matches this rule.\n//\n//   closeParent:: ?bool\n//   When true, finding an element that matches this rule will close\n//   the current node.\n//\n//   skip:: ?bool\n//   When true, ignore the node that matches this rule, but do parse\n//   its content.\n//\n//   attrs:: ?Object\n//   Attributes for the node or mark created by this rule. When\n//   `getAttrs` is provided, it takes precedence.\n//\n//   getAttrs:: ?(union<dom.Node, string>)  ?union<Object, false>\n//   A function used to compute the attributes for the node or mark\n//   created by this rule. Can also be used to describe further\n//   conditions the DOM element or style must match. When it returns\n//   `false`, the rule won't match. When it returns null or undefined,\n//   that is interpreted as an empty/default set of attributes.\n//\n//   Called with a DOM Element for `tag` rules, and with a string (the\n//   style's value) for `style` rules.\n//\n//   contentElement:: ?union<string, (dom.Node)  dom.Node>\n//   For `tag` rules that produce non-leaf nodes or marks, by default\n//   the content of the DOM element is parsed as content of the mark\n//   or node. If the child nodes are in a descendent node, this may be\n//   a CSS selector string that the parser must use to find the actual\n//   content element, or a function that returns the actual content\n//   element to the parser.\n//\n//   getContent:: ?(dom.Node, schema: Schema)  Fragment\n//   Can be used to override the content of a matched node. When\n//   present, instead of parsing the node's child nodes, the result of\n//   this function is used.\n//\n//   preserveWhitespace:: ?union<bool, \"full\">\n//   Controls whether whitespace should be preserved when parsing the\n//   content inside the matched element. `false` means whitespace may\n//   be collapsed, `true` means that whitespace should be preserved\n//   but newlines normalized to spaces, and `\"full\"` means that\n//   newlines should also be preserved.\n\n// ::- A DOM parser represents a strategy for parsing DOM content into\n// a ProseMirror document conforming to a given schema. Its behavior\n// is defined by an array of [rules](#model.ParseRule).\nexport class DOMParser {\n  // :: (Schema, [ParseRule])\n  // Create a parser that targets the given schema, using the given\n  // parsing rules.\n  constructor(schema, rules) {\n    // :: Schema\n    // The schema into which the parser parses.\n    this.schema = schema\n    // :: [ParseRule]\n    // The set of [parse rules](#model.ParseRule) that the parser\n    // uses, in order of precedence.\n    this.rules = rules\n    this.tags = []\n    this.styles = []\n\n    rules.forEach(rule => {\n      if (rule.tag) this.tags.push(rule)\n      else if (rule.style) this.styles.push(rule)\n    })\n\n    // Only normalize list elements when lists in the schema can't directly contain themselves\n    this.normalizeLists = !this.tags.some(r => {\n      if (!/^(ul|ol)\\b/.test(r.tag) || !r.node) return false\n      let node = schema.nodes[r.node]\n      return node.contentMatch.matchType(node)\n    })\n  }\n\n  // :: (dom.Node, ?ParseOptions)  Node\n  // Parse a document from the content of a DOM node.\n  parse(dom, options = {}) {\n    let context = new ParseContext(this, options, false)\n    context.addAll(dom, null, options.from, options.to)\n    return context.finish()\n  }\n\n  // :: (dom.Node, ?ParseOptions)  Slice\n  // Parses the content of the given DOM node, like\n  // [`parse`](#model.DOMParser.parse), and takes the same set of\n  // options. But unlike that method, which produces a whole node,\n  // this one returns a slice that is open at the sides, meaning that\n  // the schema constraints aren't applied to the start of nodes to\n  // the left of the input and the end of nodes at the end.\n  parseSlice(dom, options = {}) {\n    let context = new ParseContext(this, options, true)\n    context.addAll(dom, null, options.from, options.to)\n    return Slice.maxOpen(context.finish())\n  }\n\n  matchTag(dom, context, after) {\n    for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {\n      let rule = this.tags[i]\n      if (matches(dom, rule.tag) &&\n          (rule.namespace === undefined || dom.namespaceURI == rule.namespace) &&\n          (!rule.context || context.matchesContext(rule.context))) {\n        if (rule.getAttrs) {\n          let result = rule.getAttrs(dom)\n          if (result === false) continue\n          rule.attrs = result\n        }\n        return rule\n      }\n    }\n  }\n\n  matchStyle(prop, value, context, after) {\n    for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {\n      let rule = this.styles[i]\n      if (rule.style.indexOf(prop) != 0 ||\n          rule.context && !context.matchesContext(rule.context) ||\n          // Test that the style string either precisely matches the prop,\n          // or has an '=' sign after the prop, followed by the given\n          // value.\n          rule.style.length > prop.length &&\n          (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value))\n        continue\n      if (rule.getAttrs) {\n        let result = rule.getAttrs(value)\n        if (result === false) continue\n        rule.attrs = result\n      }\n      return rule\n    }\n  }\n\n  // : (Schema)  [ParseRule]\n  static schemaRules(schema) {\n    let result = []\n    function insert(rule) {\n      let priority = rule.priority == null ? 50 : rule.priority, i = 0\n      for (; i < result.length; i++) {\n        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority\n        if (nextPriority < priority) break\n      }\n      result.splice(i, 0, rule)\n    }\n\n    for (let name in schema.marks) {\n      let rules = schema.marks[name].spec.parseDOM\n      if (rules) rules.forEach(rule => {\n        insert(rule = copy(rule))\n        rule.mark = name\n      })\n    }\n    for (let name in schema.nodes) {\n      let rules = schema.nodes[name].spec.parseDOM\n      if (rules) rules.forEach(rule => {\n        insert(rule = copy(rule))\n        rule.node = name\n      })\n    }\n    return result\n  }\n\n  // :: (Schema)  DOMParser\n  // Construct a DOM parser using the parsing rules listed in a\n  // schema's [node specs](#model.NodeSpec.parseDOM), reordered by\n  // [priority](#model.ParseRule.priority).\n  static fromSchema(schema) {\n    return schema.cached.domParser ||\n      (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)))\n  }\n}\n\n// : Object<bool> The block-level tags in HTML5\nconst blockTags = {\n  address: true, article: true, aside: true, blockquote: true, canvas: true,\n  dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,\n  footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,\n  h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,\n  output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true\n}\n\n// : Object<bool> The tags that we normally ignore.\nconst ignoreTags = {\n  head: true, noscript: true, object: true, script: true, style: true, title: true\n}\n\n// : Object<bool> List tags.\nconst listTags = {ol: true, ul: true}\n\n// Using a bitfield for node context options\nconst OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4\n\nfunction wsOptionsFor(type, preserveWhitespace, base) {\n  if (preserveWhitespace != null) return (preserveWhitespace ? OPT_PRESERVE_WS : 0) |\n    (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0)\n  return type && type.whitespace == \"pre\" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT\n}\n\nclass NodeContext {\n  constructor(type, attrs, marks, pendingMarks, solid, match, options) {\n    this.type = type\n    this.attrs = attrs\n    this.solid = solid\n    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch)\n    this.options = options\n    this.content = []\n    // Marks applied to this node itself\n    this.marks = marks\n    // Marks applied to its children\n    this.activeMarks = Mark.none\n    // Marks that can't apply here, but will be used in children if possible\n    this.pendingMarks = pendingMarks\n    // Nested Marks with same type\n    this.stashMarks = []\n  }\n\n  findWrapping(node) {\n    if (!this.match) {\n      if (!this.type) return []\n      let fill = this.type.contentMatch.fillBefore(Fragment.from(node))\n      if (fill) {\n        this.match = this.type.contentMatch.matchFragment(fill)\n      } else {\n        let start = this.type.contentMatch, wrap\n        if (wrap = start.findWrapping(node.type)) {\n          this.match = start\n          return wrap\n        } else {\n          return null\n        }\n      }\n    }\n    return this.match.findWrapping(node.type)\n  }\n\n  finish(openEnd) {\n    if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace\n      let last = this.content[this.content.length - 1], m\n      if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n        if (last.text.length == m[0].length) this.content.pop()\n        else this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length))\n      }\n    }\n    let content = Fragment.from(this.content)\n    if (!openEnd && this.match)\n      content = content.append(this.match.fillBefore(Fragment.empty, true))\n    return this.type ? this.type.create(this.attrs, content, this.marks) : content\n  }\n\n  popFromStashMark(mark) {\n    for (let i = this.stashMarks.length - 1; i >= 0; i--)\n      if (mark.eq(this.stashMarks[i])) return this.stashMarks.splice(i, 1)[0]\n  }\n\n  applyPending(nextType) {\n    for (let i = 0, pending = this.pendingMarks; i < pending.length; i++) {\n      let mark = pending[i]\n      if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) &&\n          !mark.isInSet(this.activeMarks)) {\n        this.activeMarks = mark.addToSet(this.activeMarks)\n        this.pendingMarks = mark.removeFromSet(this.pendingMarks)\n      }\n    }\n  }\n\n  inlineContext(node) {\n    if (this.type) return this.type.inlineContent\n    if (this.content.length) return this.content[0].isInline\n    return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase())\n  }\n}\n\nclass ParseContext {\n  // : (DOMParser, Object)\n  constructor(parser, options, open) {\n    // : DOMParser The parser we are using.\n    this.parser = parser\n    // : Object The options passed to this parse.\n    this.options = options\n    this.isOpen = open\n    let topNode = options.topNode, topContext\n    let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (open ? OPT_OPEN_LEFT : 0)\n    if (topNode)\n      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true,\n                                   options.topMatch || topNode.type.contentMatch, topOptions)\n    else if (open)\n      topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions)\n    else\n      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions)\n    this.nodes = [topContext]\n    // : [Mark] The current set of marks\n    this.open = 0\n    this.find = options.findPositions\n    this.needsBlock = false\n  }\n\n  get top() {\n    return this.nodes[this.open]\n  }\n\n  // : (dom.Node)\n  // Add a DOM node to the content. Text is inserted as text node,\n  // otherwise, the node is passed to `addElement` or, if it has a\n  // `style` attribute, `addElementWithStyles`.\n  addDOM(dom) {\n    if (dom.nodeType == 3) {\n      this.addTextNode(dom)\n    } else if (dom.nodeType == 1) {\n      let style = dom.getAttribute(\"style\")\n      let marks = style ? this.readStyles(parseStyles(style)) : null, top = this.top\n      if (marks != null) for (let i = 0; i < marks.length; i++) this.addPendingMark(marks[i])\n      this.addElement(dom)\n      if (marks != null) for (let i = 0; i < marks.length; i++) this.removePendingMark(marks[i], top)\n    }\n  }\n\n  addTextNode(dom) {\n    let value = dom.nodeValue\n    let top = this.top\n    if (top.options & OPT_PRESERVE_WS_FULL ||\n        top.inlineContext(dom) ||\n        /[^ \\t\\r\\n\\u000c]/.test(value)) {\n      if (!(top.options & OPT_PRESERVE_WS)) {\n        value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \")\n        // If this starts with whitespace, and there is no node before it, or\n        // a hard break, or a text node that ends with whitespace, strip the\n        // leading space.\n        if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n          let nodeBefore = top.content[top.content.length - 1]\n          let domNodeBefore = dom.previousSibling\n          if (!nodeBefore ||\n              (domNodeBefore && domNodeBefore.nodeName == 'BR') ||\n              (nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)))\n            value = value.slice(1)\n        }\n      } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {\n        value = value.replace(/\\r?\\n|\\r/g, \" \")\n      } else {\n        value = value.replace(/\\r\\n?/g, \"\\n\")\n      }\n      if (value) this.insertNode(this.parser.schema.text(value))\n      this.findInText(dom)\n    } else {\n      this.findInside(dom)\n    }\n  }\n\n  // : (dom.Element, ?ParseRule)\n  // Try to find a handler for the given tag and use that to parse. If\n  // none is found, the element's content nodes are added directly.\n  addElement(dom, matchAfter) {\n    let name = dom.nodeName.toLowerCase(), ruleID\n    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) normalizeList(dom)\n    let rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) ||\n        (ruleID = this.parser.matchTag(dom, this, matchAfter))\n    if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n      this.findInside(dom)\n      this.ignoreFallback(dom)\n    } else if (!rule || rule.skip || rule.closeParent) {\n      if (rule && rule.closeParent) this.open = Math.max(0, this.open - 1)\n      else if (rule && rule.skip.nodeType) dom = rule.skip\n      let sync, top = this.top, oldNeedsBlock = this.needsBlock\n      if (blockTags.hasOwnProperty(name)) {\n        sync = true\n        if (!top.type) this.needsBlock = true\n      } else if (!dom.firstChild) {\n        this.leafFallback(dom)\n        return\n      }\n      this.addAll(dom)\n      if (sync) this.sync(top)\n      this.needsBlock = oldNeedsBlock\n    } else {\n      this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null)\n    }\n  }\n\n  // Called for leaf DOM nodes that would otherwise be ignored\n  leafFallback(dom) {\n    if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent)\n      this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\"))\n  }\n\n  // Called for ignored nodes\n  ignoreFallback(dom) {\n    // Ignored BR nodes should at least create an inline context\n    if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent))\n      this.findPlace(this.parser.schema.text(\"-\"))\n  }\n\n  // Run any style parser associated with the node's styles. Either\n  // return an array of marks, or null to indicate some of the styles\n  // had a rule with `ignore` set.\n  readStyles(styles) {\n    let marks = Mark.none\n    style: for (let i = 0; i < styles.length; i += 2) {\n      for (let after = null;;) {\n        let rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after)\n        if (!rule) continue style\n        if (rule.ignore) return null\n        marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks)\n        if (rule.consuming === false) after = rule\n        else break\n      }\n    }\n    return marks\n  }\n\n  // : (dom.Element, ParseRule)  bool\n  // Look up a handler for the given node. If none are found, return\n  // false. Otherwise, apply it, use its return value to drive the way\n  // the node's content is wrapped, and return true.\n  addElementByRule(dom, rule, continueAfter) {\n    let sync, nodeType, markType, mark\n    if (rule.node) {\n      nodeType = this.parser.schema.nodes[rule.node]\n      if (!nodeType.isLeaf) {\n        sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace)\n      } else if (!this.insertNode(nodeType.create(rule.attrs))) {\n        this.leafFallback(dom)\n      }\n    } else {\n      markType = this.parser.schema.marks[rule.mark]\n      mark = markType.create(rule.attrs)\n      this.addPendingMark(mark)\n    }\n    let startIn = this.top\n\n    if (nodeType && nodeType.isLeaf) {\n      this.findInside(dom)\n    } else if (continueAfter) {\n      this.addElement(dom, continueAfter)\n    } else if (rule.getContent) {\n      this.findInside(dom)\n      rule.getContent(dom, this.parser.schema).forEach(node => this.insertNode(node))\n    } else {\n      let contentDOM = rule.contentElement\n      if (typeof contentDOM == \"string\") contentDOM = dom.querySelector(contentDOM)\n      else if (typeof contentDOM == \"function\") contentDOM = contentDOM(dom)\n      if (!contentDOM) contentDOM = dom\n      this.findAround(dom, contentDOM, true)\n      this.addAll(contentDOM, sync)\n    }\n    if (sync) { this.sync(startIn); this.open-- }\n    if (mark) this.removePendingMark(mark, startIn)\n  }\n\n  // : (dom.Node, ?NodeBuilder, ?number, ?number)\n  // Add all child nodes between `startIndex` and `endIndex` (or the\n  // whole node, if not given). If `sync` is passed, use it to\n  // synchronize after every block element.\n  addAll(parent, sync, startIndex, endIndex) {\n    let index = startIndex || 0\n    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild,\n             end = endIndex == null ? null : parent.childNodes[endIndex];\n         dom != end; dom = dom.nextSibling, ++index) {\n      this.findAtPoint(parent, index)\n      this.addDOM(dom)\n      if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase()))\n        this.sync(sync)\n    }\n    this.findAtPoint(parent, index)\n  }\n\n  // Try to find a way to fit the given node type into the current\n  // context. May add intermediate wrappers and/or leave non-solid\n  // nodes that we're in.\n  findPlace(node) {\n    let route, sync\n    for (let depth = this.open; depth >= 0; depth--) {\n      let cx = this.nodes[depth]\n      let found = cx.findWrapping(node)\n      if (found && (!route || route.length > found.length)) {\n        route = found\n        sync = cx\n        if (!found.length) break\n      }\n      if (cx.solid) break\n    }\n    if (!route) return false\n    this.sync(sync)\n    for (let i = 0; i < route.length; i++)\n      this.enterInner(route[i], null, false)\n    return true\n  }\n\n  // : (Node)  ?Node\n  // Try to insert the given node, adjusting the context when needed.\n  insertNode(node) {\n    if (node.isInline && this.needsBlock && !this.top.type) {\n      let block = this.textblockFromContext()\n      if (block) this.enterInner(block)\n    }\n    if (this.findPlace(node)) {\n      this.closeExtra()\n      let top = this.top\n      top.applyPending(node.type)\n      if (top.match) top.match = top.match.matchType(node.type)\n      let marks = top.activeMarks\n      for (let i = 0; i < node.marks.length; i++)\n        if (!top.type || top.type.allowsMarkType(node.marks[i].type))\n          marks = node.marks[i].addToSet(marks)\n      top.content.push(node.mark(marks))\n      return true\n    }\n    return false\n  }\n\n  // : (NodeType, ?Object)  bool\n  // Try to start a node of the given type, adjusting the context when\n  // necessary.\n  enter(type, attrs, preserveWS) {\n    let ok = this.findPlace(type.create(attrs))\n    if (ok) this.enterInner(type, attrs, true, preserveWS)\n    return ok\n  }\n\n  // Open a node of the given type\n  enterInner(type, attrs, solid, preserveWS) {\n    this.closeExtra()\n    let top = this.top\n    top.applyPending(type)\n    top.match = top.match && top.match.matchType(type, attrs)\n    let options = wsOptionsFor(type, preserveWS, top.options)\n    if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0) options |= OPT_OPEN_LEFT\n    this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options))\n    this.open++\n  }\n\n  // Make sure all nodes above this.open are finished and added to\n  // their parents\n  closeExtra(openEnd) {\n    let i = this.nodes.length - 1\n    if (i > this.open) {\n      for (; i > this.open; i--) this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd))\n      this.nodes.length = this.open + 1\n    }\n  }\n\n  finish() {\n    this.open = 0\n    this.closeExtra(this.isOpen)\n    return this.nodes[0].finish(this.isOpen || this.options.topOpen)\n  }\n\n  sync(to) {\n    for (let i = this.open; i >= 0; i--) if (this.nodes[i] == to) {\n      this.open = i\n      return\n    }\n  }\n\n  get currentPos() {\n    this.closeExtra()\n    let pos = 0\n    for (let i = this.open; i >= 0; i--) {\n      let content = this.nodes[i].content\n      for (let j = content.length - 1; j >= 0; j--)\n        pos += content[j].nodeSize\n      if (i) pos++\n    }\n    return pos\n  }\n\n  findAtPoint(parent, offset) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].node == parent && this.find[i].offset == offset)\n        this.find[i].pos = this.currentPos\n    }\n  }\n\n  findInside(parent) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))\n        this.find[i].pos = this.currentPos\n    }\n  }\n\n  findAround(parent, content, before) {\n    if (parent != content && this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n        let pos = content.compareDocumentPosition(this.find[i].node)\n        if (pos & (before ? 2 : 4))\n          this.find[i].pos = this.currentPos\n      }\n    }\n  }\n\n  findInText(textNode) {\n    if (this.find) for (let i = 0; i < this.find.length; i++) {\n      if (this.find[i].node == textNode)\n        this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset)\n    }\n  }\n\n  // : (string)  bool\n  // Determines whether the given [context\n  // string](#ParseRule.context) matches this context.\n  matchesContext(context) {\n    if (context.indexOf(\"|\") > -1)\n      return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this)\n\n    let parts = context.split(\"/\")\n    let option = this.options.context\n    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type)\n    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1)\n    let match = (i, depth) => {\n      for (; i >= 0; i--) {\n        let part = parts[i]\n        if (part == \"\") {\n          if (i == parts.length - 1 || i == 0) continue\n          for (; depth >= minDepth; depth--)\n            if (match(i - 1, depth)) return true\n          return false\n        } else {\n          let next = depth > 0 || (depth == 0 && useRoot) ? this.nodes[depth].type\n              : option && depth >= minDepth ? option.node(depth - minDepth).type\n              : null\n          if (!next || (next.name != part && next.groups.indexOf(part) == -1))\n            return false\n          depth--\n        }\n      }\n      return true\n    }\n    return match(parts.length - 1, this.open)\n  }\n\n  textblockFromContext() {\n    let $context = this.options.context\n    if ($context) for (let d = $context.depth; d >= 0; d--) {\n      let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType\n      if (deflt && deflt.isTextblock && deflt.defaultAttrs) return deflt\n    }\n    for (let name in this.parser.schema.nodes) {\n      let type = this.parser.schema.nodes[name]\n      if (type.isTextblock && type.defaultAttrs) return type\n    }\n  }\n\n  addPendingMark(mark) {\n    let found = findSameMarkInSet(mark, this.top.pendingMarks)\n    if (found) this.top.stashMarks.push(found)\n    this.top.pendingMarks = mark.addToSet(this.top.pendingMarks)\n  }\n\n  removePendingMark(mark, upto) {\n    for (let depth = this.open; depth >= 0; depth--) {\n      let level = this.nodes[depth]\n      let found = level.pendingMarks.lastIndexOf(mark)\n      if (found > -1) {\n        level.pendingMarks = mark.removeFromSet(level.pendingMarks)\n      } else {\n        level.activeMarks = mark.removeFromSet(level.activeMarks)\n        let stashMark = level.popFromStashMark(mark)\n        if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))\n          level.activeMarks = stashMark.addToSet(level.activeMarks)\n      }\n      if (level == upto) break\n    }\n  }\n}\n\n// Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\nfunction normalizeList(dom) {\n  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child)\n      child = prevItem\n    } else if (name == \"li\") {\n      prevItem = child\n    } else if (name) {\n      prevItem = null\n    }\n  }\n}\n\n// Apply a CSS selector.\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector)\n}\n\n// : (string)  [string]\n// Tokenize a style attribute into property/value pairs.\nfunction parseStyles(style) {\n  let re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g, m, result = []\n  while (m = re.exec(style)) result.push(m[1], m[2].trim())\n  return result\n}\n\nfunction copy(obj) {\n  let copy = {}\n  for (let prop in obj) copy[prop] = obj[prop]\n  return copy\n}\n\n// Used when finding a mark at the top level of a fragment parse.\n// Checks whether it would be reasonable to apply a given mark type to\n// a given node, by looking at the way the mark occurs in the schema.\nfunction markMayApply(markType, nodeType) {\n  let nodes = nodeType.schema.nodes\n  for (let name in nodes) {\n    let parent = nodes[name]\n    if (!parent.allowsMarkType(markType)) continue\n    let seen = [], scan = match => {\n      seen.push(match)\n      for (let i = 0; i < match.edgeCount; i++) {\n        let {type, next} = match.edge(i)\n        if (type == nodeType) return true\n        if (seen.indexOf(next) < 0 && scan(next)) return true\n      }\n    }\n    if (scan(parent.contentMatch)) return true\n  }\n}\n\nfunction findSameMarkInSet(mark, set) {\n  for (let i = 0; i < set.length; i++) {\n    if (mark.eq(set[i])) return set[i]\n  }\n}\n","// DOMOutputSpec:: interface\n// A description of a DOM structure. Can be either a string, which is\n// interpreted as a text node, a DOM node, which is interpreted as\n// itself, a `{dom: Node, contentDOM: ?Node}` object, or an array.\n//\n// An array describes a DOM element. The first value in the array\n// should be a stringthe name of the DOM element, optionally prefixed\n// by a namespace URL and a space. If the second element is plain\n// object, it is interpreted as a set of attributes for the element.\n// Any elements after that (including the 2nd if it's not an attribute\n// object) are interpreted as children of the DOM elements, and must\n// either be valid `DOMOutputSpec` values, or the number zero.\n//\n// The number zero (pronounced hole) is used to indicate the place\n// where a node's child nodes should be inserted. If it occurs in an\n// output spec, it should be the only child element in its parent\n// node.\n\n// ::- A DOM serializer knows how to convert ProseMirror nodes and\n// marks of various types to DOM nodes.\nexport class DOMSerializer {\n  // :: (Object<(node: Node)  DOMOutputSpec>, Object<?(mark: Mark, inline: bool)  DOMOutputSpec>)\n  // Create a serializer. `nodes` should map node names to functions\n  // that take a node and return a description of the corresponding\n  // DOM. `marks` does the same for mark names, but also gets an\n  // argument that tells it whether the mark's content is block or\n  // inline content (for typical use, it'll always be inline). A mark\n  // serializer may be `null` to indicate that marks of that type\n  // should not be serialized.\n  constructor(nodes, marks) {\n    // :: Object<(node: Node)  DOMOutputSpec>\n    // The node serialization functions.\n    this.nodes = nodes || {}\n    // :: Object<?(mark: Mark, inline: bool)  DOMOutputSpec>\n    // The mark serialization functions.\n    this.marks = marks || {}\n  }\n\n  // :: (Fragment, ?Object)  dom.DocumentFragment\n  // Serialize the content of this fragment to a DOM fragment. When\n  // not in the browser, the `document` option, containing a DOM\n  // document, should be passed so that the serializer can create\n  // nodes.\n  serializeFragment(fragment, options = {}, target) {\n    if (!target) target = doc(options).createDocumentFragment()\n\n    let top = target, active = null\n    fragment.forEach(node => {\n      if (active || node.marks.length) {\n        if (!active) active = []\n        let keep = 0, rendered = 0\n        while (keep < active.length && rendered < node.marks.length) {\n          let next = node.marks[rendered]\n          if (!this.marks[next.type.name]) { rendered++; continue }\n          if (!next.eq(active[keep]) || next.type.spec.spanning === false) break\n          keep += 2; rendered++\n        }\n        while (keep < active.length) {\n          top = active.pop()\n          active.pop()\n        }\n        while (rendered < node.marks.length) {\n          let add = node.marks[rendered++]\n          let markDOM = this.serializeMark(add, node.isInline, options)\n          if (markDOM) {\n            active.push(add, top)\n            top.appendChild(markDOM.dom)\n            top = markDOM.contentDOM || markDOM.dom\n          }\n        }\n      }\n      top.appendChild(this.serializeNodeInner(node, options))\n    })\n\n    return target\n  }\n\n  serializeNodeInner(node, options = {}) {\n    let {dom, contentDOM} =\n        DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node))\n    if (contentDOM) {\n      if (node.isLeaf)\n        throw new RangeError(\"Content hole not allowed in a leaf node spec\")\n      if (options.onContent)\n        options.onContent(node, contentDOM, options)\n      else\n        this.serializeFragment(node.content, options, contentDOM)\n    }\n    return dom\n  }\n\n  // :: (Node, ?Object)  dom.Node\n  // Serialize this node to a DOM node. This can be useful when you\n  // need to serialize a part of a document, as opposed to the whole\n  // document. To serialize a whole document, use\n  // [`serializeFragment`](#model.DOMSerializer.serializeFragment) on\n  // its [content](#model.Node.content).\n  serializeNode(node, options = {}) {\n    let dom = this.serializeNodeInner(node, options)\n    for (let i = node.marks.length - 1; i >= 0; i--) {\n      let wrap = this.serializeMark(node.marks[i], node.isInline, options)\n      if (wrap) {\n        ;(wrap.contentDOM || wrap.dom).appendChild(dom)\n        dom = wrap.dom\n      }\n    }\n    return dom\n  }\n\n  serializeMark(mark, inline, options = {}) {\n    let toDOM = this.marks[mark.type.name]\n    return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline))\n  }\n\n  // :: (dom.Document, DOMOutputSpec)  {dom: dom.Node, contentDOM: ?dom.Node}\n  // Render an [output spec](#model.DOMOutputSpec) to a DOM node. If\n  // the spec has a hole (zero) in it, `contentDOM` will point at the\n  // node with the hole.\n  static renderSpec(doc, structure, xmlNS = null) {\n    if (typeof structure == \"string\")\n      return {dom: doc.createTextNode(structure)}\n    if (structure.nodeType != null)\n      return {dom: structure}\n    if (structure.dom && structure.dom.nodeType != null)\n      return structure\n    let tagName = structure[0], space = tagName.indexOf(\" \")\n    if (space > 0) {\n      xmlNS = tagName.slice(0, space)\n      tagName = tagName.slice(space + 1)\n    }\n    let contentDOM = null, dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName)\n    let attrs = structure[1], start = 1\n    if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n      start = 2\n      for (let name in attrs) if (attrs[name] != null) {\n        let space = name.indexOf(\" \")\n        if (space > 0) dom.setAttributeNS(name.slice(0, space), name.slice(space + 1), attrs[name])\n        else dom.setAttribute(name, attrs[name])\n      }\n    }\n    for (let i = start; i < structure.length; i++) {\n      let child = structure[i]\n      if (child === 0) {\n        if (i < structure.length - 1 || i > start)\n          throw new RangeError(\"Content hole must be the only child of its parent node\")\n        return {dom, contentDOM: dom}\n      } else {\n        let {dom: inner, contentDOM: innerContent} = DOMSerializer.renderSpec(doc, child, xmlNS)\n        dom.appendChild(inner)\n        if (innerContent) {\n          if (contentDOM) throw new RangeError(\"Multiple content holes\")\n          contentDOM = innerContent\n        }\n      }\n    }\n    return {dom, contentDOM}\n  }\n\n  // :: (Schema)  DOMSerializer\n  // Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)\n  // properties in a schema's node and mark specs.\n  static fromSchema(schema) {\n    return schema.cached.domSerializer ||\n      (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)))\n  }\n\n  // : (Schema)  Object<(node: Node)  DOMOutputSpec>\n  // Gather the serializers in a schema's node specs into an object.\n  // This can be useful as a base to build a custom serializer from.\n  static nodesFromSchema(schema) {\n    let result = gatherToDOM(schema.nodes)\n    if (!result.text) result.text = node => node.text\n    return result\n  }\n\n  // : (Schema)  Object<(mark: Mark)  DOMOutputSpec>\n  // Gather the serializers in a schema's mark specs into an object.\n  static marksFromSchema(schema) {\n    return gatherToDOM(schema.marks)\n  }\n}\n\nfunction gatherToDOM(obj) {\n  let result = {}\n  for (let name in obj) {\n    let toDOM = obj[name].spec.toDOM\n    if (toDOM) result[name] = toDOM\n  }\n  return result\n}\n\nfunction doc(options) {\n  // declare global: window\n  return options.document || window.document\n}\n","import {findWrapping, liftTarget, canSplit, ReplaceAroundStep} from \"prosemirror-transform\"\nimport {Slice, Fragment, NodeRange} from \"prosemirror-model\"\n\nconst olDOM = [\"ol\", 0], ulDOM = [\"ul\", 0], liDOM = [\"li\", 0]\n\n// :: NodeSpec\n// An ordered list [node spec](#model.NodeSpec). Has a single\n// attribute, `order`, which determines the number at which the list\n// starts counting, and defaults to 1. Represented as an `<ol>`\n// element.\nexport const orderedList = {\n  attrs: {order: {default: 1}},\n  parseDOM: [{tag: \"ol\", getAttrs(dom) {\n    return {order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1}\n  }}],\n  toDOM(node) {\n    return node.attrs.order == 1 ? olDOM : [\"ol\", {start: node.attrs.order}, 0]\n  }\n}\n\n// :: NodeSpec\n// A bullet list node spec, represented in the DOM as `<ul>`.\nexport const bulletList = {\n  parseDOM: [{tag: \"ul\"}],\n  toDOM() { return ulDOM }\n}\n\n// :: NodeSpec\n// A list item (`<li>`) spec.\nexport const listItem = {\n  parseDOM: [{tag: \"li\"}],\n  toDOM() { return liDOM },\n  defining: true\n}\n\nfunction add(obj, props) {\n  let copy = {}\n  for (let prop in obj) copy[prop] = obj[prop]\n  for (let prop in props) copy[prop] = props[prop]\n  return copy\n}\n\n// :: (OrderedMap<NodeSpec>, string, ?string)  OrderedMap<NodeSpec>\n// Convenience function for adding list-related node types to a map\n// specifying the nodes for a schema. Adds\n// [`orderedList`](#schema-list.orderedList) as `\"ordered_list\"`,\n// [`bulletList`](#schema-list.bulletList) as `\"bullet_list\"`, and\n// [`listItem`](#schema-list.listItem) as `\"list_item\"`.\n//\n// `itemContent` determines the content expression for the list items.\n// If you want the commands defined in this module to apply to your\n// list structure, it should have a shape like `\"paragraph block*\"` or\n// `\"paragraph (ordered_list | bullet_list)*\"`. `listGroup` can be\n// given to assign a group name to the list node types, for example\n// `\"block\"`.\nexport function addListNodes(nodes, itemContent, listGroup) {\n  return nodes.append({\n    ordered_list: add(orderedList, {content: \"list_item+\", group: listGroup}),\n    bullet_list: add(bulletList, {content: \"list_item+\", group: listGroup}),\n    list_item: add(listItem, {content: itemContent})\n  })\n}\n\n// :: (NodeType, ?Object)  (state: EditorState, dispatch: ?(tr: Transaction))  bool\n// Returns a command function that wraps the selection in a list with\n// the given type an attributes. If `dispatch` is null, only return a\n// value to indicate whether this is possible, but don't actually\n// perform the change.\nexport function wrapInList(listType, attrs) {\n  return function(state, dispatch) {\n    let {$from, $to} = state.selection\n    let range = $from.blockRange($to), doJoin = false, outerRange = range\n    if (!range) return false\n    // This is at the top of an existing list item\n    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {\n      // Don't do anything if this is the top of the list\n      if ($from.index(range.depth - 1) == 0) return false\n      let $insert = state.doc.resolve(range.start - 2)\n      outerRange = new NodeRange($insert, $insert, range.depth)\n      if (range.endIndex < range.parent.childCount)\n        range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth)\n      doJoin = true\n    }\n    let wrap = findWrapping(outerRange, listType, attrs, range)\n    if (!wrap) return false\n    if (dispatch) dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView())\n    return true\n  }\n}\n\nfunction doWrapInList(tr, range, wrappers, joinBefore, listType) {\n  let content = Fragment.empty\n  for (let i = wrappers.length - 1; i >= 0; i--)\n    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content))\n\n  tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end,\n                                new Slice(content, 0, 0), wrappers.length, true))\n\n  let found = 0\n  for (let i = 0; i < wrappers.length; i++) if (wrappers[i].type == listType) found = i + 1\n  let splitDepth = wrappers.length - found\n\n  let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent\n  for (let i = range.startIndex, e = range.endIndex, first = true; i < e; i++, first = false) {\n    if (!first && canSplit(tr.doc, splitPos, splitDepth)) {\n      tr.split(splitPos, splitDepth)\n      splitPos += 2 * splitDepth\n    }\n    splitPos += parent.child(i).nodeSize\n  }\n  return tr\n}\n\n// :: (NodeType)  (state: EditorState, dispatch: ?(tr: Transaction))  bool\n// Build a command that splits a non-empty textblock at the top level\n// of a list item by also splitting that list item.\nexport function splitListItem(itemType) {\n  return function(state, dispatch) {\n    let {$from, $to, node} = state.selection\n    if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) return false\n    let grandParent = $from.node(-1)\n    if (grandParent.type != itemType) return false\n    if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {\n      // In an empty block. If this is a nested list, the wrapping\n      // list item should be split. Otherwise, bail out and let next\n      // command handle lifting.\n      if ($from.depth == 2 || $from.node(-3).type != itemType ||\n          $from.index(-2) != $from.node(-2).childCount - 1) return false\n      if (dispatch) {\n        let wrap = Fragment.empty\n        let depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3\n        // Build a fragment containing empty versions of the structure\n        // from the outer list item to the parent node of the cursor\n        for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d--)\n          wrap = Fragment.from($from.node(d).copy(wrap))\n        let depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1\n            : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3\n        // Add a second list item with an empty default start node\n        wrap = wrap.append(Fragment.from(itemType.createAndFill()))\n        let start = $from.before($from.depth - (depthBefore - 1))\n        let tr = state.tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0))\n        let sel = -1\n        tr.doc.nodesBetween(start, tr.doc.content.size, (node, pos) => {\n          if (sel > -1) return false\n          if (node.isTextblock && node.content.size == 0) sel = pos + 1\n        })\n        if (sel > -1) tr.setSelection(state.selection.constructor.near(tr.doc.resolve(sel)))\n        dispatch(tr.scrollIntoView())\n      }\n      return true\n    }\n    let nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null\n    let tr = state.tr.delete($from.pos, $to.pos)\n    let types = nextType && [null, {type: nextType}]\n    if (!canSplit(tr.doc, $from.pos, 2, types)) return false\n    if (dispatch) dispatch(tr.split($from.pos, 2, types).scrollIntoView())\n    return true\n  }\n}\n\n// :: (NodeType)  (state: EditorState, dispatch: ?(tr: Transaction))  bool\n// Create a command to lift the list item around the selection up into\n// a wrapping list.\nexport function liftListItem(itemType) {\n  return function(state, dispatch) {\n    let {$from, $to} = state.selection\n    let range = $from.blockRange($to, node => node.childCount && node.firstChild.type == itemType)\n    if (!range) return false\n    if (!dispatch) return true\n    if ($from.node(range.depth - 1).type == itemType) // Inside a parent list\n      return liftToOuterList(state, dispatch, itemType, range)\n    else // Outer list node\n      return liftOutOfList(state, dispatch, range)\n  }\n}\n\nfunction liftToOuterList(state, dispatch, itemType, range) {\n  let tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth)\n  if (end < endOfList) {\n    // There are siblings after the lifted items, which must become\n    // children of the last item\n    tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList,\n                                  new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true))\n    range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth)\n  }\n  dispatch(tr.lift(range, liftTarget(range)).scrollIntoView())\n  return true\n}\n\nfunction liftOutOfList(state, dispatch, range) {\n  let tr = state.tr, list = range.parent\n  // Merge the list items into a single big item\n  for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {\n    pos -= list.child(i).nodeSize\n    tr.delete(pos - 1, pos + 1)\n  }\n  let $start = tr.doc.resolve(range.start), item = $start.nodeAfter\n  if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize) return false\n  let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount\n  let parent = $start.node(-1), indexBefore = $start.index(-1)\n  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1,\n                         item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))\n    return false\n  let start = $start.pos, end = start + item.nodeSize\n  // Strip off the surrounding list. At the sides where we're not at\n  // the end of the list, the existing list is closed. At sides where\n  // this is the end, it is overwritten to its end.\n  tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1,\n                                new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty)))\n                                          .append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))),\n                                          atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1))\n  dispatch(tr.scrollIntoView())\n  return true\n}\n\n// :: (NodeType)  (state: EditorState, dispatch: ?(tr: Transaction))  bool\n// Create a command to sink the list item around the selection down\n// into an inner list.\nexport function sinkListItem(itemType) {\n  return function(state, dispatch) {\n    let {$from, $to} = state.selection\n    let range = $from.blockRange($to, node => node.childCount && node.firstChild.type == itemType)\n    if (!range) return false\n    let startIndex = range.startIndex\n    if (startIndex == 0) return false\n    let parent = range.parent, nodeBefore = parent.child(startIndex - 1)\n    if (nodeBefore.type != itemType) return false\n\n    if (dispatch) {\n      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type\n      let inner = Fragment.from(nestedBefore ? itemType.create() : null)\n      let slice = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))),\n                            nestedBefore ? 3 : 1, 0)\n      let before = range.start, after = range.end\n      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after,\n                                                   before, after, slice, 1, true))\n               .scrollIntoView())\n    }\n    return true\n  }\n}\n","import {Slice, Fragment} from \"prosemirror-model\"\nimport {ReplaceStep, ReplaceAroundStep} from \"prosemirror-transform\"\n\nconst classesById = Object.create(null)\n\n// ::- Superclass for editor selections. Every selection type should\n// extend this. Should not be instantiated directly.\nexport class Selection {\n  // :: (ResolvedPos, ResolvedPos, ?[SelectionRange])\n  // Initialize a selection with the head and anchor and ranges. If no\n  // ranges are given, constructs a single range across `$anchor` and\n  // `$head`.\n  constructor($anchor, $head, ranges) {\n    // :: [SelectionRange]\n    // The ranges covered by the selection.\n    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))]\n    // :: ResolvedPos\n    // The resolved anchor of the selection (the side that stays in\n    // place when the selection is modified).\n    this.$anchor = $anchor\n    // :: ResolvedPos\n    // The resolved head of the selection (the side that moves when\n    // the selection is modified).\n    this.$head = $head\n  }\n\n  // :: number\n  // The selection's anchor, as an unresolved position.\n  get anchor() { return this.$anchor.pos }\n\n  // :: number\n  // The selection's head.\n  get head() { return this.$head.pos }\n\n  // :: number\n  // The lower bound of the selection's main range.\n  get from() { return this.$from.pos }\n\n  // :: number\n  // The upper bound of the selection's main range.\n  get to() { return this.$to.pos }\n\n  // :: ResolvedPos\n  // The resolved lower  bound of the selection's main range.\n  get $from() {\n    return this.ranges[0].$from\n  }\n\n  // :: ResolvedPos\n  // The resolved upper bound of the selection's main range.\n  get $to() {\n    return this.ranges[0].$to\n  }\n\n  // :: bool\n  // Indicates whether the selection contains any content.\n  get empty() {\n    let ranges = this.ranges\n    for (let i = 0; i < ranges.length; i++)\n      if (ranges[i].$from.pos != ranges[i].$to.pos) return false\n    return true\n  }\n\n  // eq:: (Selection)  bool\n  // Test whether the selection is the same as another selection.\n\n  // map:: (doc: Node, mapping: Mappable)  Selection\n  // Map this selection through a [mappable](#transform.Mappable) thing. `doc`\n  // should be the new document to which we are mapping.\n\n  // :: ()  Slice\n  // Get the content of this selection as a slice.\n  content() {\n    return this.$from.node(0).slice(this.from, this.to, true)\n  }\n\n  // :: (Transaction, ?Slice)\n  // Replace the selection with a slice or, if no slice is given,\n  // delete the selection. Will append to the given transaction.\n  replace(tr, content = Slice.empty) {\n    // Put the new selection at the position after the inserted\n    // content. When that ended in an inline node, search backwards,\n    // to get the position after that node. If not, search forward.\n    let lastNode = content.content.lastChild, lastParent = null\n    for (let i = 0; i < content.openEnd; i++) {\n      lastParent = lastNode\n      lastNode = lastNode.lastChild\n    }\n\n    let mapFrom = tr.steps.length, ranges = this.ranges\n    for (let i = 0; i < ranges.length; i++) {\n      let {$from, $to} = ranges[i], mapping = tr.mapping.slice(mapFrom)\n      tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content)\n      if (i == 0)\n        selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1)\n    }\n  }\n\n  // :: (Transaction, Node)\n  // Replace the selection with the given node, appending the changes\n  // to the given transaction.\n  replaceWith(tr, node) {\n    let mapFrom = tr.steps.length, ranges = this.ranges\n    for (let i = 0; i < ranges.length; i++) {\n      let {$from, $to} = ranges[i], mapping = tr.mapping.slice(mapFrom)\n      let from = mapping.map($from.pos), to = mapping.map($to.pos)\n      if (i) {\n        tr.deleteRange(from, to)\n      } else {\n        tr.replaceRangeWith(from, to, node)\n        selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1)\n      }\n    }\n  }\n\n  // toJSON:: ()  Object\n  // Convert the selection to a JSON representation. When implementing\n  // this for a custom selection class, make sure to give the object a\n  // `type` property whose value matches the ID under which you\n  // [registered](#state.Selection^jsonID) your class.\n\n  // :: (ResolvedPos, number, ?bool)  ?Selection\n  // Find a valid cursor or leaf node selection starting at the given\n  // position and searching back if `dir` is negative, and forward if\n  // positive. When `textOnly` is true, only consider cursor\n  // selections. Will return null when no valid selection position is\n  // found.\n  static findFrom($pos, dir, textOnly) {\n    let inner = $pos.parent.inlineContent ? new TextSelection($pos)\n        : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly)\n    if (inner) return inner\n\n    for (let depth = $pos.depth - 1; depth >= 0; depth--) {\n      let found = dir < 0\n          ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly)\n          : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly)\n      if (found) return found\n    }\n  }\n\n  // :: (ResolvedPos, ?number)  Selection\n  // Find a valid cursor or leaf node selection near the given\n  // position. Searches forward first by default, but if `bias` is\n  // negative, it will search backwards first.\n  static near($pos, bias = 1) {\n    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0))\n  }\n\n  // :: (Node)  Selection\n  // Find the cursor or leaf node selection closest to the start of\n  // the given document. Will return an\n  // [`AllSelection`](#state.AllSelection) if no valid position\n  // exists.\n  static atStart(doc) {\n    return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc)\n  }\n\n  // :: (Node)  Selection\n  // Find the cursor or leaf node selection closest to the end of the\n  // given document.\n  static atEnd(doc) {\n    return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc)\n  }\n\n  // :: (Node, Object)  Selection\n  // Deserialize the JSON representation of a selection. Must be\n  // implemented for custom classes (as a static class method).\n  static fromJSON(doc, json) {\n    if (!json || !json.type) throw new RangeError(\"Invalid input for Selection.fromJSON\")\n    let cls = classesById[json.type]\n    if (!cls) throw new RangeError(`No selection type ${json.type} defined`)\n    return cls.fromJSON(doc, json)\n  }\n\n  // :: (string, constructor<Selection>)\n  // To be able to deserialize selections from JSON, custom selection\n  // classes must register themselves with an ID string, so that they\n  // can be disambiguated. Try to pick something that's unlikely to\n  // clash with classes from other modules.\n  static jsonID(id, selectionClass) {\n    if (id in classesById) throw new RangeError(\"Duplicate use of selection JSON ID \" + id)\n    classesById[id] = selectionClass\n    selectionClass.prototype.jsonID = id\n    return selectionClass\n  }\n\n  // :: ()  SelectionBookmark\n  // Get a [bookmark](#state.SelectionBookmark) for this selection,\n  // which is a value that can be mapped without having access to a\n  // current document, and later resolved to a real selection for a\n  // given document again. (This is used mostly by the history to\n  // track and restore old selections.) The default implementation of\n  // this method just converts the selection to a text selection and\n  // returns the bookmark for that.\n  getBookmark() {\n    return TextSelection.between(this.$anchor, this.$head).getBookmark()\n  }\n}\n\n// :: bool\n// Controls whether, when a selection of this type is active in the\n// browser, the selected range should be visible to the user. Defaults\n// to `true`.\nSelection.prototype.visible = true\n\n// SelectionBookmark:: interface\n// A lightweight, document-independent representation of a selection.\n// You can define a custom bookmark type for a custom selection class\n// to make the history handle it well.\n//\n//   map:: (mapping: Mapping)  SelectionBookmark\n//   Map the bookmark through a set of changes.\n//\n//   resolve:: (doc: Node)  Selection\n//   Resolve the bookmark to a real selection again. This may need to\n//   do some error checking and may fall back to a default (usually\n//   [`TextSelection.between`](#state.TextSelection^between)) if\n//   mapping made the bookmark invalid.\n\n// ::- Represents a selected range in a document.\nexport class SelectionRange {\n  // :: (ResolvedPos, ResolvedPos)\n  constructor($from, $to) {\n    // :: ResolvedPos\n    // The lower bound of the range.\n    this.$from = $from\n    // :: ResolvedPos\n    // The upper bound of the range.\n    this.$to = $to\n  }\n}\n\n// ::- A text selection represents a classical editor selection, with\n// a head (the moving side) and anchor (immobile side), both of which\n// point into textblock nodes. It can be empty (a regular cursor\n// position).\nexport class TextSelection extends Selection {\n  // :: (ResolvedPos, ?ResolvedPos)\n  // Construct a text selection between the given points.\n  constructor($anchor, $head = $anchor) {\n    super($anchor, $head)\n  }\n\n  // :: ?ResolvedPos\n  // Returns a resolved position if this is a cursor selection (an\n  // empty text selection), and null otherwise.\n  get $cursor() { return this.$anchor.pos == this.$head.pos ? this.$head : null }\n\n  map(doc, mapping) {\n    let $head = doc.resolve(mapping.map(this.head))\n    if (!$head.parent.inlineContent) return Selection.near($head)\n    let $anchor = doc.resolve(mapping.map(this.anchor))\n    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head)\n  }\n\n  replace(tr, content = Slice.empty) {\n    super.replace(tr, content)\n    if (content == Slice.empty) {\n      let marks = this.$from.marksAcross(this.$to)\n      if (marks) tr.ensureMarks(marks)\n    }\n  }\n\n  eq(other) {\n    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head\n  }\n\n  getBookmark() {\n    return new TextBookmark(this.anchor, this.head)\n  }\n\n  toJSON() {\n    return {type: \"text\", anchor: this.anchor, head: this.head}\n  }\n\n  static fromJSON(doc, json) {\n    if (typeof json.anchor != \"number\" || typeof json.head != \"number\")\n      throw new RangeError(\"Invalid input for TextSelection.fromJSON\")\n    return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head))\n  }\n\n  // :: (Node, number, ?number)  TextSelection\n  // Create a text selection from non-resolved positions.\n  static create(doc, anchor, head = anchor) {\n    let $anchor = doc.resolve(anchor)\n    return new this($anchor, head == anchor ? $anchor : doc.resolve(head))\n  }\n\n  // :: (ResolvedPos, ResolvedPos, ?number)  Selection\n  // Return a text selection that spans the given positions or, if\n  // they aren't text positions, find a text selection near them.\n  // `bias` determines whether the method searches forward (default)\n  // or backwards (negative number) first. Will fall back to calling\n  // [`Selection.near`](#state.Selection^near) when the document\n  // doesn't contain a valid text position.\n  static between($anchor, $head, bias) {\n    let dPos = $anchor.pos - $head.pos\n    if (!bias || dPos) bias = dPos >= 0 ? 1 : -1\n    if (!$head.parent.inlineContent) {\n      let found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true)\n      if (found) $head = found.$head\n      else return Selection.near($head, bias)\n    }\n    if (!$anchor.parent.inlineContent) {\n      if (dPos == 0) {\n        $anchor = $head\n      } else {\n        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor\n        if (($anchor.pos < $head.pos) != (dPos < 0)) $anchor = $head\n      }\n    }\n    return new TextSelection($anchor, $head)\n  }\n}\n\nSelection.jsonID(\"text\", TextSelection)\n\nclass TextBookmark {\n  constructor(anchor, head) {\n    this.anchor = anchor\n    this.head = head\n  }\n  map(mapping) {\n    return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head))\n  }\n  resolve(doc) {\n    return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head))\n  }\n}\n\n// ::- A node selection is a selection that points at a single node.\n// All nodes marked [selectable](#model.NodeSpec.selectable) can be\n// the target of a node selection. In such a selection, `from` and\n// `to` point directly before and after the selected node, `anchor`\n// equals `from`, and `head` equals `to`..\nexport class NodeSelection extends Selection {\n  // :: (ResolvedPos)\n  // Create a node selection. Does not verify the validity of its\n  // argument.\n  constructor($pos) {\n    let node = $pos.nodeAfter\n    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize)\n    super($pos, $end)\n    // :: Node The selected node.\n    this.node = node\n  }\n\n  map(doc, mapping) {\n    let {deleted, pos} = mapping.mapResult(this.anchor)\n    let $pos = doc.resolve(pos)\n    if (deleted) return Selection.near($pos)\n    return new NodeSelection($pos)\n  }\n\n  content() {\n    return new Slice(Fragment.from(this.node), 0, 0)\n  }\n\n  eq(other) {\n    return other instanceof NodeSelection && other.anchor == this.anchor\n  }\n\n  toJSON() {\n    return {type: \"node\", anchor: this.anchor}\n  }\n\n  getBookmark() { return new NodeBookmark(this.anchor) }\n\n  static fromJSON(doc, json) {\n    if (typeof json.anchor != \"number\")\n      throw new RangeError(\"Invalid input for NodeSelection.fromJSON\")\n    return new NodeSelection(doc.resolve(json.anchor))\n  }\n\n  // :: (Node, number)  NodeSelection\n  // Create a node selection from non-resolved positions.\n  static create(doc, from) {\n    return new this(doc.resolve(from))\n  }\n\n  // :: (Node)  bool\n  // Determines whether the given node may be selected as a node\n  // selection.\n  static isSelectable(node) {\n    return !node.isText && node.type.spec.selectable !== false\n  }\n}\n\nNodeSelection.prototype.visible = false\n\nSelection.jsonID(\"node\", NodeSelection)\n\nclass NodeBookmark {\n  constructor(anchor) {\n    this.anchor = anchor\n  }\n  map(mapping) {\n    let {deleted, pos} = mapping.mapResult(this.anchor)\n    return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos)\n  }\n  resolve(doc) {\n    let $pos = doc.resolve(this.anchor), node = $pos.nodeAfter\n    if (node && NodeSelection.isSelectable(node)) return new NodeSelection($pos)\n    return Selection.near($pos)\n  }\n}\n\n// ::- A selection type that represents selecting the whole document\n// (which can not necessarily be expressed with a text selection, when\n// there are for example leaf block nodes at the start or end of the\n// document).\nexport class AllSelection extends Selection {\n  // :: (Node)\n  // Create an all-selection over the given document.\n  constructor(doc) {\n    super(doc.resolve(0), doc.resolve(doc.content.size))\n  }\n\n  replace(tr, content = Slice.empty) {\n    if (content == Slice.empty) {\n      tr.delete(0, tr.doc.content.size)\n      let sel = Selection.atStart(tr.doc)\n      if (!sel.eq(tr.selection)) tr.setSelection(sel)\n    } else {\n      super.replace(tr, content)\n    }\n  }\n\n  toJSON() { return {type: \"all\"} }\n\n  static fromJSON(doc) { return new AllSelection(doc) }\n\n  map(doc) { return new AllSelection(doc) }\n\n  eq(other) { return other instanceof AllSelection }\n\n  getBookmark() { return AllBookmark }\n}\n\nSelection.jsonID(\"all\", AllSelection)\n\nconst AllBookmark = {\n  map() { return this },\n  resolve(doc) { return new AllSelection(doc) }\n}\n\n// FIXME we'll need some awareness of text direction when scanning for selections\n\n// Try to find a selection inside the given node. `pos` points at the\n// position where the search starts. When `text` is true, only return\n// text selections.\nfunction findSelectionIn(doc, node, pos, index, dir, text) {\n  if (node.inlineContent) return TextSelection.create(doc, pos)\n  for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n    let child = node.child(i)\n    if (!child.isAtom) {\n      let inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text)\n      if (inner) return inner\n    } else if (!text && NodeSelection.isSelectable(child)) {\n      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0))\n    }\n    pos += child.nodeSize * dir\n  }\n}\n\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  let last = tr.steps.length - 1\n  if (last < startLen) return\n  let step = tr.steps[last]\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) return\n  let map = tr.mapping.maps[last], end\n  map.forEach((_from, _to, _newFrom, newTo) => { if (end == null) end = newTo })\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias))\n}\n","import {Transform} from \"prosemirror-transform\"\nimport {Mark} from \"prosemirror-model\"\nimport {Selection} from \"./selection\"\n\nconst UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4\n\n// ::- An editor state transaction, which can be applied to a state to\n// create an updated state. Use\n// [`EditorState.tr`](#state.EditorState.tr) to create an instance.\n//\n// Transactions track changes to the document (they are a subclass of\n// [`Transform`](#transform.Transform)), but also other state changes,\n// like selection updates and adjustments of the set of [stored\n// marks](#state.EditorState.storedMarks). In addition, you can store\n// metadata properties in a transaction, which are extra pieces of\n// information that client code or plugins can use to describe what a\n// transacion represents, so that they can update their [own\n// state](#state.StateField) accordingly.\n//\n// The [editor view](#view.EditorView) uses a few metadata properties:\n// it will attach a property `\"pointer\"` with the value `true` to\n// selection transactions directly caused by mouse or touch input, and\n// a `\"uiEvent\"` property of that may be `\"paste\"`, `\"cut\"`, or `\"drop\"`.\nexport class Transaction extends Transform {\n  constructor(state) {\n    super(state.doc)\n    // :: number\n    // The timestamp associated with this transaction, in the same\n    // format as `Date.now()`.\n    this.time = Date.now()\n    this.curSelection = state.selection\n    // The step count for which the current selection is valid.\n    this.curSelectionFor = 0\n    // :: ?[Mark]\n    // The stored marks set by this transaction, if any.\n    this.storedMarks = state.storedMarks\n    // Bitfield to track which aspects of the state were updated by\n    // this transaction.\n    this.updated = 0\n    // Object used to store metadata properties for the transaction.\n    this.meta = Object.create(null)\n  }\n\n  // :: Selection\n  // The transaction's current selection. This defaults to the editor\n  // selection [mapped](#state.Selection.map) through the steps in the\n  // transaction, but can be overwritten with\n  // [`setSelection`](#state.Transaction.setSelection).\n  get selection() {\n    if (this.curSelectionFor < this.steps.length) {\n      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor))\n      this.curSelectionFor = this.steps.length\n    }\n    return this.curSelection\n  }\n\n  // :: (Selection)  Transaction\n  // Update the transaction's current selection. Will determine the\n  // selection that the editor gets when the transaction is applied.\n  setSelection(selection) {\n    if (selection.$from.doc != this.doc)\n      throw new RangeError(\"Selection passed to setSelection must point at the current document\")\n    this.curSelection = selection\n    this.curSelectionFor = this.steps.length\n    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS\n    this.storedMarks = null\n    return this\n  }\n\n  // :: bool\n  // Whether the selection was explicitly updated by this transaction.\n  get selectionSet() {\n    return (this.updated & UPDATED_SEL) > 0\n  }\n\n  // :: (?[Mark])  Transaction\n  // Set the current stored marks.\n  setStoredMarks(marks) {\n    this.storedMarks = marks\n    this.updated |= UPDATED_MARKS\n    return this\n  }\n\n  // :: ([Mark])  Transaction\n  // Make sure the current stored marks or, if that is null, the marks\n  // at the selection, match the given set of marks. Does nothing if\n  // this is already the case.\n  ensureMarks(marks) {\n    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))\n      this.setStoredMarks(marks)\n    return this\n  }\n\n  // :: (Mark)  Transaction\n  // Add a mark to the set of stored marks.\n  addStoredMark(mark) {\n    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()))\n  }\n\n  // :: (union<Mark, MarkType>)  Transaction\n  // Remove a mark or mark type from the set of stored marks.\n  removeStoredMark(mark) {\n    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()))\n  }\n\n  // :: bool\n  // Whether the stored marks were explicitly set for this transaction.\n  get storedMarksSet() {\n    return (this.updated & UPDATED_MARKS) > 0\n  }\n\n  addStep(step, doc) {\n    super.addStep(step, doc)\n    this.updated = this.updated & ~UPDATED_MARKS\n    this.storedMarks = null\n  }\n\n  // :: (number)  Transaction\n  // Update the timestamp for the transaction.\n  setTime(time) {\n    this.time = time\n    return this\n  }\n\n  // :: (Slice)  Transaction\n  // Replace the current selection with the given slice.\n  replaceSelection(slice) {\n    this.selection.replace(this, slice)\n    return this\n  }\n\n  // :: (Node, ?bool)  Transaction\n  // Replace the selection with the given node. When `inheritMarks` is\n  // true and the content is inline, it inherits the marks from the\n  // place where it is inserted.\n  replaceSelectionWith(node, inheritMarks) {\n    let selection = this.selection\n    if (inheritMarks !== false)\n      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : (selection.$from.marksAcross(selection.$to) || Mark.none)))\n    selection.replaceWith(this, node)\n    return this\n  }\n\n  // :: ()  Transaction\n  // Delete the selection.\n  deleteSelection() {\n    this.selection.replace(this)\n    return this\n  }\n\n  // :: (string, from: ?number, to: ?number)  Transaction\n  // Replace the given range, or the selection if no range is given,\n  // with a text node containing the given string.\n  insertText(text, from, to = from) {\n    let schema = this.doc.type.schema\n    if (from == null) {\n      if (!text) return this.deleteSelection()\n      return this.replaceSelectionWith(schema.text(text), true)\n    } else {\n      if (!text) return this.deleteRange(from, to)\n      let marks = this.storedMarks\n      if (!marks) {\n        let $from = this.doc.resolve(from)\n        marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to))\n      }\n      this.replaceRangeWith(from, to, schema.text(text, marks))\n      if (!this.selection.empty) this.setSelection(Selection.near(this.selection.$to))\n      return this\n    }\n  }\n\n  // :: (union<string, Plugin, PluginKey>, any)  Transaction\n  // Store a metadata property in this transaction, keyed either by\n  // name or by plugin.\n  setMeta(key, value) {\n    this.meta[typeof key == \"string\" ? key : key.key] = value\n    return this\n  }\n\n  // :: (union<string, Plugin, PluginKey>)  any\n  // Retrieve a metadata property for a given name or plugin.\n  getMeta(key) {\n    return this.meta[typeof key == \"string\" ? key : key.key]\n  }\n\n  // :: bool\n  // Returns true if this transaction doesn't contain any metadata,\n  // and can thus safely be extended.\n  get isGeneric() {\n    for (let _ in this.meta) return false\n    return true\n  }\n\n  // :: ()  Transaction\n  // Indicate that the editor should scroll the selection into view\n  // when updated to the state produced by this transaction.\n  scrollIntoView() {\n    this.updated |= UPDATED_SCROLL\n    return this\n  }\n\n  get scrolledIntoView() {\n    return (this.updated & UPDATED_SCROLL) > 0\n  }\n}\n","import {Node} from \"prosemirror-model\"\n\nimport {Selection} from \"./selection\"\nimport {Transaction} from \"./transaction\"\n\nfunction bind(f, self) {\n  return !self || !f ? f : f.bind(self)\n}\n\nclass FieldDesc {\n  constructor(name, desc, self) {\n    this.name = name\n    this.init = bind(desc.init, self)\n    this.apply = bind(desc.apply, self)\n  }\n}\n\nconst baseFields = [\n  new FieldDesc(\"doc\", {\n    init(config) { return config.doc || config.schema.topNodeType.createAndFill() },\n    apply(tr) { return tr.doc }\n  }),\n\n  new FieldDesc(\"selection\", {\n    init(config, instance) { return config.selection || Selection.atStart(instance.doc) },\n    apply(tr) { return tr.selection }\n  }),\n\n  new FieldDesc(\"storedMarks\", {\n    init(config) { return config.storedMarks || null },\n    apply(tr, _marks, _old, state) { return state.selection.$cursor ? tr.storedMarks : null }\n  }),\n\n  new FieldDesc(\"scrollToSelection\", {\n    init() { return 0 },\n    apply(tr, prev) { return tr.scrolledIntoView ? prev + 1 : prev }\n  })\n]\n\n// Object wrapping the part of a state object that stays the same\n// across transactions. Stored in the state's `config` property.\nclass Configuration {\n  constructor(schema, plugins) {\n    this.schema = schema\n    this.fields = baseFields.concat()\n    this.plugins = []\n    this.pluginsByKey = Object.create(null)\n    if (plugins) plugins.forEach(plugin => {\n      if (this.pluginsByKey[plugin.key])\n        throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\")\n      this.plugins.push(plugin)\n      this.pluginsByKey[plugin.key] = plugin\n      if (plugin.spec.state)\n        this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin))\n    })\n  }\n}\n\n// ::- The state of a ProseMirror editor is represented by an object\n// of this type. A state is a persistent data structureit isn't\n// updated, but rather a new state value is computed from an old one\n// using the [`apply`](#state.EditorState.apply) method.\n//\n// A state holds a number of built-in fields, and plugins can\n// [define](#state.PluginSpec.state) additional fields.\nexport class EditorState {\n  constructor(config) {\n    this.config = config\n  }\n\n  // doc:: Node\n  // The current document.\n\n  // selection:: Selection\n  // The selection.\n\n  // storedMarks:: ?[Mark]\n  // A set of marks to apply to the next input. Will be null when\n  // no explicit marks have been set.\n\n  // :: Schema\n  // The schema of the state's document.\n  get schema() {\n    return this.config.schema\n  }\n\n  // :: [Plugin]\n  // The plugins that are active in this state.\n  get plugins() {\n    return this.config.plugins\n  }\n\n  // :: (Transaction)  EditorState\n  // Apply the given transaction to produce a new state.\n  apply(tr) {\n    return this.applyTransaction(tr).state\n  }\n\n  // : (Transaction)  bool\n  filterTransaction(tr, ignore = -1) {\n    for (let i = 0; i < this.config.plugins.length; i++) if (i != ignore) {\n      let plugin = this.config.plugins[i]\n      if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))\n        return false\n    }\n    return true\n  }\n\n  // :: (Transaction)  {state: EditorState, transactions: [Transaction]}\n  // Verbose variant of [`apply`](#state.EditorState.apply) that\n  // returns the precise transactions that were applied (which might\n  // be influenced by the [transaction\n  // hooks](#state.PluginSpec.filterTransaction) of\n  // plugins) along with the new state.\n  applyTransaction(rootTr) {\n    if (!this.filterTransaction(rootTr)) return {state: this, transactions: []}\n\n    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null\n    // This loop repeatedly gives plugins a chance to respond to\n    // transactions as new transactions are added, making sure to only\n    // pass the transactions the plugin did not see before.\n    outer: for (;;) {\n      let haveNew = false\n      for (let i = 0; i < this.config.plugins.length; i++) {\n        let plugin = this.config.plugins[i]\n        if (plugin.spec.appendTransaction) {\n          let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this\n          let tr = n < trs.length &&\n              plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState)\n          if (tr && newState.filterTransaction(tr, i)) {\n            tr.setMeta(\"appendedTransaction\", rootTr)\n            if (!seen) {\n              seen = []\n              for (let j = 0; j < this.config.plugins.length; j++)\n                seen.push(j < i ? {state: newState, n: trs.length} : {state: this, n: 0})\n            }\n            trs.push(tr)\n            newState = newState.applyInner(tr)\n            haveNew = true\n          }\n          if (seen) seen[i] = {state: newState, n: trs.length}\n        }\n      }\n      if (!haveNew) return {state: newState, transactions: trs}\n    }\n  }\n\n  // : (Transaction)  EditorState\n  applyInner(tr) {\n    if (!tr.before.eq(this.doc)) throw new RangeError(\"Applying a mismatched transaction\")\n    let newInstance = new EditorState(this.config), fields = this.config.fields\n    for (let i = 0; i < fields.length; i++) {\n      let field = fields[i]\n      newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance)\n    }\n    for (let i = 0; i < applyListeners.length; i++) applyListeners[i](this, tr, newInstance)\n    return newInstance\n  }\n\n  // :: Transaction\n  // Start a [transaction](#state.Transaction) from this state.\n  get tr() { return new Transaction(this) }\n\n  // :: (Object)  EditorState\n  // Create a new state.\n  //\n  //   config::- Configuration options. Must contain `schema` or `doc` (or both).\n  //\n  //      schema:: ?Schema\n  //      The schema to use (only relevant if no `doc` is specified).\n  //\n  //      doc:: ?Node\n  //      The starting document.\n  //\n  //      selection:: ?Selection\n  //      A valid selection in the document.\n  //\n  //      storedMarks:: ?[Mark]\n  //      The initial set of [stored marks](#state.EditorState.storedMarks).\n  //\n  //      plugins:: ?[Plugin]\n  //      The plugins that should be active in this state.\n  static create(config) {\n    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins)\n    let instance = new EditorState($config)\n    for (let i = 0; i < $config.fields.length; i++)\n      instance[$config.fields[i].name] = $config.fields[i].init(config, instance)\n    return instance\n  }\n\n  // :: (Object)  EditorState\n  // Create a new state based on this one, but with an adjusted set of\n  // active plugins. State fields that exist in both sets of plugins\n  // are kept unchanged. Those that no longer exist are dropped, and\n  // those that are new are initialized using their\n  // [`init`](#state.StateField.init) method, passing in the new\n  // configuration object..\n  //\n  //   config::- configuration options\n  //\n  //     plugins:: [Plugin]\n  //     New set of active plugins.\n  reconfigure(config) {\n    let $config = new Configuration(this.schema, config.plugins)\n    let fields = $config.fields, instance = new EditorState($config)\n    for (let i = 0; i < fields.length; i++) {\n      let name = fields[i].name\n      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance)\n    }\n    return instance\n  }\n\n  // :: (?union<Object<Plugin>, string, number>)  Object\n  // Serialize this state to JSON. If you want to serialize the state\n  // of plugins, pass an object mapping property names to use in the\n  // resulting JSON object to plugin objects. The argument may also be\n  // a string or number, in which case it is ignored, to support the\n  // way `JSON.stringify` calls `toString` methods.\n  toJSON(pluginFields) {\n    let result = {doc: this.doc.toJSON(), selection: this.selection.toJSON()}\n    if (this.storedMarks) result.storedMarks = this.storedMarks.map(m => m.toJSON())\n    if (pluginFields && typeof pluginFields == 'object') for (let prop in pluginFields) {\n      if (prop == \"doc\" || prop == \"selection\")\n        throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\")\n      let plugin = pluginFields[prop], state = plugin.spec.state\n      if (state && state.toJSON) result[prop] = state.toJSON.call(plugin, this[plugin.key])\n    }\n    return result\n  }\n\n  // :: (Object, Object, ?Object<Plugin>)  EditorState\n  // Deserialize a JSON representation of a state. `config` should\n  // have at least a `schema` field, and should contain array of\n  // plugins to initialize the state with. `pluginFields` can be used\n  // to deserialize the state of plugins, by associating plugin\n  // instances with the property names they use in the JSON object.\n  //\n  //   config::- configuration options\n  //\n  //     schema:: Schema\n  //     The schema to use.\n  //\n  //     plugins:: ?[Plugin]\n  //     The set of active plugins.\n  static fromJSON(config, json, pluginFields) {\n    if (!json) throw new RangeError(\"Invalid input for EditorState.fromJSON\")\n    if (!config.schema) throw new RangeError(\"Required config field 'schema' missing\")\n    let $config = new Configuration(config.schema, config.plugins)\n    let instance = new EditorState($config)\n    $config.fields.forEach(field => {\n      if (field.name == \"doc\") {\n        instance.doc = Node.fromJSON(config.schema, json.doc)\n      } else if (field.name == \"selection\") {\n        instance.selection = Selection.fromJSON(instance.doc, json.selection)\n      } else if (field.name == \"storedMarks\") {\n        if (json.storedMarks) instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON)\n      } else {\n        if (pluginFields) for (let prop in pluginFields) {\n          let plugin = pluginFields[prop], state = plugin.spec.state\n          if (plugin.key == field.name && state && state.fromJSON &&\n              Object.prototype.hasOwnProperty.call(json, prop)) {\n            // This field belongs to a plugin mapped to a JSON field, read it from there.\n            instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance)\n            return\n          }\n        }\n        instance[field.name] = field.init(config, instance)\n      }\n    })\n    return instance\n  }\n\n  // Kludge to allow the view to track mappings between different\n  // instances of a state.\n  //\n  // FIXME this is no longer needed as of prosemirror-view 1.9.0,\n  // though due to backwards-compat we should probably keep it around\n  // for a while (if only as a no-op)\n  static addApplyListener(f) {\n    applyListeners.push(f)\n  }\n  static removeApplyListener(f) {\n    let found = applyListeners.indexOf(f)\n    if (found > -1) applyListeners.splice(found, 1)\n  }\n}\n\nconst applyListeners = []\n","// PluginSpec:: interface\n//\n// This is the type passed to the [`Plugin`](#state.Plugin)\n// constructor. It provides a definition for a plugin.\n//\n//   props:: ?EditorProps\n//   The [view props](#view.EditorProps) added by this plugin. Props\n//   that are functions will be bound to have the plugin instance as\n//   their `this` binding.\n//\n//   state:: ?StateField<any>\n//   Allows a plugin to define a [state field](#state.StateField), an\n//   extra slot in the state object in which it can keep its own data.\n//\n//   key:: ?PluginKey\n//   Can be used to make this a keyed plugin. You can have only one\n//   plugin with a given key in a given state, but it is possible to\n//   access the plugin's configuration and state through the key,\n//   without having access to the plugin instance object.\n//\n//   view:: ?(EditorView)  Object\n//   When the plugin needs to interact with the editor view, or\n//   set something up in the DOM, use this field. The function\n//   will be called when the plugin's state is associated with an\n//   editor view.\n//\n//     return::-\n//     Should return an object with the following optional\n//     properties:\n//\n//       update:: ?(view: EditorView, prevState: EditorState)\n//       Called whenever the view's state is updated.\n//\n//       destroy:: ?()\n//       Called when the view is destroyed or receives a state\n//       with different plugins.\n//\n//   filterTransaction:: ?(Transaction, EditorState)  bool\n//   When present, this will be called before a transaction is\n//   applied by the state, allowing the plugin to cancel it (by\n//   returning false).\n//\n//   appendTransaction:: ?(transactions: [Transaction], oldState: EditorState, newState: EditorState)  ?Transaction\n//   Allows the plugin to append another transaction to be applied\n//   after the given array of transactions. When another plugin\n//   appends a transaction after this was called, it is called again\n//   with the new state and new transactionsbut only the new\n//   transactions, i.e. it won't be passed transactions that it\n//   already saw.\n\nfunction bindProps(obj, self, target) {\n  for (let prop in obj) {\n    let val = obj[prop]\n    if (val instanceof Function) val = val.bind(self)\n    else if (prop == \"handleDOMEvents\") val = bindProps(val, self, {})\n    target[prop] = val\n  }\n  return target\n}\n\n// ::- Plugins bundle functionality that can be added to an editor.\n// They are part of the [editor state](#state.EditorState) and\n// may influence that state and the view that contains it.\nexport class Plugin {\n  // :: (PluginSpec)\n  // Create a plugin.\n  constructor(spec) {\n    // :: EditorProps\n    // The [props](#view.EditorProps) exported by this plugin.\n    this.props = {}\n    if (spec.props) bindProps(spec.props, this, this.props)\n    // :: Object\n    // The plugin's [spec object](#state.PluginSpec).\n    this.spec = spec\n    this.key = spec.key ? spec.key.key : createKey(\"plugin\")\n  }\n\n  // :: (EditorState)  any\n  // Extract the plugin's state field from an editor state.\n  getState(state) { return state[this.key] }\n}\n\n// StateField:: interface<T>\n// A plugin spec may provide a state field (under its\n// [`state`](#state.PluginSpec.state) property) of this type, which\n// describes the state it wants to keep. Functions provided here are\n// always called with the plugin instance as their `this` binding.\n//\n//   init:: (config: Object, instance: EditorState)  T\n//   Initialize the value of the field. `config` will be the object\n//   passed to [`EditorState.create`](#state.EditorState^create). Note\n//   that `instance` is a half-initialized state instance, and will\n//   not have values for plugin fields initialized after this one.\n//\n//   apply:: (tr: Transaction, value: T, oldState: EditorState, newState: EditorState)  T\n//   Apply the given transaction to this state field, producing a new\n//   field value. Note that the `newState` argument is again a partially\n//   constructed state does not yet contain the state from plugins\n//   coming after this one.\n//\n//   toJSON:: ?(value: T)  *\n//   Convert this field to JSON. Optional, can be left off to disable\n//   JSON serialization for the field.\n//\n//   fromJSON:: ?(config: Object, value: *, state: EditorState)  T\n//   Deserialize the JSON representation of this field. Note that the\n//   `state` argument is again a half-initialized state.\n\nconst keys = Object.create(null)\n\nfunction createKey(name) {\n  if (name in keys) return name + \"$\" + ++keys[name]\n  keys[name] = 0\n  return name + \"$\"\n}\n\n// ::- A key is used to [tag](#state.PluginSpec.key)\n// plugins in a way that makes it possible to find them, given an\n// editor state. Assigning a key does mean only one plugin of that\n// type can be active in a state.\nexport class PluginKey {\n  // :: (?string)\n  // Create a plugin key.\n  constructor(name = \"key\") { this.key = createKey(name) }\n\n  // :: (EditorState)  ?Plugin\n  // Get the active plugin with this key, if any, from an editor\n  // state.\n  get(state) { return state.config.pluginsByKey[this.key] }\n\n  // :: (EditorState)  ?any\n  // Get the plugin's state from an editor state.\n  getState(state) { return state[this.key] }\n}\n","// Mappable:: interface\n// There are several things that positions can be mapped through.\n// Such objects conform to this interface.\n//\n//   map:: (pos: number, assoc: ?number)  number\n//   Map a position through this object. When given, `assoc` (should\n//   be -1 or 1, defaults to 1) determines with which side the\n//   position is associated, which determines in which direction to\n//   move when a chunk of content is inserted at the mapped position.\n//\n//   mapResult:: (pos: number, assoc: ?number)  MapResult\n//   Map a position, and return an object containing additional\n//   information about the mapping. The result's `deleted` field tells\n//   you whether the position was deleted (completely enclosed in a\n//   replaced range) during the mapping. When content on only one side\n//   is deleted, the position itself is only considered deleted when\n//   `assoc` points in the direction of the deleted content.\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\n\nconst lower16 = 0xffff\nconst factor16 = Math.pow(2, 16)\n\nfunction makeRecover(index, offset) { return index + offset * factor16 }\nfunction recoverIndex(value) { return value & lower16 }\nfunction recoverOffset(value) { return (value - (value & lower16)) / factor16 }\n\n// ::- An object representing a mapped position with extra\n// information.\nexport class MapResult {\n  constructor(pos, deleted = false, recover = null) {\n    // :: number The mapped version of the position.\n    this.pos = pos\n    // :: bool Tells you whether the position was deleted, that is,\n    // whether the step removed its surroundings from the document.\n    this.deleted = deleted\n    this.recover = recover\n  }\n}\n\n// :: class extends Mappable\n// A map describing the deletions and insertions made by a step, which\n// can be used to find the correspondence between positions in the\n// pre-step version of a document and the same position in the\n// post-step version.\nexport class StepMap {\n  // :: ([number])\n  // Create a position map. The modifications to the document are\n  // represented as an array of numbers, in which each group of three\n  // represents a modified chunk as `[start, oldSize, newSize]`.\n  constructor(ranges, inverted = false) {\n    if (!ranges.length && StepMap.empty) return StepMap.empty\n    this.ranges = ranges\n    this.inverted = inverted\n  }\n\n  recover(value) {\n    let diff = 0, index = recoverIndex(value)\n    if (!this.inverted) for (let i = 0; i < index; i++)\n      diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]\n    return this.ranges[index * 3] + diff + recoverOffset(value)\n  }\n\n  // : (number, ?number)  MapResult\n  mapResult(pos, assoc = 1) { return this._map(pos, assoc, false) }\n\n  // : (number, ?number)  number\n  map(pos, assoc = 1) { return this._map(pos, assoc, true) }\n\n  _map(pos, assoc, simple) {\n    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0)\n      if (start > pos) break\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize\n      if (pos <= end) {\n        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc\n        let result = start + diff + (side < 0 ? 0 : newSize)\n        if (simple) return result\n        let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start)\n        return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover)\n      }\n      diff += newSize - oldSize\n    }\n    return simple ? pos + diff : new MapResult(pos + diff)\n  }\n\n  touches(pos, recover) {\n    let diff = 0, index = recoverIndex(recover)\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0)\n      if (start > pos) break\n      let oldSize = this.ranges[i + oldIndex], end = start + oldSize\n      if (pos <= end && i == index * 3) return true\n      diff += this.ranges[i + newIndex] - oldSize\n    }\n    return false\n  }\n\n  // :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))\n  // Calls the given function on each of the changed ranges included in\n  // this map.\n  forEach(f) {\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff)\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex]\n      f(oldStart, oldStart + oldSize, newStart, newStart + newSize)\n      diff += newSize - oldSize\n    }\n  }\n\n  // :: ()  StepMap\n  // Create an inverted version of this map. The result can be used to\n  // map positions in the post-step document to the pre-step document.\n  invert() {\n    return new StepMap(this.ranges, !this.inverted)\n  }\n\n  toString() {\n    return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges)\n  }\n\n  // :: (n: number)  StepMap\n  // Create a map that moves all positions by offset `n` (which may be\n  // negative). This can be useful when applying steps meant for a\n  // sub-document to a larger document, or vice-versa.\n  static offset(n) {\n    return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n])\n  }\n}\n\nStepMap.empty = new StepMap([])\n\n// :: class extends Mappable\n// A mapping represents a pipeline of zero or more [step\n// maps](#transform.StepMap). It has special provisions for losslessly\n// handling mapping positions through a series of steps in which some\n// steps are inverted versions of earlier steps. (This comes up when\n// [rebasing](/docs/guide/#transform.rebasing) steps for\n// collaboration or history management.)\nexport class Mapping {\n  // :: (?[StepMap])\n  // Create a new mapping with the given position maps.\n  constructor(maps, mirror, from, to) {\n    // :: [StepMap]\n    // The step maps in this mapping.\n    this.maps = maps || []\n    // :: number\n    // The starting position in the `maps` array, used when `map` or\n    // `mapResult` is called.\n    this.from = from || 0\n    // :: number\n    // The end position in the `maps` array.\n    this.to = to == null ? this.maps.length : to\n    this.mirror = mirror\n  }\n\n  // :: (?number, ?number)  Mapping\n  // Create a mapping that maps only through a part of this one.\n  slice(from = 0, to = this.maps.length) {\n    return new Mapping(this.maps, this.mirror, from, to)\n  }\n\n  copy() {\n    return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)\n  }\n\n  // :: (StepMap, ?number)\n  // Add a step map to the end of this mapping. If `mirrors` is\n  // given, it should be the index of the step map that is the mirror\n  // image of this one.\n  appendMap(map, mirrors) {\n    this.to = this.maps.push(map)\n    if (mirrors != null) this.setMirror(this.maps.length - 1, mirrors)\n  }\n\n  // :: (Mapping)\n  // Add all the step maps in a given mapping to this one (preserving\n  // mirroring information).\n  appendMapping(mapping) {\n    for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n      let mirr = mapping.getMirror(i)\n      this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null)\n    }\n  }\n\n  // :: (number)  ?number\n  // Finds the offset of the step map that mirrors the map at the\n  // given offset, in this mapping (as per the second argument to\n  // `appendMap`).\n  getMirror(n) {\n    if (this.mirror) for (let i = 0; i < this.mirror.length; i++)\n      if (this.mirror[i] == n) return this.mirror[i + (i % 2 ? -1 : 1)]\n  }\n\n  setMirror(n, m) {\n    if (!this.mirror) this.mirror = []\n    this.mirror.push(n, m)\n  }\n\n  // :: (Mapping)\n  // Append the inverse of the given mapping to this one.\n  appendMappingInverted(mapping) {\n    for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n      let mirr = mapping.getMirror(i)\n      this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null)\n    }\n  }\n\n  // :: ()  Mapping\n  // Create an inverted version of this mapping.\n  invert() {\n    let inverse = new Mapping\n    inverse.appendMappingInverted(this)\n    return inverse\n  }\n\n  // : (number, ?number)  number\n  // Map a position through this mapping.\n  map(pos, assoc = 1) {\n    if (this.mirror) return this._map(pos, assoc, true)\n    for (let i = this.from; i < this.to; i++)\n      pos = this.maps[i].map(pos, assoc)\n    return pos\n  }\n\n  // : (number, ?number)  MapResult\n  // Map a position through this mapping, returning a mapping\n  // result.\n  mapResult(pos, assoc = 1) { return this._map(pos, assoc, false) }\n\n  _map(pos, assoc, simple) {\n    let deleted = false\n\n    for (let i = this.from; i < this.to; i++) {\n      let map = this.maps[i], result = map.mapResult(pos, assoc)\n      if (result.recover != null) {\n        let corr = this.getMirror(i)\n        if (corr != null && corr > i && corr < this.to) {\n          i = corr\n          pos = this.maps[corr].recover(result.recover)\n          continue\n        }\n      }\n\n      if (result.deleted) deleted = true\n      pos = result.pos\n    }\n\n    return simple ? pos : new MapResult(pos, deleted)\n  }\n}\n","import {Mapping} from \"./map\"\n\nexport function TransformError(message) {\n  let err = Error.call(this, message)\n  err.__proto__ = TransformError.prototype\n  return err\n}\n\nTransformError.prototype = Object.create(Error.prototype)\nTransformError.prototype.constructor = TransformError\nTransformError.prototype.name = \"TransformError\"\n\n// ::- Abstraction to build up and track an array of\n// [steps](#transform.Step) representing a document transformation.\n//\n// Most transforming methods return the `Transform` object itself, so\n// that they can be chained.\nexport class Transform {\n  // :: (Node)\n  // Create a transform that starts with the given document.\n  constructor(doc) {\n    // :: Node\n    // The current document (the result of applying the steps in the\n    // transform).\n    this.doc = doc\n    // :: [Step]\n    // The steps in this transform.\n    this.steps = []\n    // :: [Node]\n    // The documents before each of the steps.\n    this.docs = []\n    // :: Mapping\n    // A mapping with the maps for each of the steps in this transform.\n    this.mapping = new Mapping\n  }\n\n  // :: Node The starting document.\n  get before() { return this.docs.length ? this.docs[0] : this.doc }\n\n  // :: (step: Step)  this\n  // Apply a new step in this transform, saving the result. Throws an\n  // error when the step fails.\n  step(object) {\n    let result = this.maybeStep(object)\n    if (result.failed) throw new TransformError(result.failed)\n    return this\n  }\n\n  // :: (Step)  StepResult\n  // Try to apply a step in this transformation, ignoring it if it\n  // fails. Returns the step result.\n  maybeStep(step) {\n    let result = step.apply(this.doc)\n    if (!result.failed) this.addStep(step, result.doc)\n    return result\n  }\n\n  // :: bool\n  // True when the document has been changed (when there are any\n  // steps).\n  get docChanged() {\n    return this.steps.length > 0\n  }\n\n  addStep(step, doc) {\n    this.docs.push(this.doc)\n    this.steps.push(step)\n    this.mapping.appendMap(step.getMap())\n    this.doc = doc\n  }\n}\n","import {ReplaceError} from \"prosemirror-model\"\n\nimport {StepMap} from \"./map\"\n\nfunction mustOverride() { throw new Error(\"Override me\") }\n\nconst stepsByID = Object.create(null)\n\n// ::- A step object represents an atomic change. It generally applies\n// only to the document it was created for, since the positions\n// stored in it will only make sense for that document.\n//\n// New steps are defined by creating classes that extend `Step`,\n// overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\n// methods, and registering your class with a unique\n// JSON-serialization identifier using\n// [`Step.jsonID`](#transform.Step^jsonID).\nexport class Step {\n  // :: (doc: Node)  StepResult\n  // Applies this step to the given document, returning a result\n  // object that either indicates failure, if the step can not be\n  // applied to this document, or indicates success by containing a\n  // transformed document.\n  apply(_doc) { return mustOverride() }\n\n  // :: ()  StepMap\n  // Get the step map that represents the changes made by this step,\n  // and which can be used to transform between positions in the old\n  // and the new document.\n  getMap() { return StepMap.empty }\n\n  // :: (doc: Node)  Step\n  // Create an inverted version of this step. Needs the document as it\n  // was before the step as argument.\n  invert(_doc) { return mustOverride() }\n\n  // :: (mapping: Mappable)  ?Step\n  // Map this step through a mappable thing, returning either a\n  // version of that step with its positions adjusted, or `null` if\n  // the step was entirely deleted by the mapping.\n  map(_mapping) { return mustOverride() }\n\n  // :: (other: Step)  ?Step\n  // Try to merge this step with another one, to be applied directly\n  // after it. Returns the merged step when possible, null if the\n  // steps can't be merged.\n  merge(_other) { return null }\n\n  // :: ()  Object\n  // Create a JSON-serializeable representation of this step. When\n  // defining this for a custom subclass, make sure the result object\n  // includes the step type's [JSON id](#transform.Step^jsonID) under\n  // the `stepType` property.\n  toJSON() { return mustOverride() }\n\n  // :: (Schema, Object)  Step\n  // Deserialize a step from its JSON representation. Will call\n  // through to the step class' own implementation of this method.\n  static fromJSON(schema, json) {\n    if (!json || !json.stepType) throw new RangeError(\"Invalid input for Step.fromJSON\")\n    let type = stepsByID[json.stepType]\n    if (!type) throw new RangeError(`No step type ${json.stepType} defined`)\n    return type.fromJSON(schema, json)\n  }\n\n  // :: (string, constructor<Step>)\n  // To be able to serialize steps to JSON, each step needs a string\n  // ID to attach to its JSON representation. Use this method to\n  // register an ID for your step classes. Try to pick something\n  // that's unlikely to clash with steps from other modules.\n  static jsonID(id, stepClass) {\n    if (id in stepsByID) throw new RangeError(\"Duplicate use of step JSON ID \" + id)\n    stepsByID[id] = stepClass\n    stepClass.prototype.jsonID = id\n    return stepClass\n  }\n}\n\n// ::- The result of [applying](#transform.Step.apply) a step. Contains either a\n// new document or a failure value.\nexport class StepResult {\n  // : (?Node, ?string)\n  constructor(doc, failed) {\n    // :: ?Node The transformed document.\n    this.doc = doc\n    // :: ?string Text providing information about a failed step.\n    this.failed = failed\n  }\n\n  // :: (Node)  StepResult\n  // Create a successful step result.\n  static ok(doc) { return new StepResult(doc, null) }\n\n  // :: (string)  StepResult\n  // Create a failed step result.\n  static fail(message) { return new StepResult(null, message) }\n\n  // :: (Node, number, number, Slice)  StepResult\n  // Call [`Node.replace`](#model.Node.replace) with the given\n  // arguments. Create a successful result if it succeeds, and a\n  // failed one if it throws a `ReplaceError`.\n  static fromReplace(doc, from, to, slice) {\n    try {\n      return StepResult.ok(doc.replace(from, to, slice))\n    } catch (e) {\n      if (e instanceof ReplaceError) return StepResult.fail(e.message)\n      throw e\n    }\n  }\n}\n","import {Slice} from \"prosemirror-model\"\n\nimport {Step, StepResult} from \"./step\"\nimport {StepMap} from \"./map\"\n\n// ::- Replace a part of the document with a slice of new content.\nexport class ReplaceStep extends Step {\n  // :: (number, number, Slice, ?bool)\n  // The given `slice` should fit the 'gap' between `from` and\n  // `to`the depths must line up, and the surrounding nodes must be\n  // able to be joined with the open sides of the slice. When\n  // `structure` is true, the step will fail if the content between\n  // from and to is not just a sequence of closing and then opening\n  // tokens (this is to guard against rebased replace steps\n  // overwriting something they weren't supposed to).\n  constructor(from, to, slice, structure) {\n    super()\n    // :: number\n    // The start position of the replaced range.\n    this.from = from\n    // :: number\n    // The end position of the replaced range.\n    this.to = to\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice\n    this.structure = !!structure\n  }\n\n  apply(doc) {\n    if (this.structure && contentBetween(doc, this.from, this.to))\n      return StepResult.fail(\"Structure replace would overwrite content\")\n    return StepResult.fromReplace(doc, this.from, this.to, this.slice)\n  }\n\n  getMap() {\n    return new StepMap([this.from, this.to - this.from, this.slice.size])\n  }\n\n  invert(doc) {\n    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to))\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted) return null\n    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice)\n  }\n\n  merge(other) {\n    if (!(other instanceof ReplaceStep) || other.structure || this.structure) return null\n\n    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd)\n      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure)\n    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd)\n      return new ReplaceStep(other.from, this.to, slice, this.structure)\n    } else {\n      return null\n    }\n  }\n\n  toJSON() {\n    let json = {stepType: \"replace\", from: this.from, to: this.to}\n    if (this.slice.size) json.slice = this.slice.toJSON()\n    if (this.structure) json.structure = true\n    return json\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\")\n    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure)\n  }\n}\n\nStep.jsonID(\"replace\", ReplaceStep)\n\n// ::- Replace a part of the document with a slice of content, but\n// preserve a range of the replaced content by moving it into the\n// slice.\nexport class ReplaceAroundStep extends Step {\n  // :: (number, number, number, number, Slice, number, ?bool)\n  // Create a replace-around step with the given range and gap.\n  // `insert` should be the point in the slice into which the content\n  // of the gap should be moved. `structure` has the same meaning as\n  // it has in the [`ReplaceStep`](#transform.ReplaceStep) class.\n  constructor(from, to, gapFrom, gapTo, slice, insert, structure) {\n    super()\n    // :: number\n    // The start position of the replaced range.\n    this.from = from\n    // :: number\n    // The end position of the replaced range.\n    this.to = to\n    // :: number\n    // The start of preserved range.\n    this.gapFrom = gapFrom\n    // :: number\n    // The end of preserved range.\n    this.gapTo = gapTo\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice\n    // :: number\n    // The position in the slice where the preserved range should be\n    // inserted.\n    this.insert = insert\n    this.structure = !!structure\n  }\n\n  apply(doc) {\n    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||\n                           contentBetween(doc, this.gapTo, this.to)))\n      return StepResult.fail(\"Structure gap-replace would overwrite content\")\n\n    let gap = doc.slice(this.gapFrom, this.gapTo)\n    if (gap.openStart || gap.openEnd)\n      return StepResult.fail(\"Gap is not a flat range\")\n    let inserted = this.slice.insertAt(this.insert, gap.content)\n    if (!inserted) return StepResult.fail(\"Content does not fit in gap\")\n    return StepResult.fromReplace(doc, this.from, this.to, inserted)\n  }\n\n  getMap() {\n    return new StepMap([this.from, this.gapFrom - this.from, this.insert,\n                        this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])\n  }\n\n  invert(doc) {\n    let gap = this.gapTo - this.gapFrom\n    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap,\n                                 this.from + this.insert, this.from + this.insert + gap,\n                                 doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),\n                                 this.gapFrom - this.from, this.structure)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1)\n    if ((from.deleted && to.deleted) || gapFrom < from.pos || gapTo > to.pos) return null\n    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure)\n  }\n\n  toJSON() {\n    let json = {stepType: \"replaceAround\", from: this.from, to: this.to,\n                gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert}\n    if (this.slice.size) json.slice = this.slice.toJSON()\n    if (this.structure) json.structure = true\n    return json\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\" ||\n        typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\")\n    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo,\n                                 Slice.fromJSON(schema, json.slice), json.insert, !!json.structure)\n  }\n}\n\nStep.jsonID(\"replaceAround\", ReplaceAroundStep)\n\nfunction contentBetween(doc, from, to) {\n  let $from = doc.resolve(from), dist = to - from, depth = $from.depth\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--\n    dist--\n  }\n  if (dist > 0) {\n    let next = $from.node(depth).maybeChild($from.indexAfter(depth))\n    while (dist > 0) {\n      if (!next || next.isLeaf) return true\n      next = next.firstChild\n      dist--\n    }\n  }\n  return false\n}\n","import {Slice, Fragment} from \"prosemirror-model\"\n\nimport {Transform} from \"./transform\"\nimport {ReplaceStep, ReplaceAroundStep} from \"./replace_step\"\n\nfunction canCut(node, start, end) {\n  return (start == 0 || node.canReplace(start, node.childCount)) &&\n    (end == node.childCount || node.canReplace(0, end))\n}\n\n// :: (NodeRange)  ?number\n// Try to find a target depth to which the content in the given range\n// can be lifted. Will not go across\n// [isolating](#model.NodeSpec.isolating) parent nodes.\nexport function liftTarget(range) {\n  let parent = range.parent\n  let content = parent.content.cutByIndex(range.startIndex, range.endIndex)\n  for (let depth = range.depth;; --depth) {\n    let node = range.$from.node(depth)\n    let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth)\n    if (depth < range.depth && node.canReplace(index, endIndex, content))\n      return depth\n    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) break\n  }\n}\n\n// :: (NodeRange, number)  this\n// Split the content in the given range off from its parent, if there\n// is sibling content before or after it, and move it up the tree to\n// the depth specified by `target`. You'll probably want to use\n// [`liftTarget`](#transform.liftTarget) to compute `target`, to make\n// sure the lift is valid.\nTransform.prototype.lift = function(range, target) {\n  let {$from, $to, depth} = range\n\n  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1)\n  let start = gapStart, end = gapEnd\n\n  let before = Fragment.empty, openStart = 0\n  for (let d = depth, splitting = false; d > target; d--)\n    if (splitting || $from.index(d) > 0) {\n      splitting = true\n      before = Fragment.from($from.node(d).copy(before))\n      openStart++\n    } else {\n      start--\n    }\n  let after = Fragment.empty, openEnd = 0\n  for (let d = depth, splitting = false; d > target; d--)\n    if (splitting || $to.after(d + 1) < $to.end(d)) {\n      splitting = true\n      after = Fragment.from($to.node(d).copy(after))\n      openEnd++\n    } else {\n      end++\n    }\n\n  return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd,\n                                         new Slice(before.append(after), openStart, openEnd),\n                                         before.size - openStart, true))\n}\n\n// :: (NodeRange, NodeType, ?Object, ?NodeRange)  ?[{type: NodeType, attrs: ?Object}]\n// Try to find a valid way to wrap the content in the given range in a\n// node of the given type. May introduce extra nodes around and inside\n// the wrapper node, if necessary. Returns null if no valid wrapping\n// could be found. When `innerRange` is given, that range's content is\n// used as the content to fit into the wrapping, instead of the\n// content of `range`.\nexport function findWrapping(range, nodeType, attrs, innerRange = range) {\n  let around = findWrappingOutside(range, nodeType)\n  let inner = around && findWrappingInside(innerRange, nodeType)\n  if (!inner) return null\n  return around.map(withAttrs).concat({type: nodeType, attrs}).concat(inner.map(withAttrs))\n}\n\nfunction withAttrs(type) { return {type, attrs: null} }\n\nfunction findWrappingOutside(range, type) {\n  let {parent, startIndex, endIndex} = range\n  let around = parent.contentMatchAt(startIndex).findWrapping(type)\n  if (!around) return null\n  let outer = around.length ? around[0] : type\n  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null\n}\n\nfunction findWrappingInside(range, type) {\n  let {parent, startIndex, endIndex} = range\n  let inner = parent.child(startIndex)\n  let inside = type.contentMatch.findWrapping(inner.type)\n  if (!inside) return null\n  let lastType = inside.length ? inside[inside.length - 1] : type\n  let innerMatch = lastType.contentMatch\n  for (let i = startIndex; innerMatch && i < endIndex; i++)\n    innerMatch = innerMatch.matchType(parent.child(i).type)\n  if (!innerMatch || !innerMatch.validEnd) return null\n  return inside\n}\n\n// :: (NodeRange, [{type: NodeType, attrs: ?Object}])  this\n// Wrap the given [range](#model.NodeRange) in the given set of wrappers.\n// The wrappers are assumed to be valid in this position, and should\n// probably be computed with [`findWrapping`](#transform.findWrapping).\nTransform.prototype.wrap = function(range, wrappers) {\n  let content = Fragment.empty\n  for (let i = wrappers.length - 1; i >= 0; i--) {\n    if (content.size) {\n      let match = wrappers[i].type.contentMatch.matchFragment(content)\n      if (!match || !match.validEnd)\n        throw new RangeError(\"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper\")\n    }\n    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content))\n  }\n\n  let start = range.start, end = range.end\n  return this.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true))\n}\n\n// :: (number, ?number, NodeType, ?Object)  this\n// Set the type of all textblocks (partly) between `from` and `to` to\n// the given node type with the given attributes.\nTransform.prototype.setBlockType = function(from, to = from, type, attrs) {\n  if (!type.isTextblock) throw new RangeError(\"Type given to setBlockType should be a textblock\")\n  let mapFrom = this.steps.length\n  this.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(this.doc, this.mapping.slice(mapFrom).map(pos), type)) {\n      // Ensure all markup that isn't allowed in the new node type is cleared\n      this.clearIncompatible(this.mapping.slice(mapFrom).map(pos, 1), type)\n      let mapping = this.mapping.slice(mapFrom)\n      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1)\n      this.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1,\n                                      new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true))\n      return false\n    }\n  })\n  return this\n}\n\nfunction canChangeType(doc, pos, type) {\n  let $pos = doc.resolve(pos), index = $pos.index()\n  return $pos.parent.canReplaceWith(index, index + 1, type)\n}\n\n// :: (number, ?NodeType, ?Object, ?[Mark])  this\n// Change the type, attributes, and/or marks of the node at `pos`.\n// When `type` isn't given, the existing node type is preserved,\nTransform.prototype.setNodeMarkup = function(pos, type, attrs, marks) {\n  let node = this.doc.nodeAt(pos)\n  if (!node) throw new RangeError(\"No node at given position\")\n  if (!type) type = node.type\n  let newNode = type.create(attrs, null, marks || node.marks)\n  if (node.isLeaf)\n    return this.replaceWith(pos, pos + node.nodeSize, newNode)\n\n  if (!type.validContent(node.content))\n    throw new RangeError(\"Invalid content for node type \" + type.name)\n\n  return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1,\n                                         new Slice(Fragment.from(newNode), 0, 0), 1, true))\n}\n\n// :: (Node, number, number, ?[?{type: NodeType, attrs: ?Object}])  bool\n// Check whether splitting at the given position is allowed.\nexport function canSplit(doc, pos, depth = 1, typesAfter) {\n  let $pos = doc.resolve(pos), base = $pos.depth - depth\n  let innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent\n  if (base < 0 || $pos.parent.type.spec.isolating ||\n      !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||\n      !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))\n    return false\n  for (let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n    let node = $pos.node(d), index = $pos.index(d)\n    if (node.type.spec.isolating) return false\n    let rest = node.content.cutByIndex(index, node.childCount)\n    let after = (typesAfter && typesAfter[i]) || node\n    if (after != node) rest = rest.replaceChild(0, after.type.create(after.attrs))\n    if (!node.canReplace(index + 1, node.childCount) || !after.type.validContent(rest))\n      return false\n  }\n  let index = $pos.indexAfter(base)\n  let baseType = typesAfter && typesAfter[0]\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type)\n}\n\n// :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}])  this\n// Split the node at the given position, and optionally, if `depth` is\n// greater than one, any number of nodes above that. By default, the\n// parts split off will inherit the node type of the original node.\n// This can be changed by passing an array of types and attributes to\n// use after the split.\nTransform.prototype.split = function(pos, depth = 1, typesAfter) {\n  let $pos = this.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty\n  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n    before = Fragment.from($pos.node(d).copy(before))\n    let typeAfter = typesAfter && typesAfter[i]\n    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after))\n  }\n  return this.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true))\n}\n\n// :: (Node, number)  bool\n// Test whether the blocks before and after a given position can be\n// joined.\nexport function canJoin(doc, pos) {\n  let $pos = doc.resolve(pos), index = $pos.index()\n  return joinable($pos.nodeBefore, $pos.nodeAfter) &&\n    $pos.parent.canReplace(index, index + 1)\n}\n\nfunction joinable(a, b) {\n  return a && b && !a.isLeaf && a.canAppend(b)\n}\n\n// :: (Node, number, ?number)  ?number\n// Find an ancestor of the given position that can be joined to the\n// block before (or after if `dir` is positive). Returns the joinable\n// point, if any.\nexport function joinPoint(doc, pos, dir = -1) {\n  let $pos = doc.resolve(pos)\n  for (let d = $pos.depth;; d--) {\n    let before, after, index = $pos.index(d)\n    if (d == $pos.depth) {\n      before = $pos.nodeBefore\n      after = $pos.nodeAfter\n    } else if (dir > 0) {\n      before = $pos.node(d + 1)\n      index++\n      after = $pos.node(d).maybeChild(index)\n    } else {\n      before = $pos.node(d).maybeChild(index - 1)\n      after = $pos.node(d + 1)\n    }\n    if (before && !before.isTextblock && joinable(before, after) &&\n        $pos.node(d).canReplace(index, index + 1)) return pos\n    if (d == 0) break\n    pos = dir < 0 ? $pos.before(d) : $pos.after(d)\n  }\n}\n\n// :: (number, ?number)  this\n// Join the blocks around the given position. If depth is 2, their\n// last and first siblings are also joined, and so on.\nTransform.prototype.join = function(pos, depth = 1) {\n  let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true)\n  return this.step(step)\n}\n\n// :: (Node, number, NodeType)  ?number\n// Try to find a point where a node of the given type can be inserted\n// near `pos`, by searching up the node hierarchy when `pos` itself\n// isn't a valid place but is at the start or end of a node. Return\n// null if no position was found.\nexport function insertPoint(doc, pos, nodeType) {\n  let $pos = doc.resolve(pos)\n  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) return pos\n\n  if ($pos.parentOffset == 0)\n    for (let d = $pos.depth - 1; d >= 0; d--) {\n      let index = $pos.index(d)\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.before(d + 1)\n      if (index > 0) return null\n    }\n  if ($pos.parentOffset == $pos.parent.content.size)\n    for (let d = $pos.depth - 1; d >= 0; d--) {\n      let index = $pos.indexAfter(d)\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.after(d + 1)\n      if (index < $pos.node(d).childCount) return null\n    }\n}\n\n// :: (Node, number, Slice)  ?number\n// Finds a position at or around the given position where the given\n// slice can be inserted. Will look at parent nodes' nearest boundary\n// and try there, even if the original position wasn't directly at the\n// start or end of that node. Returns null when no position was found.\nexport function dropPoint(doc, pos, slice) {\n  let $pos = doc.resolve(pos)\n  if (!slice.content.size) return pos\n  let content = slice.content\n  for (let i = 0; i < slice.openStart; i++) content = content.firstChild.content\n  for (let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n    for (let d = $pos.depth; d >= 0; d--) {\n      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1\n      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0)\n      let parent = $pos.node(d), fits = false\n      if (pass == 1) {\n        fits = parent.canReplace(insertPos, insertPos, content)\n      } else {\n        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type)\n        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0])\n      }\n      if (fits)\n        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1)\n    }\n  }\n  return null\n}\n","import {Fragment, Slice} from \"prosemirror-model\"\nimport {Step, StepResult} from \"./step\"\n\nfunction mapFragment(fragment, f, parent) {\n  let mapped = []\n  for (let i = 0; i < fragment.childCount; i++) {\n    let child = fragment.child(i)\n    if (child.content.size) child = child.copy(mapFragment(child.content, f, child))\n    if (child.isInline) child = f(child, parent, i)\n    mapped.push(child)\n  }\n  return Fragment.fromArray(mapped)\n}\n\n// ::- Add a mark to all inline content between two positions.\nexport class AddMarkStep extends Step {\n  // :: (number, number, Mark)\n  constructor(from, to, mark) {\n    super()\n    // :: number\n    // The start of the marked range.\n    this.from = from\n    // :: number\n    // The end of the marked range.\n    this.to = to\n    // :: Mark\n    // The mark to add.\n    this.mark = mark\n  }\n\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from)\n    let parent = $from.node($from.sharedDepth(this.to))\n    let slice = new Slice(mapFragment(oldSlice.content, (node, parent) => {\n      if (!node.isAtom || !parent.type.allowsMarkType(this.mark.type)) return node\n      return node.mark(this.mark.addToSet(node.marks))\n    }, parent), oldSlice.openStart, oldSlice.openEnd)\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  }\n\n  invert() {\n    return new RemoveMarkStep(this.from, this.to, this.mark)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted || from.pos >= to.pos) return null\n    return new AddMarkStep(from.pos, to.pos, this.mark)\n  }\n\n  merge(other) {\n    if (other instanceof AddMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      return new AddMarkStep(Math.min(this.from, other.from),\n                             Math.max(this.to, other.to), this.mark)\n  }\n\n  toJSON() {\n    return {stepType: \"addMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\")\n    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  }\n}\n\nStep.jsonID(\"addMark\", AddMarkStep)\n\n// ::- Remove a mark from all inline content between two positions.\nexport class RemoveMarkStep extends Step {\n  // :: (number, number, Mark)\n  constructor(from, to, mark) {\n    super()\n    // :: number\n    // The start of the unmarked range.\n    this.from = from\n    // :: number\n    // The end of the unmarked range.\n    this.to = to\n    // :: Mark\n    // The mark to remove.\n    this.mark = mark\n  }\n\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to)\n    let slice = new Slice(mapFragment(oldSlice.content, node => {\n      return node.mark(this.mark.removeFromSet(node.marks))\n    }), oldSlice.openStart, oldSlice.openEnd)\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  }\n\n  invert() {\n    return new AddMarkStep(this.from, this.to, this.mark)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted || from.pos >= to.pos) return null\n    return new RemoveMarkStep(from.pos, to.pos, this.mark)\n  }\n\n  merge(other) {\n    if (other instanceof RemoveMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      return new RemoveMarkStep(Math.min(this.from, other.from),\n                                Math.max(this.to, other.to), this.mark)\n  }\n\n  toJSON() {\n    return {stepType: \"removeMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\")\n    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  }\n}\n\nStep.jsonID(\"removeMark\", RemoveMarkStep)\n","\n    /*!\n    * tiptap-commands v1.17.0\n    * (c) 2021 berdosis GbR (limited liability)\n    * @license MIT\n    */\n  \nimport { setBlockType, lift, wrapIn } from 'prosemirror-commands';\nexport { autoJoin, baseKeymap, chainCommands, createParagraphNear, deleteSelection, exitCode, joinBackward, joinDown, joinForward, joinUp, lift, liftEmptyBlock, macBaseKeymap, newlineInCode, pcBaseKeymap, selectAll, selectNodeBackward, selectNodeForward, selectParentNode, setBlockType, splitBlock, splitBlockKeepMarks, toggleMark, wrapIn } from 'prosemirror-commands';\nimport { liftListItem, wrapInList } from 'prosemirror-schema-list';\nexport { addListNodes, liftListItem, sinkListItem, splitListItem, wrapInList } from 'prosemirror-schema-list';\nimport { InputRule } from 'prosemirror-inputrules';\nexport { textblockTypeInputRule, wrappingInputRule } from 'prosemirror-inputrules';\nimport { Plugin } from 'prosemirror-state';\nimport { Slice, Fragment } from 'prosemirror-model';\nimport { getMarkRange, nodeIsActive, findParentNode } from 'tiptap-utils';\n\nfunction insertText (text = '') {\n  return (state, dispatch) => {\n    const {\n      $from\n    } = state.selection;\n    const {\n      pos\n    } = $from.pos;\n    dispatch(state.tr.insertText(text, pos));\n    return true;\n  };\n}\n\nfunction getMarksBetween(start, end, state) {\n  let marks = [];\n  state.doc.nodesBetween(start, end, (node, pos) => {\n    marks = [...marks, ...node.marks.map(mark => ({\n      start: pos,\n      end: pos + node.nodeSize,\n      mark\n    }))];\n  });\n  return marks;\n}\n\nfunction markInputRule (regexp, markType, getAttrs) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    const attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n    const {\n      tr\n    } = state;\n    const m = match.length - 1;\n    let markEnd = end;\n    let markStart = start;\n\n    if (match[m]) {\n      const matchStart = start + match[0].indexOf(match[m - 1]);\n      const matchEnd = matchStart + match[m - 1].length - 1;\n      const textStart = matchStart + match[m - 1].lastIndexOf(match[m]);\n      const textEnd = textStart + match[m].length;\n      const excludedMarks = getMarksBetween(start, end, state).filter(item => {\n        const {\n          excluded\n        } = item.mark.type;\n        return excluded.find(type => type.name === markType.name);\n      }).filter(item => item.end > matchStart);\n\n      if (excludedMarks.length) {\n        return false;\n      }\n\n      if (textEnd < matchEnd) {\n        tr.delete(textEnd, matchEnd);\n      }\n\n      if (textStart > matchStart) {\n        tr.delete(matchStart, textStart);\n      }\n\n      markStart = matchStart;\n      markEnd = markStart + match[m].length;\n    }\n\n    tr.addMark(markStart, markEnd, markType.create(attrs));\n    tr.removeStoredMark(markType);\n    return tr;\n  });\n}\n\nfunction nodeInputRule (regexp, type, getAttrs) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    const attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n    const {\n      tr\n    } = state;\n\n    if (match[0]) {\n      tr.replaceWith(start - 1, end, type.create(attrs));\n    }\n\n    return tr;\n  });\n}\n\nfunction pasteRule (regexp, type, getAttrs) {\n  const handler = fragment => {\n    const nodes = [];\n    fragment.forEach(child => {\n      if (child.isText) {\n        const {\n          text\n        } = child;\n        let pos = 0;\n        let match;\n\n        do {\n          match = regexp.exec(text);\n\n          if (match) {\n            const start = match.index;\n            const end = start + match[0].length;\n            const attrs = getAttrs instanceof Function ? getAttrs(match[0]) : getAttrs;\n\n            if (start > 0) {\n              nodes.push(child.cut(pos, start));\n            }\n\n            nodes.push(child.cut(start, end).mark(type.create(attrs).addToSet(child.marks)));\n            pos = end;\n          }\n        } while (match);\n\n        if (pos < text.length) {\n          nodes.push(child.cut(pos));\n        }\n      } else {\n        nodes.push(child.copy(handler(child.content)));\n      }\n    });\n    return Fragment.fromArray(nodes);\n  };\n\n  return new Plugin({\n    props: {\n      transformPasted: slice => new Slice(handler(slice.content), slice.openStart, slice.openEnd)\n    }\n  });\n}\n\nfunction markPasteRule (regexp, type, getAttrs) {\n  const handler = (fragment, parent) => {\n    const nodes = [];\n    fragment.forEach(child => {\n      if (child.isText) {\n        const {\n          text,\n          marks\n        } = child;\n        let pos = 0;\n        let match;\n        const isLink = !!marks.filter(x => x.type.name === 'link')[0]; // eslint-disable-next-line\n\n        while (!isLink && (match = regexp.exec(text)) !== null) {\n          if (parent && parent.type.allowsMarkType(type) && match[1]) {\n            const start = match.index;\n            const end = start + match[0].length;\n            const textStart = start + match[0].indexOf(match[1]);\n            const textEnd = textStart + match[1].length;\n            const attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs; // adding text before markdown to nodes\n\n            if (start > 0) {\n              nodes.push(child.cut(pos, start));\n            } // adding the markdown part to nodes\n\n\n            nodes.push(child.cut(textStart, textEnd).mark(type.create(attrs).addToSet(child.marks)));\n            pos = end;\n          }\n        } // adding rest of text to nodes\n\n\n        if (pos < text.length) {\n          nodes.push(child.cut(pos));\n        }\n      } else {\n        nodes.push(child.copy(handler(child.content, child)));\n      }\n    });\n    return Fragment.fromArray(nodes);\n  };\n\n  return new Plugin({\n    props: {\n      transformPasted: slice => new Slice(handler(slice.content), slice.openStart, slice.openEnd)\n    }\n  });\n}\n\nfunction removeMark (type) {\n  return (state, dispatch) => {\n    const {\n      tr,\n      selection\n    } = state;\n    let {\n      from,\n      to\n    } = selection;\n    const {\n      $from,\n      empty\n    } = selection;\n\n    if (empty) {\n      const range = getMarkRange($from, type);\n      from = range.from;\n      to = range.to;\n    }\n\n    tr.removeMark(from, to, type);\n    return dispatch(tr);\n  };\n}\n\nfunction replaceText (range = null, type, attrs = {}, fragment = Fragment.empty) {\n  return (state, dispatch) => {\n    const {\n      $from,\n      $to\n    } = state.selection;\n    const index = $from.index();\n    const from = range ? range.from : $from.pos;\n    const to = range ? range.to : $to.pos;\n\n    if (!$from.parent.canReplaceWith(index, index, type)) {\n      return false;\n    }\n\n    if (dispatch) {\n      dispatch(state.tr.replaceWith(from, to, type.create(attrs, fragment)));\n    }\n\n    return true;\n  };\n}\n\nfunction setInlineBlockType (type, attrs = {}) {\n  return (state, dispatch) => {\n    const {\n      $from\n    } = state.selection;\n    const index = $from.index();\n\n    if (!$from.parent.canReplaceWith(index, index, type)) {\n      return false;\n    }\n\n    if (dispatch) {\n      dispatch(state.tr.replaceSelectionWith(type.create(attrs)));\n    }\n\n    return true;\n  };\n}\n\n// see https://github.com/ProseMirror/prosemirror-transform/blob/main/src/structure.js\n// Since this piece of code was \"borrowed\" from prosemirror, ESLint rules are ignored.\n\n/* eslint-disable max-len, no-plusplus, no-undef, eqeqeq */\n\nfunction canSplit(doc, pos, depth = 1, typesAfter) {\n  const $pos = doc.resolve(pos);\n  const base = $pos.depth - depth;\n  const innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;\n  if (base < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount))) return false;\n\n  for (let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n    const node = $pos.node(d);\n    const index = $pos.index(d);\n    if (node.type.spec.isolating) return false;\n    let rest = node.content.cutByIndex(index, node.childCount);\n    const after = typesAfter && typesAfter[i] || node;\n    if (after != node) rest = rest.replaceChild(0, after.type.create(after.attrs));\n    /* Change starts from here */\n    // if (!node.canReplace(index + 1, node.childCount) || !after.type.validContent(rest))\n    //   return false\n\n    if (!node.canReplace(index + 1, node.childCount)) return false;\n    /* Change ends here */\n  }\n\n  const index = $pos.indexAfter(base);\n  const baseType = typesAfter && typesAfter[0];\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);\n} // this is a copy of splitListItem\n// see https://github.com/ProseMirror/prosemirror-schema-list/blob/main/src/schema-list.js\n\n\nfunction splitToDefaultListItem(itemType) {\n  return function (state, dispatch) {\n    const {\n      $from,\n      $to,\n      node\n    } = state.selection;\n    if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) return false;\n    const grandParent = $from.node(-1);\n    if (grandParent.type != itemType) return false;\n\n    if ($from.parent.content.size == 0) {\n      // In an empty block. If this is a nested list, the wrapping\n      // list item should be split. Otherwise, bail out and let next\n      // command handle lifting.\n      if ($from.depth == 2 || $from.node(-3).type != itemType || $from.index(-2) != $from.node(-2).childCount - 1) return false;\n\n      if (dispatch) {\n        let wrap = Fragment.empty;\n        const keepItem = $from.index(-1) > 0; // Build a fragment containing empty versions of the structure\n        // from the outer list item to the parent node of the cursor\n\n        for (let d = $from.depth - (keepItem ? 1 : 2); d >= $from.depth - 3; d--) wrap = Fragment.from($from.node(d).copy(wrap)); // Add a second list item with an empty default start node\n\n\n        wrap = wrap.append(Fragment.from(itemType.createAndFill()));\n        const tr = state.tr.replace($from.before(keepItem ? null : -1), $from.after(-3), new Slice(wrap, keepItem ? 3 : 2, 2));\n        tr.setSelection(state.selection.constructor.near(tr.doc.resolve($from.pos + (keepItem ? 3 : 2))));\n        dispatch(tr.scrollIntoView());\n      }\n\n      return true;\n    }\n\n    const nextType = $to.pos == $from.end() ? grandParent.contentMatchAt($from.indexAfter(-1)).defaultType : null;\n    const tr = state.tr.delete($from.pos, $to.pos);\n    /* Change starts from here */\n    // let types = nextType && [null, {type: nextType}]\n\n    let types = nextType && [{\n      type: itemType\n    }, {\n      type: nextType\n    }];\n    if (!types) types = [{\n      type: itemType\n    }, null];\n    /* Change ends here */\n\n    if (!canSplit(tr.doc, $from.pos, 2, types)) return false;\n    if (dispatch) dispatch(tr.split($from.pos, 2, types).scrollIntoView());\n    return true;\n  };\n}\n/* eslint-enable max-len, no-plusplus, no-undef, eqeqeq */\n\nfunction toggleBlockType (type, toggletype, attrs = {}) {\n  return (state, dispatch, view) => {\n    const isActive = nodeIsActive(state, type, attrs);\n\n    if (isActive) {\n      return setBlockType(toggletype)(state, dispatch, view);\n    }\n\n    return setBlockType(type, attrs)(state, dispatch, view);\n  };\n}\n\nfunction isList(node, schema) {\n  return node.type === schema.nodes.bullet_list || node.type === schema.nodes.ordered_list || node.type === schema.nodes.todo_list;\n}\n\nfunction toggleList(listType, itemType) {\n  return (state, dispatch, view) => {\n    const {\n      schema,\n      selection\n    } = state;\n    const {\n      $from,\n      $to\n    } = selection;\n    const range = $from.blockRange($to);\n\n    if (!range) {\n      return false;\n    }\n\n    const parentList = findParentNode(node => isList(node, schema))(selection);\n\n    if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n      if (parentList.node.type === listType) {\n        return liftListItem(itemType)(state, dispatch, view);\n      }\n\n      if (isList(parentList.node, schema) && listType.validContent(parentList.node.content)) {\n        const {\n          tr\n        } = state;\n        tr.setNodeMarkup(parentList.pos, listType);\n\n        if (dispatch) {\n          dispatch(tr);\n        }\n\n        return false;\n      }\n    }\n\n    return wrapInList(listType)(state, dispatch, view);\n  };\n}\n\nfunction toggleWrap (type, attrs = {}) {\n  return (state, dispatch, view) => {\n    const isActive = nodeIsActive(state, type, attrs);\n\n    if (isActive) {\n      return lift(state, dispatch);\n    }\n\n    return wrapIn(type, attrs)(state, dispatch, view);\n  };\n}\n\nfunction updateMark (type, attrs) {\n  return (state, dispatch) => {\n    const {\n      tr,\n      selection,\n      doc\n    } = state;\n    const {\n      ranges,\n      empty\n    } = selection;\n\n    if (empty) {\n      const {\n        from,\n        to\n      } = getMarkRange(selection.$from, type);\n\n      if (doc.rangeHasMark(from, to, type)) {\n        tr.removeMark(from, to, type);\n      }\n\n      tr.addMark(from, to, type.create(attrs));\n    } else {\n      ranges.forEach(ref$1 => {\n        const {\n          $to,\n          $from\n        } = ref$1;\n\n        if (doc.rangeHasMark($from.pos, $to.pos, type)) {\n          tr.removeMark($from.pos, $to.pos, type);\n        }\n\n        tr.addMark($from.pos, $to.pos, type.create(attrs));\n      });\n    }\n\n    return dispatch(tr);\n  };\n}\n\nexport { insertText, markInputRule, markPasteRule, nodeInputRule, pasteRule, removeMark, replaceText, setInlineBlockType, splitToDefaultListItem, toggleBlockType, toggleList, toggleWrap, updateMark };\n","\n    /*!\n    * tiptap-utils v1.13.0\n    * (c) 2021 berdosis GbR (limited liability)\n    * @license MIT\n    */\n  \nimport { NodeSelection } from 'prosemirror-state';\n\nfunction createCell(cellType, cellContent) {\n  if (cellContent) {\n    return cellType.createChecked(null, cellContent);\n  }\n\n  return cellType.createAndFill();\n}\n\nfunction getTableNodeTypes(schema) {\n  if (schema.cached.tableNodeTypes) {\n    return schema.cached.tableNodeTypes;\n  }\n\n  const roles = {};\n  Object.keys(schema.nodes).forEach(type => {\n    const nodeType = schema.nodes[type];\n\n    if (nodeType.spec.tableRole) {\n      roles[nodeType.spec.tableRole] = nodeType;\n    }\n  }); // eslint-disable-next-line\n\n  schema.cached.tableNodeTypes = roles;\n  return roles;\n}\n\nfunction createTable(schema, rowsCount, colsCount, withHeaderRow, cellContent) {\n  const types = getTableNodeTypes(schema);\n  const headerCells = [];\n  const cells = [];\n\n  for (let index = 0; index < colsCount; index += 1) {\n    const cell = createCell(types.cell, cellContent);\n\n    if (cell) {\n      cells.push(cell);\n    }\n\n    if (withHeaderRow) {\n      const headerCell = createCell(types.header_cell, cellContent);\n\n      if (headerCell) {\n        headerCells.push(headerCell);\n      }\n    }\n  }\n\n  const rows = [];\n\n  for (let index = 0; index < rowsCount; index += 1) {\n    rows.push(types.row.createChecked(null, withHeaderRow && index === 0 ? headerCells : cells));\n  }\n\n  return types.table.createChecked(null, rows);\n}\n\nfunction equalNodeType(nodeType, node) {\n  return Array.isArray(nodeType) && nodeType.indexOf(node.type) > -1 || node.type === nodeType;\n}\n\nfunction flatten(node) {\n  // eslint-disable-next-line\n  const descend = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  if (!node) {\n    throw new Error('Invalid \"node\" parameter');\n  }\n\n  const result = []; // eslint-disable-next-line\n\n  node.descendants((child, pos) => {\n    result.push({\n      node: child,\n      pos\n    });\n\n    if (!descend) {\n      return false;\n    }\n  });\n  return result;\n}\n\nfunction findChildren(node, predicate, descend) {\n  if (!node) {\n    throw new Error('Invalid \"node\" parameter');\n  } else if (!predicate) {\n    throw new Error('Invalid \"predicate\" parameter');\n  }\n\n  return flatten(node, descend).filter(child => predicate(child.node));\n}\n\nfunction findBlockNodes(node, descend) {\n  return findChildren(node, child => child.isBlock, descend);\n}\n\n// eslint-disable-next-line\nfunction findParentNodeClosestToPos($pos, predicate) {\n  for (let i = $pos.depth; i > 0; i -= 1) {\n    const node = $pos.node(i);\n\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node\n      };\n    }\n  }\n}\n\nfunction findParentNode(predicate) {\n  return selection => findParentNodeClosestToPos(selection.$from, predicate);\n}\n\nfunction isNodeSelection(selection) {\n  return selection instanceof NodeSelection;\n}\n\nfunction findSelectedNodeOfType(nodeType) {\n  // eslint-disable-next-line\n  return function (selection) {\n    if (isNodeSelection(selection)) {\n      const {\n        node\n      } = selection;\n      const {\n        $from\n      } = selection;\n\n      if (equalNodeType(nodeType, node)) {\n        return {\n          node,\n          pos: $from.pos,\n          depth: $from.depth\n        };\n      }\n    }\n  };\n}\n\nfunction getMarkAttrs(state, type) {\n  const {\n    from,\n    to\n  } = state.selection;\n  let marks = [];\n  state.doc.nodesBetween(from, to, node => {\n    marks = [...marks, ...node.marks];\n  });\n  const mark = marks.find(markItem => markItem.type.name === type.name);\n\n  if (mark) {\n    return mark.attrs;\n  }\n\n  return {};\n}\n\nfunction getMarkRange($pos = null, type = null) {\n  if (!$pos || !type) {\n    return false;\n  }\n\n  const start = $pos.parent.childAfter($pos.parentOffset);\n\n  if (!start.node) {\n    return false;\n  }\n\n  const link = start.node.marks.find(mark => mark.type === type);\n\n  if (!link) {\n    return false;\n  }\n\n  let startIndex = $pos.index();\n  let startPos = $pos.start() + start.offset;\n  let endIndex = startIndex + 1;\n  let endPos = startPos + start.node.nodeSize;\n\n  while (startIndex > 0 && link.isInSet($pos.parent.child(startIndex - 1).marks)) {\n    startIndex -= 1;\n    startPos -= $pos.parent.child(startIndex).nodeSize;\n  }\n\n  while (endIndex < $pos.parent.childCount && link.isInSet($pos.parent.child(endIndex).marks)) {\n    endPos += $pos.parent.child(endIndex).nodeSize;\n    endIndex += 1;\n  }\n\n  return {\n    from: startPos,\n    to: endPos\n  };\n}\n\nfunction getNodeAttrs(state, type) {\n  const {\n    from,\n    to\n  } = state.selection;\n  let nodes = [];\n  state.doc.nodesBetween(from, to, node => {\n    nodes = [...nodes, node];\n  });\n  const node = nodes.reverse().find(nodeItem => nodeItem.type.name === type.name);\n\n  if (node) {\n    return node.attrs;\n  }\n\n  return {};\n}\n\nfunction markIsActive(state, type) {\n  const {\n    from,\n    $from,\n    to,\n    empty\n  } = state.selection;\n\n  if (empty) {\n    return !!type.isInSet(state.storedMarks || $from.marks());\n  }\n\n  return !!state.doc.rangeHasMark(from, to, type);\n}\n\nfunction nodeEqualsType({\n  types,\n  node\n}) {\n  return Array.isArray(types) && types.includes(node.type) || node.type === types;\n}\n\nfunction nodeIsActive(state, type, attrs = {}) {\n  const predicate = node => node.type === type;\n\n  const node = findSelectedNodeOfType(type)(state.selection) || findParentNode(predicate)(state.selection);\n\n  if (!Object.keys(attrs).length || !node) {\n    return !!node;\n  }\n\n  return node.node.hasMarkup(type, { ...node.node.attrs,\n    ...attrs\n  });\n}\n\nexport { createCell, createTable, equalNodeType, findBlockNodes, findChildren, findParentNode, findParentNodeClosestToPos, findSelectedNodeOfType, flatten, getMarkAttrs, getMarkRange, getNodeAttrs, getTableNodeTypes, isNodeSelection, markIsActive, nodeEqualsType, nodeIsActive };\n","import Button from 'flarum/common/components/Button';\r\nimport extractText from 'flarum/common/utils/extractText';\r\nimport Stream from 'flarum/common/utils/Stream';\r\nimport Dropdown from 'flarum/common/components/Dropdown';\r\nimport Tooltip from 'flarum/common/components/Tooltip';\r\nimport icon from 'flarum/common/helpers/icon';\r\nimport styleSelectedText from 'flarum/common/utils/styleSelectedText';\r\nimport ItemList from 'flarum/common/utils/ItemList';\r\n\r\nimport { removeMark, updateMark } from 'tiptap-commands';\r\n\r\n//borrowed from askvortsov1/flarum-rich-text\r\nexport default class InsertReferenceDropdown extends Dropdown  {\r\n  static initAttrs(attrs) {\r\n    attrs.buttonClassName = 'Button Button--icon Button--link Button--menuDropdown';\r\n  }\r\n  \r\n  oninit(vnode) {\r\n    super.oninit(vnode);\r\n    this.state = this.attrs.state;\r\n\r\n    this.text = Stream('');\r\n    this.href = Stream('');\r\n\r\n    // this.state.addItem(\r\n    //   this.attrs.type,\r\n    //   (state, dispatch) => {\r\n    //     this.command(state, dispatch);\r\n    //   },\r\n    //   this.onEditorUpdate.bind(this)\r\n    // );\r\n\r\n    this.selectionEmpty = true;\r\n  }\r\n\r\n  oncreate(vnode) {\r\n    super.oncreate(vnode);\r\n\r\n    this.$().on('click', (e) => {\r\n      if ($('.App').is('.mobile-safari')) {\r\n        // Mobile Safari doesn't support fixed items\r\n        // So, we wrap them in a modal.\r\n        app.modal.show(SafariModalHack, {\r\n          title: this.attrs.tooltip,\r\n          vnodeContent: this.fields().toArray(),\r\n          onsubmit: this.onsubmit.bind(this),\r\n        });\r\n        e.stopPropagation();\r\n      }\r\n    });\r\n\r\n    this.$().on('shown.bs.dropdown', () => {\r\n      this.$('.Dropdown-menu').find('input, select, textarea').first().focus().select();\r\n    });\r\n  }\r\n\r\n  getButtonContent(children) {\r\n    return (\r\n      <Tooltip text={this.attrs.tooltip}>\r\n        <span>{icon(this.attrs.icon)}</span>\r\n      </Tooltip>\r\n    );\r\n  }\r\n\r\n  getMenu(items) {\r\n    return (\r\n      <ul className={'Dropdown-menu dropdown-menu FormDropdown'}>\r\n        <form className=\"Form\" onsubmit={this.onsubmit.bind(this)}>\r\n          {this.fields().toArray()}\r\n        </form>\r\n      </ul>\r\n    );\r\n  }\r\n\r\n  onsubmit(e) {\r\n    // Here for the safari workaround\r\n    app.modal.close();\r\n    e.preventDefault();\r\n    $('body').trigger('click');\r\n    this.insert(e);\r\n    app.composer.editor.focus();\r\n  }\r\n\r\n  fields() {\r\n    const items = new ItemList();\r\n\r\n    items.add(\r\n      'insert',\r\n      <Button type=\"submit\" className=\"Button Button--primary\">\r\n        {app.translator.trans('flarum-references.forum.composer.insert_button')}\r\n      </Button>\r\n    );\r\n\r\n    if (this.selectionEmpty && !this.active) {\r\n      items.add(\r\n        'text',\r\n        <div className=\"Form-group\">\r\n          <input\r\n            className=\"FormControl\"\r\n            name=\"text\"\r\n            placeholder={extractText(app.translator.trans('flarum-references.forum.composer.insert_link.text_placeholder'))}\r\n            bidi={this.text}\r\n            required\r\n          />\r\n        </div>,\r\n        10\r\n      );\r\n    }\r\n\r\n    items.add(\r\n      'href',\r\n      <div className=\"Form-group\">\r\n        <input\r\n          className=\"FormControl\"\r\n          name=\"href\"\r\n          type=\"url\"\r\n          placeholder={extractText(app.translator.trans('flarum-references.forum.composer.insert_link.href_placeholder'))}\r\n          bidi={this.href}\r\n          required\r\n        />\r\n      </div>,\r\n      10\r\n    );\r\n\r\n    if (this.active) {\r\n      items.add(\r\n        'remove',\r\n        <Button onclick={this.remove.bind(this)} className=\"Button Button--danger\">\r\n          {app.translator.trans('flarum-references.forum.composer.insert_link.remove_button')}\r\n        </Button>,\r\n        -10\r\n      );\r\n    }\r\n\r\n    return items;\r\n  }\r\n\r\n  insert(e) {\r\n    const linkAttrs = { href: this.href(), text: this.text() };\r\n\r\n    if (this.selectionEmpty && !this.active) {\r\n      //this.command = dispatch(state.tr.replaceSelectionWith(state.schema.text(this.text(), [this.attrs.mark.create(linkAttrs)]), false));\r\n\r\n      styleSelectedText(app.composer.editor.el, \r\n        //{ prefix: '![', suffix: '](https://)', replaceNext: 'https://', scanFor: 'https?://' }\r\n        { prefix: '[ref][' + linkAttrs.text, suffix: ']('+ linkAttrs.href +')[/ref]' }\r\n      );\r\n      //$('.TextEditor-editor')\r\n      this.text('');\r\n      this.href('');\r\n    } else {\r\n      this.command = updateMark(this.attrs.mark, linkAttrs);\r\n    }\r\n  }\r\n\r\n  remove(e) {\r\n    $('body').trigger('click');\r\n    this.command = removeMark(this.attrs.mark);\r\n    this.state.run(this.attrs.type);\r\n    app.composer.editor.focus();\r\n  }\r\n\r\n  onEditorUpdate() {\r\n    this.active = !!this.state.markActive(this.attrs.mark);\r\n    this.$('.Dropdown-toggle').toggleClass('active', this.active);\r\n\r\n    const attrs = this.state.markAttrs(this.attrs.mark);\r\n\r\n    this.href(attrs.href);\r\n    this.text(attrs.text);\r\n\r\n    this.selectionEmpty = this.state.selectionEmpty();\r\n  }\r\n}","import {extend} from 'flarum/common/extend';\r\nimport app from 'flarum/app';\r\nimport InsertReferenceDropdown from './InsertReferenceDropdown';\r\nimport TextEditorButton from 'flarum/components/TextEditorButton';\r\nimport TextEditor from 'flarum/common/components/TextEditor';\r\nimport CommentPost from 'flarum/forum/components/CommentPost';\r\n\r\napp.initializers.add('aradeid/flarum-references', () => {\r\n  extend(TextEditor.prototype, 'toolbarItems', function (items) {\r\n    //() => this.attrs.composer.editor.insertAtCursor(' :')\r\n    /*items.add(\r\n      'addReference',\r\n      (\r\n        <TextEditorButton onclick={addReference.bind(this)} icon=\"fas fa-paper-plane\">\r\n          {app.translator.trans('flarum-references.forum.composer.addReferenceButton')}\r\n        </TextEditorButton>\r\n      )\r\n    );*/\r\n    \r\n    items.add(\r\n      'link',\r\n      InsertReferenceDropdown.component({\r\n        type: 'link',\r\n        icon: 'fas fa-link',\r\n        tooltip: app.translator.trans('flarum-references.forum.composer.addReferenceButton'),\r\n        state: this.attrs.state,\r\n      }),\r\n      50\r\n    );\r\n\r\n    return items;\r\n  });\r\n\r\n  // Implementarea accesarii link-urilor interne in articole si comentarii\r\n  extend(CommentPost.prototype, ['oncreate', 'onupdate'], function () {\r\n    const baseUrl = app.forum.attribute('baseUrl');\r\n    const postBody = this.element.querySelector('.Post-body');\r\n    const elements = postBody.querySelectorAll('a');\r\n\r\n    for (const link of elements) {\r\n      if (link.classList.contains('PostMention')) {\r\n          continue;\r\n      }\r\n\r\n      const href = link.href;\r\n      \r\n      if (!href.startsWith(baseUrl)) {\r\n        continue;\r\n      }\r\n      \r\n      const path = href.replace(baseUrl, '');\r\n      const elements = path.split('/');\r\n      const isFile = elements[elements.length-1].match(/(.*)\\.(.*)/i);\r\n      \r\n      if (isFile) {\r\n        continue;\r\n      }\r\n      \r\n      const separateId = elements[elements.length-1].split('#');\r\n      const referenceId = separateId[separateId.length - 1];\r\n\r\n      link.addEventListener('click', function (e) {\r\n          e.preventDefault();\r\n\r\n          var reference = document.getElementById(referenceId);\r\n          reference?.scrollIntoView({behavior: 'smooth'});\r\n      });\r\n    }\r\n  });\r\n});\r\n\r\nfunction addReference() {\r\n  styleSelectedText(app.composer.editor.el, \r\n    //{ prefix: '![', suffix: '](https://)', replaceNext: 'https://', scanFor: 'https?://' }\r\n    { prefix: '[ref][', suffix: '](https://insertLinkHere)[/ref]' }\r\n  );\r\n}","module.exports = flarum.core.compat['app'];","module.exports = flarum.core.compat['common/components/Button'];","module.exports = flarum.core.compat['common/components/Dropdown'];","module.exports = flarum.core.compat['common/components/TextEditor'];","module.exports = flarum.core.compat['common/components/Tooltip'];","module.exports = flarum.core.compat['common/extend'];","module.exports = flarum.core.compat['common/helpers/icon'];","module.exports = flarum.core.compat['common/utils/ItemList'];","module.exports = flarum.core.compat['common/utils/Stream'];","module.exports = flarum.core.compat['common/utils/extractText'];","module.exports = flarum.core.compat['common/utils/styleSelectedText'];","module.exports = flarum.core.compat['components/TextEditorButton'];","module.exports = flarum.core.compat['forum/components/CommentPost'];"],"sourceRoot":""}